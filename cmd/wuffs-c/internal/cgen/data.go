// Code generated by running "go generate". DO NOT EDIT.

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cgen

const baseBasePublicH = "" +
	"// Copyright 2017 The Wuffs Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Wuffs assumes that:\n//  - converting a uint32_t to a size_t will never overflow.\n//  - converting a size_t to a uint64_t will never overflow.\n#ifdef __WORDSIZE\n#if (__WORDSIZE != 32) && (__WORDSIZE != 64)\n#error \"Wuffs requires a word size of either 32 or 64 bits\"\n#endif\n#endif\n\n// WUFFS_VERSION is the major.minor.patch v" +
	"ersion, as per https://semver.org/,\n// as a uint64_t. The major number is the high 32 bits. The minor number is the\n// middle 16 bits. The patch number is the low 16 bits. The version extension\n// (such as \"\", \"beta\" or \"rc.1\") is part of the string representation (such as\n// \"1.2.3-beta\") but not the uint64_t representation.\n//\n// All three of major, minor and patch being zero means that this is a\n// work-in-progress version, not a release version, and has no backwards or\n// forwards compatibility guarantees.\n//\n// !! Some code generation programs can override WUFFS_VERSION.\n#define WUFFS_VERSION ((uint64_t)0)\n#define WUFFS_VERSION_MAJOR ((uint64_t)0)\n#define WUFFS_VERSION_MINOR ((uint64_t)0)\n#define WUFFS_VERSION_PATCH ((uint64_t)0)\n#define WUFFS_VERSION_EXTENSION \"\"\n#define WUFFS_VERSION_STRING \"0.0.0\"\n\n// Define WUFFS_CONFIG__STATIC_FUNCTIONS to make all of Wuffs' functions have\n// static storage. The motivation is discussed in the \"ALLOW STATIC\n// IMPLEMENTATION\" section of\n// https://raw.githubuserconte" +
	"nt.com/nothings/stb/master/docs/stb_howto.txt\n#ifdef WUFFS_CONFIG__STATIC_FUNCTIONS\n#define WUFFS_BASE__MAYBE_STATIC static\n#else\n#define WUFFS_BASE__MAYBE_STATIC\n#endif\n\n// Clang also defines \"__GNUC__\".\n#if defined(__GNUC__)\n#define WUFFS_BASE__WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#else\n#define WUFFS_BASE__WARN_UNUSED_RESULT\n#endif\n\n// wuffs_base__empty_struct is used when a Wuffs function returns an empty\n// struct. In C, if a function f returns void, you can't say \"x = f()\", but in\n// Wuffs, if a function g returns empty, you can say \"y = g()\".\ntypedef struct {\n  // private_impl is a placeholder field. It isn't explicitly used, except that\n  // without it, the sizeof a struct with no fields can differ across C/C++\n  // compilers, and it is undefined behavior in C99. For example, gcc says that\n  // the sizeof an empty struct is 0, and g++ says that it is 1. This leads to\n  // ABI incompatibility if a Wuffs .c file is processed by one compiler and\n  // its .h file with another compiler.\n  " +
	"//\n  // Instead, we explicitly insert an otherwise unused field, so that the\n  // sizeof this struct is always 1.\n  uint8_t private_impl;\n} wuffs_base__empty_struct;\n\n// wuffs_base__utility is a placeholder receiver type. It enables what Java\n// calls static methods, as opposed to regular methods.\ntypedef struct {\n  // private_impl is a placeholder field. It isn't explicitly used, except that\n  // without it, the sizeof a struct with no fields can differ across C/C++\n  // compilers, and it is undefined behavior in C99. For example, gcc says that\n  // the sizeof an empty struct is 0, and g++ says that it is 1. This leads to\n  // ABI incompatibility if a Wuffs .c file is processed by one compiler and\n  // its .h file with another compiler.\n  //\n  // Instead, we explicitly insert an otherwise unused field, so that the\n  // sizeof this struct is always 1.\n  uint8_t private_impl;\n} wuffs_base__utility;\n\n" +
	"" +
	"// --------\n\n// A status is either NULL (meaning OK) or a string message. That message is\n// human-readable, for programmers, but it is not for end users. It is not\n// localized, and does not contain additional contextual information such as a\n// source filename.\n//\n// Status strings are statically allocated and should never be free'd. They can\n// be compared by the == operator and not just by strcmp.\ntypedef const char* wuffs_base__status;\n\n// !! INSERT wuffs_base__status names.\n\nstatic inline bool  //\nwuffs_base__status__is_error(wuffs_base__status z) {\n  return z && (*z == '?');\n}\n\nstatic inline bool  //\nwuffs_base__status__is_ok(wuffs_base__status z) {\n  return z == NULL;\n}\n\nstatic inline bool  //\nwuffs_base__status__is_suspension(wuffs_base__status z) {\n  return z && (*z == '$');\n}\n\nstatic inline bool  //\nwuffs_base__status__is_warning(wuffs_base__status z) {\n  return z && (*z != '$') && (*z != '?');\n}\n\n" +
	"" +
	"// --------\n\n// Flicks are a unit of time. One flick (frame-tick) is 1 / 705_600_000 of a\n// second. See https://github.com/OculusVR/Flicks\ntypedef int64_t wuffs_base__flicks;\n\n#define WUFFS_BASE__FLICKS_PER_SECOND ((uint64_t)705600000)\n#define WUFFS_BASE__FLICKS_PER_MILLISECOND ((uint64_t)705600)\n\n" +
	"" +
	"// ---------------- Numeric Types\n\nstatic inline uint8_t  //\nwuffs_base__u8__min(uint8_t x, uint8_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint8_t  //\nwuffs_base__u8__max(uint8_t x, uint8_t y) {\n  return x > y ? x : y;\n}\n\nstatic inline uint16_t  //\nwuffs_base__u16__min(uint16_t x, uint16_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint16_t  //\nwuffs_base__u16__max(uint16_t x, uint16_t y) {\n  return x > y ? x : y;\n}\n\nstatic inline uint32_t  //\nwuffs_base__u32__min(uint32_t x, uint32_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint32_t  //\nwuffs_base__u32__max(uint32_t x, uint32_t y) {\n  return x > y ? x : y;\n}\n\nstatic inline uint64_t  //\nwuffs_base__u64__min(uint64_t x, uint64_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint64_t  //\nwuffs_base__u64__max(uint64_t x, uint64_t y) {\n  return x > y ? x : y;\n}\n\n" +
	"" +
	"// --------\n\n// Saturating arithmetic (sat_add, sat_sub) branchless bit-twiddling algorithms\n// are per https://locklessinc.com/articles/sat_arithmetic/\n//\n// It is important that the underlying types are unsigned integers, as signed\n// integer arithmetic overflow is undefined behavior in C.\n\nstatic inline uint8_t  //\nwuffs_base__u8__sat_add(uint8_t x, uint8_t y) {\n  uint8_t res = x + y;\n  res |= -(res < x);\n  return res;\n}\n\nstatic inline uint8_t  //\nwuffs_base__u8__sat_sub(uint8_t x, uint8_t y) {\n  uint8_t res = x - y;\n  res &= -(res <= x);\n  return res;\n}\n\nstatic inline uint16_t  //\nwuffs_base__u16__sat_add(uint16_t x, uint16_t y) {\n  uint16_t res = x + y;\n  res |= -(res < x);\n  return res;\n}\n\nstatic inline uint16_t  //\nwuffs_base__u16__sat_sub(uint16_t x, uint16_t y) {\n  uint16_t res = x - y;\n  res &= -(res <= x);\n  return res;\n}\n\nstatic inline uint32_t  //\nwuffs_base__u32__sat_add(uint32_t x, uint32_t y) {\n  uint32_t res = x + y;\n  res |= -(res < x);\n  return res;\n}\n\nstatic inline uint32_t  //\nwuffs_base_" +
	"_u32__sat_sub(uint32_t x, uint32_t y) {\n  uint32_t res = x - y;\n  res &= -(res <= x);\n  return res;\n}\n\nstatic inline uint64_t  //\nwuffs_base__u64__sat_add(uint64_t x, uint64_t y) {\n  uint64_t res = x + y;\n  res |= -(res < x);\n  return res;\n}\n\nstatic inline uint64_t  //\nwuffs_base__u64__sat_sub(uint64_t x, uint64_t y) {\n  uint64_t res = x - y;\n  res &= -(res <= x);\n  return res;\n}\n\n" +
	"" +
	"// --------\n\n// Clang also defines \"__GNUC__\".\n\nstatic inline uint16_t  //\nwuffs_base__u16__byte_swapped(uint16_t x) {\n#if defined(__GNUC__)\n  return __builtin_bswap16(x);\n#else\n  return (x >> 8) | (x << 8);\n#endif\n}\n\nstatic inline uint32_t  //\nwuffs_base__u32__byte_swapped(uint32_t x) {\n#if defined(__GNUC__)\n  return __builtin_bswap32(x);\n#else\n  static const uint32_t mask8 = 0x00FF00FF;\n  x = ((x >> 8) & mask8) | ((x & mask8) << 8);\n  return (x >> 16) | (x << 16);\n#endif\n}\n\nstatic inline uint64_t  //\nwuffs_base__u64__byte_swapped(uint64_t x) {\n#if defined(__GNUC__)\n  return __builtin_bswap64(x);\n#else\n  static const uint64_t mask8 = 0x00FF00FF00FF00FF;\n  static const uint64_t mask16 = 0x0000FFFF0000FFFF;\n  x = ((x >> 8) & mask8) | ((x & mask8) << 8);\n  x = ((x >> 16) & mask16) | ((x & mask16) << 16);\n  return (x >> 32) | (x << 32);\n#endif\n}\n\n" +
	"" +
	"// ---------------- Slices and Tables\n\n// WUFFS_BASE__SLICE is a 1-dimensional buffer.\n//\n// A value with all fields NULL or zero is a valid, empty slice.\n#define WUFFS_BASE__SLICE(T) \\\n  struct {                   \\\n    T* ptr;                  \\\n    size_t len;              \\\n  }\n\n// WUFFS_BASE__TABLE is a 2-dimensional buffer.\n//\n// A value with all fields NULL or zero is a valid, empty table.\n#define WUFFS_BASE__TABLE(T) \\\n  struct {                   \\\n    T* ptr;                  \\\n    size_t width;            \\\n    size_t height;           \\\n    size_t stride;           \\\n  }\n\ntypedef WUFFS_BASE__SLICE(uint8_t) wuffs_base__slice_u8;\ntypedef WUFFS_BASE__SLICE(uint16_t) wuffs_base__slice_u16;\ntypedef WUFFS_BASE__SLICE(uint32_t) wuffs_base__slice_u32;\ntypedef WUFFS_BASE__SLICE(uint64_t) wuffs_base__slice_u64;\n\ntypedef WUFFS_BASE__TABLE(uint8_t) wuffs_base__table_u8;\ntypedef WUFFS_BASE__TABLE(uint16_t) wuffs_base__table_u16;\ntypedef WUFFS_BASE__TABLE(uint32_t) wuffs_base__table_u32;\ntypedef WUFFS_BASE__TAB" +
	"LE(uint64_t) wuffs_base__table_u64;\n\n" +
	"" +
	"// ---------------- Ranges and Rects\n\n// Ranges are either inclusive (\"range_ii\") or exclusive (\"range_ie\") on the\n// high end. Both the \"ii\" and \"ie\" flavors are useful in practice.\n//\n// The \"ei\" and \"ee\" flavors also exist in theory, but aren't widely used. In\n// Wuffs, the low end is always inclusive.\n//\n// The \"ii\" (closed interval) flavor is useful when refining e.g. \"the set of\n// all uint32_t values\" to a contiguous subset: \"uint32_t values in the closed\n// interval [M, N]\", for uint32_t values M and N. An unrefined type (in other\n// words, the set of all uint32_t values) is not representable in the \"ie\"\n// flavor because if N equals ((1<<32) - 1) then (N + 1) will overflow.\n//\n// On the other hand, the \"ie\" (half-open interval) flavor is recommended by\n// Dijkstra's \"Why numbering should start at zero\" at\n// http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF and a further\n// discussion of motivating rationale is at\n// https://www.quora.com/Why-are-Python-ranges-half-open-exclusive-instead-of-close" +
	"d-inclusive\n//\n// For example, with \"ie\", the number of elements in \"uint32_t values in the\n// half-open interval [M, N)\" is equal to max(0, N-M). Furthermore, that number\n// of elements (in one dimension, a length, in two dimensions, a width or\n// height) is itself representable as a uint32_t without overflow, again for\n// uint32_t values M and N. In the contrasting \"ii\" flavor, the length of the\n// closed interval [0, (1<<32) - 1] is 1<<32, which cannot be represented as a\n// uint32_t. In Wuffs, because of this potential overflow, the \"ie\" flavor has\n// length / width / height methods, but the \"ii\" flavor does not.\n//\n// It is valid for min > max (for range_ii) or for min >= max (for range_ie),\n// in which case the range is empty. There are multiple representations of an\n// empty range.\n\ntypedef struct wuffs_base__range_ii_u32__struct {\n  uint32_t min_incl;\n  uint32_t max_incl;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__range_ii_u32__struct s);\n  inline bool contains(uint" +
	"32_t x);\n  inline wuffs_base__range_ii_u32__struct intersect(\n      wuffs_base__range_ii_u32__struct s);\n  inline wuffs_base__range_ii_u32__struct unite(\n      wuffs_base__range_ii_u32__struct s);\n#endif  // __cplusplus\n\n} wuffs_base__range_ii_u32;\n\nstatic inline bool  //\nwuffs_base__range_ii_u32__is_empty(wuffs_base__range_ii_u32* r) {\n  return r->min_incl > r->max_incl;\n}\n\nstatic inline bool  //\nwuffs_base__range_ii_u32__equals(wuffs_base__range_ii_u32* r,\n                                 wuffs_base__range_ii_u32 s) {\n  return (r->min_incl == s.min_incl && r->max_incl == s.max_incl) ||\n         (wuffs_base__range_ii_u32__is_empty(r) &&\n          wuffs_base__range_ii_u32__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__range_ii_u32__contains(wuffs_base__range_ii_u32* r, uint32_t x) {\n  return (r->min_incl <= x) && (x <= r->max_incl);\n}\n\nstatic inline  //\n    wuffs_base__range_ii_u32\n    wuffs_base__range_ii_u32__intersect(wuffs_base__range_ii_u32* r,\n                                        wuffs_base__r" +
	"ange_ii_u32 s) {\n  wuffs_base__range_ii_u32 t;\n  t.min_incl = wuffs_base__u32__max(r->min_incl, s.min_incl);\n  t.max_incl = wuffs_base__u32__min(r->max_incl, s.max_incl);\n  return t;\n}\n\nstatic inline  //\n    wuffs_base__range_ii_u32\n    wuffs_base__range_ii_u32__unite(wuffs_base__range_ii_u32* r,\n                                    wuffs_base__range_ii_u32 s) {\n  if (wuffs_base__range_ii_u32__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__range_ii_u32__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__range_ii_u32 t;\n  t.min_incl = wuffs_base__u32__min(r->min_incl, s.min_incl);\n  t.max_incl = wuffs_base__u32__max(r->max_incl, s.max_incl);\n  return t;\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__range_ii_u32::is_empty() {\n  return wuffs_base__range_ii_u32__is_empty(this);\n}\n\ninline bool  //\nwuffs_base__range_ii_u32::equals(wuffs_base__range_ii_u32 s) {\n  return wuffs_base__range_ii_u32__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__range_ii_u32::contains(uint32_t x) {\n  return wuffs_base__range_ii_u" +
	"32__contains(this, x);\n}\n\ninline wuffs_base__range_ii_u32  //\nwuffs_base__range_ii_u32::intersect(wuffs_base__range_ii_u32 s) {\n  return wuffs_base__range_ii_u32__intersect(this, s);\n}\n\ninline wuffs_base__range_ii_u32  //\nwuffs_base__range_ii_u32::unite(wuffs_base__range_ii_u32 s) {\n  return wuffs_base__range_ii_u32__unite(this, s);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct wuffs_base__range_ie_u32__struct {\n  uint32_t min_incl;\n  uint32_t max_excl;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__range_ie_u32__struct s);\n  inline bool contains(uint32_t x);\n  inline wuffs_base__range_ie_u32__struct intersect(\n      wuffs_base__range_ie_u32__struct s);\n  inline wuffs_base__range_ie_u32__struct unite(\n      wuffs_base__range_ie_u32__struct s);\n  inline uint32_t length();\n#endif  // __cplusplus\n\n} wuffs_base__range_ie_u32;\n\nstatic inline bool  //\nwuffs_base__range_ie_u32__is_empty(wuffs_base__range_ie_u32* r) {\n  return r->min_incl >= r->max_excl;\n}\n\nstatic inline bool  //\nwuffs_base__range_ie_u32__equals(wuffs_base__range_ie_u32* r,\n                                 wuffs_base__range_ie_u32 s) {\n  return (r->min_incl == s.min_incl && r->max_excl == s.max_excl) ||\n         (wuffs_base__range_ie_u32__is_empty(r) &&\n          wuffs_base__range_ie_u32__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__range_ie_u32__contains(w" +
	"uffs_base__range_ie_u32* r, uint32_t x) {\n  return (r->min_incl <= x) && (x < r->max_excl);\n}\n\nstatic inline wuffs_base__range_ie_u32  //\nwuffs_base__range_ie_u32__intersect(wuffs_base__range_ie_u32* r,\n                                    wuffs_base__range_ie_u32 s) {\n  wuffs_base__range_ie_u32 t;\n  t.min_incl = wuffs_base__u32__max(r->min_incl, s.min_incl);\n  t.max_excl = wuffs_base__u32__min(r->max_excl, s.max_excl);\n  return t;\n}\n\nstatic inline wuffs_base__range_ie_u32  //\nwuffs_base__range_ie_u32__unite(wuffs_base__range_ie_u32* r,\n                                wuffs_base__range_ie_u32 s) {\n  if (wuffs_base__range_ie_u32__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__range_ie_u32__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__range_ie_u32 t;\n  t.min_incl = wuffs_base__u32__min(r->min_incl, s.min_incl);\n  t.max_excl = wuffs_base__u32__max(r->max_excl, s.max_excl);\n  return t;\n}\n\nstatic inline uint32_t  //\nwuffs_base__range_ie_u32__length(wuffs_base__range_ie_u32* r) {\n  return wuffs_base__u32__sa" +
	"t_sub(r->max_excl, r->min_incl);\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__range_ie_u32::is_empty() {\n  return wuffs_base__range_ie_u32__is_empty(this);\n}\n\ninline bool  //\nwuffs_base__range_ie_u32::equals(wuffs_base__range_ie_u32 s) {\n  return wuffs_base__range_ie_u32__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__range_ie_u32::contains(uint32_t x) {\n  return wuffs_base__range_ie_u32__contains(this, x);\n}\n\ninline wuffs_base__range_ie_u32  //\nwuffs_base__range_ie_u32::intersect(wuffs_base__range_ie_u32 s) {\n  return wuffs_base__range_ie_u32__intersect(this, s);\n}\n\ninline wuffs_base__range_ie_u32  //\nwuffs_base__range_ie_u32::unite(wuffs_base__range_ie_u32 s) {\n  return wuffs_base__range_ie_u32__unite(this, s);\n}\n\ninline uint32_t  //\nwuffs_base__range_ie_u32::length() {\n  return wuffs_base__range_ie_u32__length(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct wuffs_base__range_ii_u64__struct {\n  uint64_t min_incl;\n  uint64_t max_incl;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__range_ii_u64__struct s);\n  inline bool contains(uint64_t x);\n  inline wuffs_base__range_ii_u64__struct intersect(\n      wuffs_base__range_ii_u64__struct s);\n  inline wuffs_base__range_ii_u64__struct unite(\n      wuffs_base__range_ii_u64__struct s);\n#endif  // __cplusplus\n\n} wuffs_base__range_ii_u64;\n\nstatic inline bool  //\nwuffs_base__range_ii_u64__is_empty(wuffs_base__range_ii_u64* r) {\n  return r->min_incl > r->max_incl;\n}\n\nstatic inline bool  //\nwuffs_base__range_ii_u64__equals(wuffs_base__range_ii_u64* r,\n                                 wuffs_base__range_ii_u64 s) {\n  return (r->min_incl == s.min_incl && r->max_incl == s.max_incl) ||\n         (wuffs_base__range_ii_u64__is_empty(r) &&\n          wuffs_base__range_ii_u64__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__range_ii_u64__contains(wuffs_base__range_ii_u64* r, u" +
	"int64_t x) {\n  return (r->min_incl <= x) && (x <= r->max_incl);\n}\n\nstatic inline wuffs_base__range_ii_u64  //\nwuffs_base__range_ii_u64__intersect(wuffs_base__range_ii_u64* r,\n                                    wuffs_base__range_ii_u64 s) {\n  wuffs_base__range_ii_u64 t;\n  t.min_incl = wuffs_base__u64__max(r->min_incl, s.min_incl);\n  t.max_incl = wuffs_base__u64__min(r->max_incl, s.max_incl);\n  return t;\n}\n\nstatic inline wuffs_base__range_ii_u64  //\nwuffs_base__range_ii_u64__unite(wuffs_base__range_ii_u64* r,\n                                wuffs_base__range_ii_u64 s) {\n  if (wuffs_base__range_ii_u64__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__range_ii_u64__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__range_ii_u64 t;\n  t.min_incl = wuffs_base__u64__min(r->min_incl, s.min_incl);\n  t.max_incl = wuffs_base__u64__max(r->max_incl, s.max_incl);\n  return t;\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__range_ii_u64::is_empty() {\n  return wuffs_base__range_ii_u64__is_empty(this);\n}\n\ninline bool  //\nwu" +
	"ffs_base__range_ii_u64::equals(wuffs_base__range_ii_u64 s) {\n  return wuffs_base__range_ii_u64__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__range_ii_u64::contains(uint64_t x) {\n  return wuffs_base__range_ii_u64__contains(this, x);\n}\n\ninline wuffs_base__range_ii_u64  //\nwuffs_base__range_ii_u64::intersect(wuffs_base__range_ii_u64 s) {\n  return wuffs_base__range_ii_u64__intersect(this, s);\n}\n\ninline wuffs_base__range_ii_u64  //\nwuffs_base__range_ii_u64::unite(wuffs_base__range_ii_u64 s) {\n  return wuffs_base__range_ii_u64__unite(this, s);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct wuffs_base__range_ie_u64__struct {\n  uint64_t min_incl;\n  uint64_t max_excl;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__range_ie_u64__struct s);\n  inline bool contains(uint64_t x);\n  inline wuffs_base__range_ie_u64__struct intersect(\n      wuffs_base__range_ie_u64__struct s);\n  inline wuffs_base__range_ie_u64__struct unite(\n      wuffs_base__range_ie_u64__struct s);\n  inline uint64_t length();\n#endif  // __cplusplus\n\n} wuffs_base__range_ie_u64;\n\nstatic inline bool  //\nwuffs_base__range_ie_u64__is_empty(wuffs_base__range_ie_u64* r) {\n  return r->min_incl >= r->max_excl;\n}\n\nstatic inline bool  //\nwuffs_base__range_ie_u64__equals(wuffs_base__range_ie_u64* r,\n                                 wuffs_base__range_ie_u64 s) {\n  return (r->min_incl == s.min_incl && r->max_excl == s.max_excl) ||\n         (wuffs_base__range_ie_u64__is_empty(r) &&\n          wuffs_base__range_ie_u64__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__range_ie_u64__contains(w" +
	"uffs_base__range_ie_u64* r, uint64_t x) {\n  return (r->min_incl <= x) && (x < r->max_excl);\n}\n\nstatic inline wuffs_base__range_ie_u64  //\nwuffs_base__range_ie_u64__intersect(wuffs_base__range_ie_u64* r,\n                                    wuffs_base__range_ie_u64 s) {\n  wuffs_base__range_ie_u64 t;\n  t.min_incl = wuffs_base__u64__max(r->min_incl, s.min_incl);\n  t.max_excl = wuffs_base__u64__min(r->max_excl, s.max_excl);\n  return t;\n}\n\nstatic inline wuffs_base__range_ie_u64  //\nwuffs_base__range_ie_u64__unite(wuffs_base__range_ie_u64* r,\n                                wuffs_base__range_ie_u64 s) {\n  if (wuffs_base__range_ie_u64__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__range_ie_u64__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__range_ie_u64 t;\n  t.min_incl = wuffs_base__u64__min(r->min_incl, s.min_incl);\n  t.max_excl = wuffs_base__u64__max(r->max_excl, s.max_excl);\n  return t;\n}\n\nstatic inline uint64_t  //\nwuffs_base__range_ie_u64__length(wuffs_base__range_ie_u64* r) {\n  return wuffs_base__u64__sa" +
	"t_sub(r->max_excl, r->min_incl);\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__range_ie_u64::is_empty() {\n  return wuffs_base__range_ie_u64__is_empty(this);\n}\n\ninline bool  //\nwuffs_base__range_ie_u64::equals(wuffs_base__range_ie_u64 s) {\n  return wuffs_base__range_ie_u64__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__range_ie_u64::contains(uint64_t x) {\n  return wuffs_base__range_ie_u64__contains(this, x);\n}\n\ninline wuffs_base__range_ie_u64  //\nwuffs_base__range_ie_u64::intersect(wuffs_base__range_ie_u64 s) {\n  return wuffs_base__range_ie_u64__intersect(this, s);\n}\n\ninline wuffs_base__range_ie_u64  //\nwuffs_base__range_ie_u64::unite(wuffs_base__range_ie_u64 s) {\n  return wuffs_base__range_ie_u64__unite(this, s);\n}\n\ninline uint64_t  //\nwuffs_base__range_ie_u64::length() {\n  return wuffs_base__range_ie_u64__length(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\n// wuffs_base__rect_ii_u32 is a rectangle (a 2-dimensional range) on the\n// integer grid. The \"ii\" means that the bounds are inclusive on the low end\n// and inclusive on the high end. It contains all points (x, y) such that\n// ((min_incl_x <= x) && (x <= max_incl_x)) and likewise for y.\n//\n// It is valid for min > max, in which case the rectangle is empty. There are\n// multiple representations of an empty rectangle.\n//\n// The X and Y axes increase right and down.\ntypedef struct wuffs_base__rect_ii_u32__struct {\n  uint32_t min_incl_x;\n  uint32_t min_incl_y;\n  uint32_t max_incl_x;\n  uint32_t max_incl_y;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__rect_ii_u32__struct s);\n  inline bool contains(uint32_t x, uint32_t y);\n  inline wuffs_base__rect_ii_u32__struct intersect(\n      wuffs_base__rect_ii_u32__struct s);\n  inline wuffs_base__rect_ii_u32__struct unite(\n      wuffs_base__rect_ii_u32__struct s);\n#endif  // __cplusplus\n\n} wuffs_base__rect_ii_u32;\n\nstatic inline b" +
	"ool  //\nwuffs_base__rect_ii_u32__is_empty(wuffs_base__rect_ii_u32* r) {\n  return (r->min_incl_x > r->max_incl_x) || (r->min_incl_y > r->max_incl_y);\n}\n\nstatic inline bool  //\nwuffs_base__rect_ii_u32__equals(wuffs_base__rect_ii_u32* r,\n                                wuffs_base__rect_ii_u32 s) {\n  return (r->min_incl_x == s.min_incl_x && r->min_incl_y == s.min_incl_y &&\n          r->max_incl_x == s.max_incl_x && r->max_incl_y == s.max_incl_y) ||\n         (wuffs_base__rect_ii_u32__is_empty(r) &&\n          wuffs_base__rect_ii_u32__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__rect_ii_u32__contains(wuffs_base__rect_ii_u32* r,\n                                  uint32_t x,\n                                  uint32_t y) {\n  return (r->min_incl_x <= x) && (x <= r->max_incl_x) && (r->min_incl_y <= y) &&\n         (y <= r->max_incl_y);\n}\n\nstatic inline wuffs_base__rect_ii_u32  //\nwuffs_base__rect_ii_u32__intersect(wuffs_base__rect_ii_u32* r,\n                                   wuffs_base__rect_ii_u32 s) {\n  wuffs_b" +
	"ase__rect_ii_u32 t;\n  t.min_incl_x = wuffs_base__u32__max(r->min_incl_x, s.min_incl_x);\n  t.min_incl_y = wuffs_base__u32__max(r->min_incl_y, s.min_incl_y);\n  t.max_incl_x = wuffs_base__u32__min(r->max_incl_x, s.max_incl_x);\n  t.max_incl_y = wuffs_base__u32__min(r->max_incl_y, s.max_incl_y);\n  return t;\n}\n\nstatic inline wuffs_base__rect_ii_u32  //\nwuffs_base__rect_ii_u32__unite(wuffs_base__rect_ii_u32* r,\n                               wuffs_base__rect_ii_u32 s) {\n  if (wuffs_base__rect_ii_u32__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__rect_ii_u32__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__rect_ii_u32 t;\n  t.min_incl_x = wuffs_base__u32__min(r->min_incl_x, s.min_incl_x);\n  t.min_incl_y = wuffs_base__u32__min(r->min_incl_y, s.min_incl_y);\n  t.max_incl_x = wuffs_base__u32__max(r->max_incl_x, s.max_incl_x);\n  t.max_incl_y = wuffs_base__u32__max(r->max_incl_y, s.max_incl_y);\n  return t;\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__rect_ii_u32::is_empty() {\n  return wuffs_base__rect_ii_u32__is" +
	"_empty(this);\n}\n\ninline bool  //\nwuffs_base__rect_ii_u32::equals(wuffs_base__rect_ii_u32 s) {\n  return wuffs_base__rect_ii_u32__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__rect_ii_u32::contains(uint32_t x, uint32_t y) {\n  return wuffs_base__rect_ii_u32__contains(this, x, y);\n}\n\ninline wuffs_base__rect_ii_u32  //\nwuffs_base__rect_ii_u32::intersect(wuffs_base__rect_ii_u32 s) {\n  return wuffs_base__rect_ii_u32__intersect(this, s);\n}\n\ninline wuffs_base__rect_ii_u32  //\nwuffs_base__rect_ii_u32::unite(wuffs_base__rect_ii_u32 s) {\n  return wuffs_base__rect_ii_u32__unite(this, s);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\n// wuffs_base__rect_ie_u32 is a rectangle (a 2-dimensional range) on the\n// integer grid. The \"ie\" means that the bounds are inclusive on the low end\n// and exclusive on the high end. It contains all points (x, y) such that\n// ((min_incl_x <= x) && (x < max_excl_x)) and likewise for y.\n//\n// It is valid for min >= max, in which case the rectangle is empty. There are\n// multiple representations of an empty rectangle, including a value with all\n// fields zero.\n//\n// The X and Y axes increase right and down.\ntypedef struct wuffs_base__rect_ie_u32__struct {\n  uint32_t min_incl_x;\n  uint32_t min_incl_y;\n  uint32_t max_excl_x;\n  uint32_t max_excl_y;\n\n#ifdef __cplusplus\n  inline bool is_empty();\n  inline bool equals(wuffs_base__rect_ie_u32__struct s);\n  inline bool contains(uint32_t x, uint32_t y);\n  inline wuffs_base__rect_ie_u32__struct intersect(\n      wuffs_base__rect_ie_u32__struct s);\n  inline wuffs_base__rect_ie_u32__struct unite(\n      wuffs_base__rect_ie_u32__struct s);\n  inline uint32_t width(" +
	");\n  inline uint32_t height();\n#endif  // __cplusplus\n\n} wuffs_base__rect_ie_u32;\n\nstatic inline bool  //\nwuffs_base__rect_ie_u32__is_empty(wuffs_base__rect_ie_u32* r) {\n  return (r->min_incl_x >= r->max_excl_x) || (r->min_incl_y >= r->max_excl_y);\n}\n\nstatic inline bool  //\nwuffs_base__rect_ie_u32__equals(wuffs_base__rect_ie_u32* r,\n                                wuffs_base__rect_ie_u32 s) {\n  return (r->min_incl_x == s.min_incl_x && r->min_incl_y == s.min_incl_y &&\n          r->max_excl_x == s.max_excl_x && r->max_excl_y == s.max_excl_y) ||\n         (wuffs_base__rect_ie_u32__is_empty(r) &&\n          wuffs_base__rect_ie_u32__is_empty(&s));\n}\n\nstatic inline bool  //\nwuffs_base__rect_ie_u32__contains(wuffs_base__rect_ie_u32* r,\n                                  uint32_t x,\n                                  uint32_t y) {\n  return (r->min_incl_x <= x) && (x < r->max_excl_x) && (r->min_incl_y <= y) &&\n         (y < r->max_excl_y);\n}\n\nstatic inline wuffs_base__rect_ie_u32  //\nwuffs_base__rect_ie_u32__intersect(wuf" +
	"fs_base__rect_ie_u32* r,\n                                   wuffs_base__rect_ie_u32 s) {\n  wuffs_base__rect_ie_u32 t;\n  t.min_incl_x = wuffs_base__u32__max(r->min_incl_x, s.min_incl_x);\n  t.min_incl_y = wuffs_base__u32__max(r->min_incl_y, s.min_incl_y);\n  t.max_excl_x = wuffs_base__u32__min(r->max_excl_x, s.max_excl_x);\n  t.max_excl_y = wuffs_base__u32__min(r->max_excl_y, s.max_excl_y);\n  return t;\n}\n\nstatic inline wuffs_base__rect_ie_u32  //\nwuffs_base__rect_ie_u32__unite(wuffs_base__rect_ie_u32* r,\n                               wuffs_base__rect_ie_u32 s) {\n  if (wuffs_base__rect_ie_u32__is_empty(r)) {\n    return s;\n  }\n  if (wuffs_base__rect_ie_u32__is_empty(&s)) {\n    return *r;\n  }\n  wuffs_base__rect_ie_u32 t;\n  t.min_incl_x = wuffs_base__u32__min(r->min_incl_x, s.min_incl_x);\n  t.min_incl_y = wuffs_base__u32__min(r->min_incl_y, s.min_incl_y);\n  t.max_excl_x = wuffs_base__u32__max(r->max_excl_x, s.max_excl_x);\n  t.max_excl_y = wuffs_base__u32__max(r->max_excl_y, s.max_excl_y);\n  return t;\n}\n\nstatic inlin" +
	"e uint32_t  //\nwuffs_base__rect_ie_u32__width(wuffs_base__rect_ie_u32* r) {\n  return wuffs_base__u32__sat_sub(r->max_excl_x, r->min_incl_x);\n}\n\nstatic inline uint32_t  //\nwuffs_base__rect_ie_u32__height(wuffs_base__rect_ie_u32* r) {\n  return wuffs_base__u32__sat_sub(r->max_excl_y, r->min_incl_y);\n}\n\n#ifdef __cplusplus\n\ninline bool  //\nwuffs_base__rect_ie_u32::is_empty() {\n  return wuffs_base__rect_ie_u32__is_empty(this);\n}\n\ninline bool  //\nwuffs_base__rect_ie_u32::equals(wuffs_base__rect_ie_u32 s) {\n  return wuffs_base__rect_ie_u32__equals(this, s);\n}\n\ninline bool  //\nwuffs_base__rect_ie_u32::contains(uint32_t x, uint32_t y) {\n  return wuffs_base__rect_ie_u32__contains(this, x, y);\n}\n\ninline wuffs_base__rect_ie_u32  //\nwuffs_base__rect_ie_u32::intersect(wuffs_base__rect_ie_u32 s) {\n  return wuffs_base__rect_ie_u32__intersect(this, s);\n}\n\ninline wuffs_base__rect_ie_u32  //\nwuffs_base__rect_ie_u32::unite(wuffs_base__rect_ie_u32 s) {\n  return wuffs_base__rect_ie_u32__unite(this, s);\n}\n\ninline uint32_t  //\nwuffs_" +
	"base__rect_ie_u32::width() {\n  return wuffs_base__rect_ie_u32__width(this);\n}\n\ninline uint32_t  //\nwuffs_base__rect_ie_u32::height() {\n  return wuffs_base__rect_ie_u32__height(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// ---------------- I/O\n\nstruct wuffs_base__io_buffer__struct;\n\ntypedef struct {\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    struct wuffs_base__io_buffer__struct* buf;\n    // The bounds values are typically NULL, when created by the Wuffs public\n    // API. NULL means that the callee substitutes the implicit bounds derived\n    // from buf.\n    uint8_t* mark;\n    uint8_t* limit;\n  } private_impl;\n} wuffs_base__io_reader;\n\ntypedef struct {\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    struct wuffs_base__io_buffer__struct* buf;\n    // The bounds values are typically NULL, when created by the Wuffs public\n    // API. NULL means that the callee substitutes the implicit bounds derived\n    // from buf.\n    uint8_t* mark;\n    uint8_t* limit;\n  } private_impl;\n} wuffs_base__io_writer;\n\n// wuffs_base__io_buffer is a 1-dimensio" +
	"nal buffer (a pointer and length), plus\n// additional indexes into that buffer, plus a buffer position and an opened /\n// closed flag.\n//\n// A value with all fields NULL or zero is a valid, empty buffer.\ntypedef struct wuffs_base__io_buffer__struct {\n  uint8_t* ptr;  // Pointer.\n  size_t len;    // Length.\n  size_t wi;     // Write index. Invariant: wi <= len.\n  size_t ri;     // Read  index. Invariant: ri <= wi.\n  uint64_t pos;  // Position of the buffer start relative to the stream start.\n  bool closed;   // No further writes are expected.\n\n#ifdef __cplusplus\n  inline void compact();\n  inline uint64_t io_position_reader();\n  inline uint64_t io_position_writer();\n  inline wuffs_base__io_reader reader();\n  inline wuffs_base__io_writer writer();\n#endif  // __cplusplus\n\n} wuffs_base__io_buffer;\n\n// wuffs_base__io_buffer__compact moves any written but unread bytes to the\n// start of the buffer.\nstatic inline void  //\nwuffs_base__io_buffer__compact(wuffs_base__io_buffer* buf) {\n  if (!buf || (buf->ri == 0)) {\n   " +
	" return;\n  }\n  buf->pos = wuffs_base__u64__sat_add(buf->pos, buf->ri);\n  size_t n = buf->wi - buf->ri;\n  if (n != 0) {\n    memmove(buf->ptr, buf->ptr + buf->ri, n);\n  }\n  buf->wi = n;\n  buf->ri = 0;\n}\n\nstatic inline uint64_t  //\nwuffs_base__io_buffer__io_position_reader(wuffs_base__io_buffer* buf) {\n  return buf ? wuffs_base__u64__sat_add(buf->pos, buf->ri) : 0;\n}\n\nstatic inline uint64_t  //\nwuffs_base__io_buffer__io_position_writer(wuffs_base__io_buffer* buf) {\n  return buf ? wuffs_base__u64__sat_add(buf->pos, buf->wi) : 0;\n}\n\nstatic inline wuffs_base__io_reader  //\nwuffs_base__io_buffer__reader(wuffs_base__io_buffer* buf) {\n  wuffs_base__io_reader ret = ((wuffs_base__io_reader){});\n  ret.private_impl.buf = buf;\n  return ret;\n}\n\nstatic inline wuffs_base__io_writer  //\nwuffs_base__io_buffer__writer(wuffs_base__io_buffer* buf) {\n  wuffs_base__io_writer ret = ((wuffs_base__io_writer){});\n  ret.private_impl.buf = buf;\n  return ret;\n}\n\n#ifdef __cplusplus\n\ninline void  //\nwuffs_base__io_buffer__struct::compact() {" +
	"\n  wuffs_base__io_buffer__compact(this);\n}\n\ninline uint64_t  //\nwuffs_base__io_buffer__struct::io_position_reader() {\n  return wuffs_base__io_buffer__io_position_reader(this);\n}\n\ninline uint64_t  //\nwuffs_base__io_buffer__struct::io_position_writer() {\n  return wuffs_base__io_buffer__io_position_writer(this);\n}\n\ninline wuffs_base__io_reader  //\nwuffs_base__io_buffer__struct::reader() {\n  return wuffs_base__io_buffer__reader(this);\n}\n\ninline wuffs_base__io_writer  //\nwuffs_base__io_buffer__struct::writer() {\n  return wuffs_base__io_buffer__writer(this);\n}\n\n#endif  // __cplusplus\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n" +
	""

const baseBasePrivateH = "" +
	"#ifndef WUFFS_INCLUDE_GUARD__BASE_PRIVATE\n#define WUFFS_INCLUDE_GUARD__BASE_PRIVATE\n\n// Copyright 2017 The Wuffs Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(x) (void)(x)\n\nstatic inline void wuffs_base__ignore_check_wuffs_version_status(\n    wuffs_base__status z) {}\n\n// WUFFS_BASE__MAGIC is a magic number to check that initializers are called.\n// It's not foolproof, given C doesn't automatically zero me" +
	"mory before use,\n// but it should catch 99.99% of cases.\n//\n// Its (non-zero) value is arbitrary, based on md5sum(\"wuffs\").\n#define WUFFS_BASE__MAGIC ((uint32_t)0x3CCB6C71)\n\n// WUFFS_BASE__DISABLED is a magic number to indicate that a non-recoverable\n// error was previously encountered.\n//\n// Its (non-zero) value is arbitrary, based on md5sum(\"disabled\").\n#define WUFFS_BASE__DISABLED ((uint32_t)0x075AE3D2)\n\n// Denote intentional fallthroughs for -Wimplicit-fallthrough.\n//\n// The order matters here. Clang also defines \"__GNUC__\".\n#if defined(__clang__) && __cplusplus >= 201103L\n#define WUFFS_BASE__FALLTHROUGH [[clang::fallthrough]]\n#elif !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 7)\n#define WUFFS_BASE__FALLTHROUGH __attribute__((fallthrough))\n#else\n#define WUFFS_BASE__FALLTHROUGH\n#endif\n\n// Use switch cases for coroutine suspension points, similar to the technique\n// in https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html\n//\n// We use trivial macros instead of an explicit assignment and c" +
	"ase statement\n// so that clang-format doesn't get confused by the unusual \"case\"s.\n#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0 case 0:;\n#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT(n) \\\n  coro_susp_point = n;                            \\\n  WUFFS_BASE__FALLTHROUGH;                        \\\n  case n:;\n\n#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(n) \\\n  if (!status) {                                                \\\n    goto ok;                                                    \\\n  } else if (*status != '$') {                                  \\\n    goto exit;                                                  \\\n  }                                                             \\\n  coro_susp_point = n;                                          \\\n  goto suspend;                                                 \\\n  case n:;\n\n// Clang also defines \"__GNUC__\".\n#if defined(__GNUC__)\n#define WUFFS_BASE__LIKELY(expr) (__builtin_expect(!!(expr), 1))\n#define WUFFS_BASE__UNLIKELY(expr) (__builtin_expect(!" +
	"!(expr), 0))\n#else\n#define WUFFS_BASE__LIKELY(expr) (expr)\n#define WUFFS_BASE__UNLIKELY(expr) (expr)\n#endif\n\n// The helpers below are functions, instead of macros, because their arguments\n// can be an expression that we shouldn't evaluate more than once.\n//\n// They are static, so that linking multiple wuffs .o files won't complain about\n// duplicate function definitions.\n//\n// They are explicitly marked inline, even if modern compilers don't use the\n// inline attribute to guide optimizations such as inlining, to avoid the\n// -Wunused-function warning, and we like to compile with -Wall -Werror.\n\nstatic inline wuffs_base__empty_struct  //\nwuffs_base__return_empty_struct() {\n  return ((wuffs_base__empty_struct){});\n}\n\n" +
	"" +
	"// ---------------- Numeric Types\n\nstatic inline uint8_t  //\nwuffs_base__load_u8be(uint8_t* p) {\n  return p[0];\n}\n\nstatic inline uint16_t  //\nwuffs_base__load_u16be(uint8_t* p) {\n  return ((uint16_t)(p[0]) << 8) | ((uint16_t)(p[1]) << 0);\n}\n\nstatic inline uint16_t  //\nwuffs_base__load_u16le(uint8_t* p) {\n  return ((uint16_t)(p[0]) << 0) | ((uint16_t)(p[1]) << 8);\n}\n\nstatic inline uint32_t  //\nwuffs_base__load_u24be(uint8_t* p) {\n  return ((uint32_t)(p[0]) << 16) | ((uint32_t)(p[1]) << 8) |\n         ((uint32_t)(p[2]) << 0);\n}\n\nstatic inline uint32_t  //\nwuffs_base__load_u24le(uint8_t* p) {\n  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |\n         ((uint32_t)(p[2]) << 16);\n}\n\nstatic inline uint32_t  //\nwuffs_base__load_u32be(uint8_t* p) {\n  return ((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |\n         ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0);\n}\n\nstatic inline uint32_t  //\nwuffs_base__load_u32le(uint8_t* p) {\n  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |\n         ((uin" +
	"t32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u40be(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 32) | ((uint64_t)(p[1]) << 24) |\n         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 8) |\n         ((uint64_t)(p[4]) << 0);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u40le(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |\n         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |\n         ((uint64_t)(p[4]) << 32);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u48be(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 40) | ((uint64_t)(p[1]) << 32) |\n         ((uint64_t)(p[2]) << 24) | ((uint64_t)(p[3]) << 16) |\n         ((uint64_t)(p[4]) << 8) | ((uint64_t)(p[5]) << 0);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u48le(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |\n         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |\n         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40);\n}\n\nstatic inline u" +
	"int64_t  //\nwuffs_base__load_u56be(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 48) | ((uint64_t)(p[1]) << 40) |\n         ((uint64_t)(p[2]) << 32) | ((uint64_t)(p[3]) << 24) |\n         ((uint64_t)(p[4]) << 16) | ((uint64_t)(p[5]) << 8) |\n         ((uint64_t)(p[6]) << 0);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u56le(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |\n         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |\n         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40) |\n         ((uint64_t)(p[6]) << 48);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u64be(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 56) | ((uint64_t)(p[1]) << 48) |\n         ((uint64_t)(p[2]) << 40) | ((uint64_t)(p[3]) << 32) |\n         ((uint64_t)(p[4]) << 24) | ((uint64_t)(p[5]) << 16) |\n         ((uint64_t)(p[6]) << 8) | ((uint64_t)(p[7]) << 0);\n}\n\nstatic inline uint64_t  //\nwuffs_base__load_u64le(uint8_t* p) {\n  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |\n         ((uint64_t)" +
	"(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |\n         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40) |\n         ((uint64_t)(p[6]) << 48) | ((uint64_t)(p[7]) << 56);\n}\n\n" +
	"" +
	"// --------\n\nstatic inline void  //\nwuffs_base__store_u8be(uint8_t* p, uint8_t x) {\n  p[0] = x;\n}\n\nstatic inline void  //\nwuffs_base__store_u16be(uint8_t* p, uint16_t x) {\n  p[0] = x >> 8;\n  p[1] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u16le(uint8_t* p, uint16_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n}\n\nstatic inline void  //\nwuffs_base__store_u24be(uint8_t* p, uint32_t x) {\n  p[0] = x >> 16;\n  p[1] = x >> 8;\n  p[2] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u24le(uint8_t* p, uint32_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n}\n\nstatic inline void  //\nwuffs_base__store_u32be(uint8_t* p, uint32_t x) {\n  p[0] = x >> 24;\n  p[1] = x >> 16;\n  p[2] = x >> 8;\n  p[3] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u32le(uint8_t* p, uint32_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n  p[3] = x >> 24;\n}\n\nstatic inline void  //\nwuffs_base__store_u40be(uint8_t* p, uint64_t x) {\n  p[0] = x >> 32;\n  p[1] = x >> 24;\n  p[2] = x >> 16;\n  p[3] = x >> 8;\n  p[4] = x >>" +
	" 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u40le(uint8_t* p, uint64_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n  p[3] = x >> 24;\n  p[4] = x >> 32;\n}\n\nstatic inline void  //\nwuffs_base__store_u48be(uint8_t* p, uint64_t x) {\n  p[0] = x >> 40;\n  p[1] = x >> 32;\n  p[2] = x >> 24;\n  p[3] = x >> 16;\n  p[4] = x >> 8;\n  p[5] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u48le(uint8_t* p, uint64_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n  p[3] = x >> 24;\n  p[4] = x >> 32;\n  p[5] = x >> 40;\n}\n\nstatic inline void  //\nwuffs_base__store_u56be(uint8_t* p, uint64_t x) {\n  p[0] = x >> 48;\n  p[1] = x >> 40;\n  p[2] = x >> 32;\n  p[3] = x >> 24;\n  p[4] = x >> 16;\n  p[5] = x >> 8;\n  p[6] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u56le(uint8_t* p, uint64_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n  p[3] = x >> 24;\n  p[4] = x >> 32;\n  p[5] = x >> 40;\n  p[6] = x >> 48;\n}\n\nstatic inline void  //\nwuffs_base__store_u64be(uint8_t* p, uint64_t x) {\n  p[0] = x >> 56" +
	";\n  p[1] = x >> 48;\n  p[2] = x >> 40;\n  p[3] = x >> 32;\n  p[4] = x >> 24;\n  p[5] = x >> 16;\n  p[6] = x >> 8;\n  p[7] = x >> 0;\n}\n\nstatic inline void  //\nwuffs_base__store_u64le(uint8_t* p, uint64_t x) {\n  p[0] = x >> 0;\n  p[1] = x >> 8;\n  p[2] = x >> 16;\n  p[3] = x >> 24;\n  p[4] = x >> 32;\n  p[5] = x >> 40;\n  p[6] = x >> 48;\n  p[7] = x >> 56;\n}\n\n" +
	"" +
	"// --------\n\nstatic inline void  //\nwuffs_base__u8__sat_add_indirect(uint8_t* x, uint8_t y) {\n  *x = wuffs_base__u8__sat_add(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u8__sat_sub_indirect(uint8_t* x, uint8_t y) {\n  *x = wuffs_base__u8__sat_sub(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u16__sat_add_indirect(uint16_t* x, uint16_t y) {\n  *x = wuffs_base__u16__sat_add(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u16__sat_sub_indirect(uint16_t* x, uint16_t y) {\n  *x = wuffs_base__u16__sat_sub(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u32__sat_add_indirect(uint32_t* x, uint32_t y) {\n  *x = wuffs_base__u32__sat_add(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u32__sat_sub_indirect(uint32_t* x, uint32_t y) {\n  *x = wuffs_base__u32__sat_sub(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u64__sat_add_indirect(uint64_t* x, uint64_t y) {\n  *x = wuffs_base__u64__sat_add(*x, y);\n}\n\nstatic inline void  //\nwuffs_base__u64__sat_sub_indirect(uint64_t* x, uint64_t y) {\n  *x = wuffs_base__u64__sat_sub(*x, y);\n}\n\n" +
	"" +
	"// ---------------- Slices and Tables\n\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__slice_u8__subslice_i(wuffs_base__slice_u8 s, uint64_t i) {\n  if ((i <= SIZE_MAX) && (i <= s.len)) {\n    return ((wuffs_base__slice_u8){\n        .ptr = s.ptr + i,\n        .len = s.len - i,\n    });\n  }\n  return ((wuffs_base__slice_u8){});\n}\n\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__slice_u8__subslice_j(wuffs_base__slice_u8 s, uint64_t j) {\n  if ((j <= SIZE_MAX) && (j <= s.len)) {\n    return ((wuffs_base__slice_u8){.ptr = s.ptr, .len = j});\n  }\n  return ((wuffs_base__slice_u8){});\n}\n\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__slice_u8__subslice_ij(wuffs_base__slice_u8 s,\n                                  uint64_t i,\n                                  uint64_t j) {\n  if ((i <= j) && (j <= SIZE_MAX) && (j <= s.len)) {\n    return ((wuffs_base__slice_u8){\n        .ptr = s.ptr + i,\n        .len = j - i,\n    });\n  }\n  return ((wuffs_base__slice_u8){});\n}\n\n// wuffs_base__slice_u8__prefix returns up to the first up" +
	"_to bytes of s.\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__slice_u8__prefix(wuffs_base__slice_u8 s, uint64_t up_to) {\n  if ((uint64_t)(s.len) > up_to) {\n    s.len = up_to;\n  }\n  return s;\n}\n\n// wuffs_base__slice_u8__suffix returns up to the last up_to bytes of s.\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__slice_u8__suffix(wuffs_base__slice_u8 s, uint64_t up_to) {\n  if ((uint64_t)(s.len) > up_to) {\n    s.ptr += (uint64_t)(s.len) - up_to;\n    s.len = up_to;\n  }\n  return s;\n}\n\n// wuffs_base__slice_u8__copy_from_slice calls memmove(dst.ptr, src.ptr,\n// length) where length is the minimum of dst.len and src.len.\n//\n// Passing a wuffs_base__slice_u8 with all fields NULL or zero (a valid, empty\n// slice) is valid and results in a no-op.\nstatic inline uint64_t  //\nwuffs_base__slice_u8__copy_from_slice(wuffs_base__slice_u8 dst,\n                                      wuffs_base__slice_u8 src) {\n  size_t length = dst.len < src.len ? dst.len : src.len;\n  if (length > 0) {\n    memmove(dst.ptr, src.ptr, leng" +
	"th);\n  }\n  return length;\n}\n\n" +
	"" +
	"// --------\n\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__table_u8__row(wuffs_base__table_u8 t, uint32_t y) {\n  if (y < t.height) {\n    return ((wuffs_base__slice_u8){\n        .ptr = t.ptr + (t.stride * y),\n        .len = t.width,\n    });\n  }\n  return ((wuffs_base__slice_u8){});\n}\n\n" +
	"" +
	"// ---------------- Utility\n\nstatic inline wuffs_base__range_ii_u32  //\nwuffs_base__utility__make_range_ii_u32(wuffs_base__utility* ignored,\n                                       uint32_t min_incl,\n                                       uint32_t max_incl) {\n  return ((wuffs_base__range_ii_u32){\n      .min_incl = min_incl,\n      .max_incl = max_incl,\n  });\n}\n\nstatic inline wuffs_base__range_ie_u32  //\nwuffs_base__utility__make_range_ie_u32(wuffs_base__utility* ignored,\n                                       uint32_t min_incl,\n                                       uint32_t max_excl) {\n  return ((wuffs_base__range_ie_u32){\n      .min_incl = min_incl,\n      .max_excl = max_excl,\n  });\n}\n\nstatic inline wuffs_base__range_ii_u64  //\nwuffs_base__utility__make_range_ii_u64(wuffs_base__utility* ignored,\n                                       uint64_t min_incl,\n                                       uint64_t max_incl) {\n  return ((wuffs_base__range_ii_u64){\n      .min_incl = min_incl,\n      .max_incl = max_incl,\n  });" +
	"\n}\n\nstatic inline wuffs_base__range_ie_u64  //\nwuffs_base__utility__make_range_ie_u64(wuffs_base__utility* ignored,\n                                       uint64_t min_incl,\n                                       uint64_t max_excl) {\n  return ((wuffs_base__range_ie_u64){\n      .min_incl = min_incl,\n      .max_excl = max_excl,\n  });\n}\n\nstatic inline wuffs_base__rect_ii_u32  //\nwuffs_base__utility__make_rect_ii_u32(wuffs_base__utility* ignored,\n                                      uint32_t min_incl_x,\n                                      uint32_t min_incl_y,\n                                      uint32_t max_incl_x,\n                                      uint32_t max_incl_y) {\n  return ((wuffs_base__rect_ii_u32){\n      .min_incl_x = min_incl_x,\n      .min_incl_y = min_incl_y,\n      .max_incl_x = max_incl_x,\n      .max_incl_y = max_incl_y,\n  });\n}\n\nstatic inline wuffs_base__rect_ie_u32  //\nwuffs_base__utility__make_rect_ie_u32(wuffs_base__utility* ignored,\n                                      uint32_t min_incl" +
	"_x,\n                                      uint32_t min_incl_y,\n                                      uint32_t max_excl_x,\n                                      uint32_t max_excl_y) {\n  return ((wuffs_base__rect_ie_u32){\n      .min_incl_x = min_incl_x,\n      .min_incl_y = min_incl_y,\n      .max_excl_x = max_excl_x,\n      .max_excl_y = max_excl_y,\n  });\n}\n\n" +
	"" +
	"// ---------------- I/O\n\nstatic inline bool  //\nwuffs_base__io_buffer__is_valid(wuffs_base__io_buffer buf) {\n  return (buf.ptr || (buf.len == 0)) && (buf.len >= buf.wi) &&\n         (buf.wi >= buf.ri);\n}\n\n// TODO: wuffs_base__io_reader__is_eof is no longer used by Wuffs per se, but\n// it might be handy to programs that use Wuffs. Either delete it, or promote\n// it to the public API.\n//\n// If making this function public (i.e. moving it to base-header.h), it also\n// needs to allow NULL (i.e. implicit, callee-calculated) mark/limit.\n\nstatic inline bool  //\nwuffs_base__io_reader__is_eof(wuffs_base__io_reader o) {\n  wuffs_base__io_buffer* buf = o.private_impl.buf;\n  return buf && buf->closed && (buf->ptr + buf->wi == o.private_impl.limit);\n}\n\nstatic inline bool  //\nwuffs_base__io_reader__is_valid(wuffs_base__io_reader o) {\n  wuffs_base__io_buffer* buf = o.private_impl.buf;\n  // Note: if making this function public (i.e. moving it to base-header.h), it\n  // also needs to allow NULL (i.e. implicit, callee-calculated)" +
	" mark/limit.\n  return buf ? ((buf->ptr <= o.private_impl.mark) &&\n                (o.private_impl.mark <= o.private_impl.limit) &&\n                (o.private_impl.limit <= buf->ptr + buf->len))\n             : ((o.private_impl.mark == NULL) &&\n                (o.private_impl.limit == NULL));\n}\n\nstatic inline bool  //\nwuffs_base__io_writer__is_valid(wuffs_base__io_writer o) {\n  wuffs_base__io_buffer* buf = o.private_impl.buf;\n  // Note: if making this function public (i.e. moving it to base-header.h), it\n  // also needs to allow NULL (i.e. implicit, callee-calculated) mark/limit.\n  return buf ? ((buf->ptr <= o.private_impl.mark) &&\n                (o.private_impl.mark <= o.private_impl.limit) &&\n                (o.private_impl.limit <= buf->ptr + buf->len))\n             : ((o.private_impl.mark == NULL) &&\n                (o.private_impl.limit == NULL));\n}\n\nstatic inline uint32_t  //\nwuffs_base__io_writer__copy_n_from_history(uint8_t** ptr_ptr,\n                                           uint8_t* start,\n         " +
	"                                  uint8_t* end,\n                                           uint32_t length,\n                                           uint32_t distance) {\n  if (!distance) {\n    return 0;\n  }\n  uint8_t* ptr = *ptr_ptr;\n  if ((size_t)(ptr - start) < (size_t)(distance)) {\n    return 0;\n  }\n  start = ptr - distance;\n  size_t n = end - ptr;\n  if ((size_t)(length) > n) {\n    length = n;\n  } else {\n    n = length;\n  }\n  // TODO: unrolling by 3 seems best for the std/deflate benchmarks, but that\n  // is mostly because 3 is the minimum length for the deflate format. This\n  // function implementation shouldn't overfit to that one format. Perhaps the\n  // copy_n_from_history Wuffs method should also take an unroll hint argument,\n  // and the cgen can look if that argument is the constant expression '3'.\n  //\n  // See also wuffs_base__io_writer__copy_n_from_history_fast below.\n  //\n  // Alternatively, or additionally, have a sloppy_copy_n_from_history method\n  // that copies 8 bytes at a time, possibly " +
	"writing more than length bytes?\n  for (; n >= 3; n -= 3) {\n    *ptr++ = *start++;\n    *ptr++ = *start++;\n    *ptr++ = *start++;\n  }\n  for (; n; n--) {\n    *ptr++ = *start++;\n  }\n  *ptr_ptr = ptr;\n  return length;\n}\n\n// wuffs_base__io_writer__copy_n_from_history_fast is like the\n// wuffs_base__io_writer__copy_n_from_history function above, but has stronger\n// pre-conditions. The caller needs to prove that:\n//  - distance >  0\n//  - distance <= (*ptr_ptr - start)\n//  - length   <= (end      - *ptr_ptr)\nstatic inline uint32_t  //\nwuffs_base__io_writer__copy_n_from_history_fast(uint8_t** ptr_ptr,\n                                                uint8_t* start,\n                                                uint8_t* end,\n                                                uint32_t length,\n                                                uint32_t distance) {\n  uint8_t* ptr = *ptr_ptr;\n  start = ptr - distance;\n  uint32_t n = length;\n  for (; n >= 3; n -= 3) {\n    *ptr++ = *start++;\n    *ptr++ = *start++;\n    *ptr++ = *s" +
	"tart++;\n  }\n  for (; n; n--) {\n    *ptr++ = *start++;\n  }\n  *ptr_ptr = ptr;\n  return length;\n}\n\nstatic inline uint32_t  //\nwuffs_base__io_writer__copy_n_from_reader(uint8_t** ptr_ioptr_w,\n                                          uint8_t* iobounds1_w,\n                                          uint32_t length,\n                                          uint8_t** ptr_ioptr_r,\n                                          uint8_t* iobounds1_r) {\n  uint8_t* ioptr_w = *ptr_ioptr_w;\n  size_t n = length;\n  if (n > ((size_t)(iobounds1_w - ioptr_w))) {\n    n = iobounds1_w - ioptr_w;\n  }\n  uint8_t* ioptr_r = *ptr_ioptr_r;\n  if (n > ((size_t)(iobounds1_r - ioptr_r))) {\n    n = iobounds1_r - ioptr_r;\n  }\n  if (n > 0) {\n    memmove(ioptr_w, ioptr_r, n);\n    *ptr_ioptr_w += n;\n    *ptr_ioptr_r += n;\n  }\n  return n;\n}\n\nstatic inline uint64_t  //\nwuffs_base__io_writer__copy_from_slice(uint8_t** ptr_ioptr_w,\n                                       uint8_t* iobounds1_w,\n                                       wuffs_base__slice_u8 src" +
	") {\n  uint8_t* ioptr_w = *ptr_ioptr_w;\n  size_t n = src.len;\n  if (n > ((size_t)(iobounds1_w - ioptr_w))) {\n    n = iobounds1_w - ioptr_w;\n  }\n  if (n > 0) {\n    memmove(ioptr_w, src.ptr, n);\n    *ptr_ioptr_w += n;\n  }\n  return n;\n}\n\nstatic inline uint32_t  //\nwuffs_base__io_writer__copy_n_from_slice(uint8_t** ptr_ioptr_w,\n                                         uint8_t* iobounds1_w,\n                                         uint32_t length,\n                                         wuffs_base__slice_u8 src) {\n  uint8_t* ioptr_w = *ptr_ioptr_w;\n  size_t n = src.len;\n  if (n > length) {\n    n = length;\n  }\n  if (n > ((size_t)(iobounds1_w - ioptr_w))) {\n    n = iobounds1_w - ioptr_w;\n  }\n  if (n > 0) {\n    memmove(ioptr_w, src.ptr, n);\n    *ptr_ioptr_w += n;\n  }\n  return n;\n}\n\nstatic inline wuffs_base__empty_struct  //\nwuffs_base__io_reader__set_limit(wuffs_base__io_reader* o,\n                                 uint8_t* ioptr_r,\n                                 uint64_t limit) {\n  if (o && (((size_t)(o->private_im" +
	"pl.limit - ioptr_r)) > limit)) {\n    o->private_impl.limit = ioptr_r + limit;\n  }\n  return ((wuffs_base__empty_struct){});\n}\n\nstatic inline wuffs_base__empty_struct  //\nwuffs_base__io_reader__set_mark(wuffs_base__io_reader* o, uint8_t* mark) {\n  o->private_impl.mark = mark;\n  return ((wuffs_base__empty_struct){});\n}\n\nstatic inline wuffs_base__empty_struct  //\nwuffs_base__io_writer__set(wuffs_base__io_writer* o,\n                           wuffs_base__io_buffer* b,\n                           uint8_t** ioptr1_ptr,\n                           uint8_t** ioptr2_ptr,\n                           wuffs_base__slice_u8 s) {\n  b->ptr = s.ptr;\n  b->len = s.len;\n  b->wi = 0;\n  b->ri = 0;\n  b->closed = false;\n  o->private_impl.buf = b;\n  o->private_impl.mark = s.ptr;\n  o->private_impl.limit = s.ptr + s.len;\n  *ioptr1_ptr = s.ptr;\n  *ioptr2_ptr = s.ptr + s.len;\n  return ((wuffs_base__empty_struct){});\n}\n\nstatic inline wuffs_base__empty_struct  //\nwuffs_base__io_writer__set_mark(wuffs_base__io_writer* o, uint8_t* mark) {\n  o->p" +
	"rivate_impl.mark = mark;\n  return ((wuffs_base__empty_struct){});\n}\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n\n#endif  // WUFFS_INCLUDE_GUARD__BASE_PRIVATE\n" +
	""

const baseBaseImplC = "" +
	"// Copyright 2018 The Wuffs Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// !! INSERT base-public.h.\n\n#ifdef WUFFS_IMPLEMENTATION\n\n// !! INSERT base-private.h.\n\n#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__BASE)\n\n// !! INSERT wuffs_base__status strings.\n\n#endif  // !defined(WUFFS_CONFIG__MODULES) ||\n        // defined(WUFFS_CONFIG__MODULE__BASE)\n\n#endif  // WUFFS_IMPLEMENTATION\n" +
	""

const baseImagePublicH = "" +
	"// Copyright 2017 The Wuffs Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n" +
	"" +
	"// ---------------- Images\n\n// wuffs_base__color_u32argb is an 8 bit per channel Alpha, Red, Green, Blue\n// color, as a uint32_t value. It is in word order, not byte order: its value\n// is always 0xAARRGGBB, regardless of endianness. It uses premultiplied alpha.\ntypedef uint32_t wuffs_base__color_u32argb;\n\n" +
	"" +
	"// --------\n\n// wuffs_base__pixel_format encodes the format of the bytes that constitute an\n// image frame's pixel data. Its bits:\n//  - bit        31  is reserved.\n//  - bits 30 .. 28 encodes color (and channel order, in terms of memory).\n//  - bits 27 .. 26 are reserved.\n//  - bits 25 .. 24 encodes transparency.\n//  - bits 23 .. 21 are reserved.\n//  - bit        20 indicates big-endian/MSB-first (as opposed to little/LSB).\n//  - bit        19 indicates floating point (as opposed to integer).\n//  - bit        18 indicates palette-indexed. The number-of-planes (the next\n//                  field) will be zero, as the format is considered packed,\n//                  but the 8-bit N-BGRA color data is stored in plane 3.\n//  - bits 17 .. 16 are the number of planes, minus 1. Zero means packed.\n//  - bits 15 .. 12 encodes the number of bits (depth) in the 3rd channel.\n//  - bits 11 ..  8 encodes the number of bits (depth) in the 2nd channel.\n//  - bits  7 ..  4 encodes the number of bits (depth) in the 1st channe" +
	"l.\n//  - bits  3 ..  0 encodes the number of bits (depth) in the 0th channel.\n//\n// The bit fields of a wuffs_base__pixel_format are not independent. For\n// example, the number of planes should not be greater than the number of\n// channels. Similarly, bits 15..4 are unused (and should be zero) if bits\n// 31..24 (color and transparency) together imply only 1 channel (gray, no\n// alpha) and floating point samples should mean a bit depth of 16, 32 or 64.\n//\n// Formats hold between 1 and 4 channels. For example: Y (1 channel: gray), YA\n// (2 channels: gray and alpha), BGR (3 channels: blue, green, red) or CMYK (4\n// channels: cyan, magenta, yellow, black).\n//\n// For direct formats with N > 1 channels, those channels can be laid out in\n// either 1 (packed) or N (planar) planes. For example, RGBA data is usually\n// packed, but YUV data is usually planar, due to chroma subsampling (for\n// details, see the wuffs_base__pixel_subsampling type).\n//\n// For indexed formats, the palette (always 256  4 bytes) holds 8 bits" +
	" per\n// channel non-alpha-premultiplied BGRA color data. There is only 1 plane (for\n// the index), as the format is considered packed. Plane 0 holds the per-pixel\n// indices. Plane 3 is re-purposed to hold the per-index colors.\n//\n// The color field is encoded in 3 bits:\n//  - 0 means                 A (Alpha).\n//  - 1 means   Y       or   YA (Gray, Alpha).\n//  - 2 means BGR, BGRX or BGRA (Blue, Green, Red, X-padding or Alpha).\n//  - 3 means RGB, RGBX or RGBA (Red, Green, Blue, X-padding or Alpha).\n//  - 4 means YUV       or YUVA (Luma, Chroma-blue, Chroma-red, Alpha).\n//  - 5 means CMY       or CMYK (Cyan, Magenta, Yellow, Black).\n//  - all other values are reserved.\n//\n// In Wuffs, channels are given in memory order (also known as byte order),\n// regardless of endianness, since the C type for the pixel data is an array of\n// bytes, not an array of uint32_t. For example, packed BGRA with 8 bits per\n// channel means that the bytes in memory are always Blue, Green, Red then\n// Alpha. On big-endian systems, tha" +
	"t is the uint32_t 0xBBGGRRAA. On\n// little-endian, 0xAARRGGBB.\n//\n// When the color field (3 bits) encodes multiple options, the transparency\n// field (2 bits) distinguishes them:\n//  - 0 means fully opaque, no extra channels\n//  - 1 means fully opaque, one extra channel (X or K, padding or black).\n//  - 2 means one extra alpha channel, other channels are non-premultiplied.\n//  - 3 means one extra alpha channel, other channels are     premultiplied.\n//\n// The zero wuffs_base__pixel_format value is an invalid pixel format, as it is\n// invalid to combine the zero color (alpha only) with the zero transparency.\n//\n// Bit depth is encoded in 4 bits:\n//  -  0 means the channel or index is unused.\n//  -  x means a bit depth of  x, for x in the range 1..8.\n//  -  9 means a bit depth of 10.\n//  - 10 means a bit depth of 12.\n//  - 11 means a bit depth of 16.\n//  - 12 means a bit depth of 24.\n//  - 13 means a bit depth of 32.\n//  - 14 means a bit depth of 48.\n//  - 15 means a bit depth of 64.\n//\n// For example, wuffs_ba" +
	"se__pixel_format 0x3210BBBB is a natural format for\n// decoding a PNG image - network byte order (also known as big-endian),\n// packed, non-premultiplied alpha - that happens to be 16-bit-depth truecolor\n// with alpha (RGBA). In memory order:\n//\n//  ptr+0  ptr+1  ptr+2  ptr+3  ptr+4  ptr+5  ptr+6  ptr+7\n//  Rhi    Rlo    Ghi    Glo    Bhi    Blo    Ahi    Alo\n//\n// For example, the value wuffs_base__pixel_format 0x20000565 means BGR with no\n// alpha or padding, 5/6/5 bits for blue/green/red, packed 2 bytes per pixel,\n// laid out LSB-first in memory order:\n//\n//  ptr+0...........  ptr+1...........\n//  MSB          LSB  MSB          LSB\n//  GGGBBBBB  RRRRRGGG\n//\n// On little-endian systems (but not big-endian), this Wuffs pixel format value\n// (0x20000565) corresponds to the Cairo library's CAIRO_FORMAT_RGB16_565, the\n// SDL2 (Simple DirectMedia Layer 2) library's SDL_PIXELFORMAT_RGB565 and the\n// Skia library's kRGB_565_SkColorType. Note BGR in Wuffs versus RGB i" +
	"n the\n// other libraries.\n//\n// Regardless of endianness, this Wuffs pixel format value (0x20000565)\n// corresponds to the V4L2 (Video For Linux 2) library's V4L2_PIX_FMT_RGB565\n// and the Wayland-DRM library's WL_DRM_FORMAT_RGB565.\n//\n// Different software libraries name their pixel formats (and especially their\n// channel order) either according to memory layout or as bits of a native\n// integer type like uint32_t. The two conventions differ because of a system's\n// endianness. As mentioned earlier, Wuffs pixel formats are always in memory\n// order. More detail of other software libraries' naming conventions is in the\n// Pixel Format Guide at https://afrantzis.github.io/pixel-format-guide/\n//\n// Do not manipulate these bits directly; they are private implementation\n// details. Use methods such as wuffs_base__pixel_format__num_planes instead.\ntypedef uint32_t wuffs_base__pixel_format;\n\n// Common 8-bit-depth pixel formats. This list is not exhaustive; not all valid\n// wuffs_base__pixel_format values are prese" +
	"nt.\n\n#define WUFFS_BASE__PIXEL_FORMAT__INVALID ((wuffs_base__pixel_format)0x00000000)\n\n#define WUFFS_BASE__PIXEL_FORMAT__A ((wuffs_base__pixel_format)0x02000008)\n\n#define WUFFS_BASE__PIXEL_FORMAT__Y ((wuffs_base__pixel_format)0x10000008)\n#define WUFFS_BASE__PIXEL_FORMAT__YA_NONPREMUL \\\n  ((wuffs_base__pixel_format)0x12000008)\n#define WUFFS_BASE__PIXEL_FORMAT__YA_PREMUL \\\n  ((wuffs_base__pixel_format)0x13000008)\n\n#define WUFFS_BASE__PIXEL_FORMAT__INDEXED__BGRA_NONPREMUL \\\n  ((wuffs_base__pixel_format)0x22040008)\n\n#define WUFFS_BASE__PIXEL_FORMAT__BGR ((wuffs_base__pixel_format)0x20000888)\n#define WUFFS_BASE__PIXEL_FORMAT__BGRX ((wuffs_base__pixel_format)0x21008888)\n#define WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL \\\n  ((wuffs_base__pixel_format)0x22008888)\n#define WUFFS_BASE__PIXEL_FORMAT__BGRA_PREMUL \\\n  ((wuffs_base__pixel_format)0x23008888)\n\n#define WUFFS_BASE__PIXEL_FORMAT__RGB ((wuffs_base__pixel_format)0x30000888)\n#define WUFFS_BASE__PIXEL_FORMAT__RGBX ((wuffs_base__pixel_format)0x31008888)\n#define WUFFS_" +
	"BASE__PIXEL_FORMAT__RGBA_NONPREMUL \\\n  ((wuffs_base__pixel_format)0x32008888)\n#define WUFFS_BASE__PIXEL_FORMAT__RGBA_PREMUL \\\n  ((wuffs_base__pixel_format)0x33008888)\n\n#define WUFFS_BASE__PIXEL_FORMAT__YUV ((wuffs_base__pixel_format)0x40020888)\n#define WUFFS_BASE__PIXEL_FORMAT__YUVK ((wuffs_base__pixel_format)0x41038888)\n#define WUFFS_BASE__PIXEL_FORMAT__YUVA_NONPREMUL \\\n  ((wuffs_base__pixel_format)0x42038888)\n\n#define WUFFS_BASE__PIXEL_FORMAT__CMY ((wuffs_base__pixel_format)0x50020888)\n#define WUFFS_BASE__PIXEL_FORMAT__CMYK ((wuffs_base__pixel_format)0x51038888)\n\nstatic inline bool  //\nwuffs_base__pixel_format__is_valid(wuffs_base__pixel_format f) {\n  return f != 0;\n}\n\nstatic inline bool  //\nwuffs_base__pixel_format__is_indexed(wuffs_base__pixel_format f) {\n  return (f >> 18) & 0x01;\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_format__num_planes(wuffs_base__pixel_format f) {\n  return f ? (((f >> 16) & 0x03) + 1) : 0;\n}\n\n#define WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX 4\n\n#define WUFFS_BASE__PIXEL_FORMAT" +
	"__INDEXED__INDEX_PLANE 0\n#define WUFFS_BASE__PIXEL_FORMAT__INDEXED__COLOR_PLANE 3\n\n" +
	"" +
	"// --------\n\n// wuffs_base__pixel_subsampling encodes the mapping of pixel space coordinates\n// (x, y) to pixel buffer indices (i, j). That mapping can differ for each\n// plane p. For a depth of 8 bits (1 byte), the p'th plane's sample starts at\n// (planes[p].ptr + (j * planes[p].stride) + i).\n//\n// For packed pixel formats, the mapping is trivial: i = x and j = y. For\n// planar pixel formats, the mapping can differ due to chroma subsampling. For\n// example, consider a three plane YUV pixel format with 4:2:2 subsampling. For\n// the luma (Y) channel, there is one sample for every pixel, but for the\n// chroma (U, V) channels, there is one sample for every two pixels: pairs of\n// horizontally adjacent pixels form one macropixel, i = x / 2 and j == y. In\n// general, for a given p:\n//  - i = (x + bias_x) >> shift_x.\n//  - j = (y + bias_y) >> shift_y.\n// where biases and shifts are in the range 0..3 and 0..2 respectively.\n//\n// In general, the biases will be zero after decoding an image. However, making\n// a sub-im" +
	"age may change the bias, since the (x, y) coordinates are relative\n// to the sub-image's top-left origin, but the backing pixel buffers were\n// created relative to the original image's origin.\n//\n// For each plane p, each of those four numbers (biases and shifts) are encoded\n// in two bits, which combine to form an 8 bit unsigned integer:\n//\n//  e_p = (bias_x << 6) | (shift_x << 4) | (bias_y << 2) | (shift_y << 0)\n//\n// Those e_p values (e_0 for the first plane, e_1 for the second plane, etc)\n// combine to form a wuffs_base__pixel_subsampling value:\n//\n//  pixsub = (e_3 << 24) | (e_2 << 16) | (e_1 << 8) | (e_0 << 0)\n//\n// Do not manipulate these bits directly; they are private implementation\n// details. Use methods such as wuffs_base__pixel_subsampling__bias_x instead.\ntypedef uint32_t wuffs_base__pixel_subsampling;\n\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__NONE ((wuffs_base__pixel_subsampling)0)\n\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__444 \\\n  ((wuffs_base__pixel_subsampling)0x000000)\n#define WUFFS_BASE__PIXEL_" +
	"SUBSAMPLING__440 \\\n  ((wuffs_base__pixel_subsampling)0x010100)\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__422 \\\n  ((wuffs_base__pixel_subsampling)0x101000)\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__420 \\\n  ((wuffs_base__pixel_subsampling)0x111100)\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__411 \\\n  ((wuffs_base__pixel_subsampling)0x202000)\n#define WUFFS_BASE__PIXEL_SUBSAMPLING__410 \\\n  ((wuffs_base__pixel_subsampling)0x212100)\n\nstatic inline uint32_t  //\nwuffs_base__pixel_subsampling__bias_x(wuffs_base__pixel_subsampling s,\n                                      uint32_t plane) {\n  uint32_t shift = ((plane & 0x03) * 8) + 6;\n  return (s >> shift) & 0x03;\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_subsampling__shift_x(wuffs_base__pixel_subsampling s,\n                                       uint32_t plane) {\n  uint32_t shift = ((plane & 0x03) * 8) + 4;\n  return (s >> shift) & 0x03;\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_subsampling__bias_y(wuffs_base__pixel_subsampling s,\n                                      ui" +
	"nt32_t plane) {\n  uint32_t shift = ((plane & 0x03) * 8) + 2;\n  return (s >> shift) & 0x03;\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_subsampling__shift_y(wuffs_base__pixel_subsampling s,\n                                       uint32_t plane) {\n  uint32_t shift = ((plane & 0x03) * 8) + 0;\n  return (s >> shift) & 0x03;\n}\n\n" +
	"" +
	"// --------\n\ntypedef struct {\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    wuffs_base__pixel_format pixfmt;\n    wuffs_base__pixel_subsampling pixsub;\n    uint32_t width;\n    uint32_t height;\n  } private_impl;\n\n#ifdef __cplusplus\n  inline void initialize(wuffs_base__pixel_format pixfmt,\n                         wuffs_base__pixel_subsampling pixsub,\n                         uint32_t width,\n                         uint32_t height);\n  inline void invalidate();\n  inline bool is_valid();\n  inline wuffs_base__pixel_format pixel_format();\n  inline wuffs_base__pixel_subsampling pixel_subsampling();\n  inline wuffs_base__rect_ie_u32 bounds();\n  inline uint32_t width();\n  inline uint32_t height();\n  inline size_t pixbuf_len();\n#endif  // __cplusplus\n\n} wuffs_base__pixel_config;\n\n// TODO: Should this function return bool? An error type?\nstatic inline void  //\nwuffs_base__pixel_config__initialize(wuffs_base__pixel_config* c,\n" +
	"                                     wuffs_base__pixel_format pixfmt,\n                                     wuffs_base__pixel_subsampling pixsub,\n                                     uint32_t width,\n                                     uint32_t height) {\n  if (!c) {\n    return;\n  }\n  if (pixfmt) {\n    uint64_t wh = ((uint64_t)width) * ((uint64_t)height);\n    // TODO: handle things other than 1 byte per pixel.\n    if (wh <= ((uint64_t)SIZE_MAX)) {\n      c->private_impl.pixfmt = pixfmt;\n      c->private_impl.pixsub = pixsub;\n      c->private_impl.width = width;\n      c->private_impl.height = height;\n      return;\n    }\n  }\n  *c = ((wuffs_base__pixel_config){});\n}\n\nstatic inline void  //\nwuffs_base__pixel_config__invalidate(wuffs_base__pixel_config* c) {\n  if (c) {\n    *c = ((wuffs_base__pixel_config){});\n  }\n}\n\nstatic inline bool  //\nwuffs_base__pixel_config__is_valid(wuffs_base__pixel_config* c) {\n  return c && c->private_impl.pixfmt;\n}\n\nstatic inline wuffs_base__pixel_format  //\nwuffs_base__pixel_config__pixel" +
	"_format(wuffs_base__pixel_config* c) {\n  return c ? c->private_impl.pixfmt : 0;\n}\n\nstatic inline wuffs_base__pixel_subsampling  //\nwuffs_base__pixel_config__pixel_subsampling(wuffs_base__pixel_config* c) {\n  return c ? c->private_impl.pixsub : 0;\n}\n\nstatic inline wuffs_base__rect_ie_u32  //\nwuffs_base__pixel_config__bounds(wuffs_base__pixel_config* c) {\n  return c ? ((wuffs_base__rect_ie_u32){\n                 .min_incl_x = 0,\n                 .min_incl_y = 0,\n                 .max_excl_x = c->private_impl.width,\n                 .max_excl_y = c->private_impl.height,\n             })\n           : ((wuffs_base__rect_ie_u32){});\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_config__width(wuffs_base__pixel_config* c) {\n  return c ? c->private_impl.width : 0;\n}\n\nstatic inline uint32_t  //\nwuffs_base__pixel_config__height(wuffs_base__pixel_config* c) {\n  return c ? c->private_impl.height : 0;\n}\n\n// TODO: this is the right API for planar (not packed) pixbufs? Should it allow\n// decoding into a color model differen" +
	"t from the format's intrinsic one? For\n// example, decoding a JPEG image straight to RGBA instead of to YCbCr?\nstatic inline size_t  //\nwuffs_base__pixel_config__pixbuf_len(wuffs_base__pixel_config* c) {\n  if (c) {\n    uint64_t wh =\n        ((uint64_t)c->private_impl.width) * ((uint64_t)c->private_impl.height);\n    // TODO: handle things other than 1 byte per pixel. When doing so, consider\n    // that the +1024 below could overflow.\n    if (wuffs_base__pixel_format__is_indexed(c->private_impl.pixfmt)) {\n      wh += 1024;\n    }\n    return (size_t)wh;\n  }\n  return 0;\n}\n\n#ifdef __cplusplus\n\ninline void  //\nwuffs_base__pixel_config::initialize(wuffs_base__pixel_format pixfmt,\n                                     wuffs_base__pixel_subsampling pixsub,\n                                     uint32_t width,\n                                     uint32_t height) {\n  wuffs_base__pixel_config__initialize(this, pixfmt, pixsub, width, height);\n}\n\ninline void  //\nwuffs_base__pixel_config::invalidate() {\n  wuffs_base__pixel_co" +
	"nfig__invalidate(this);\n}\n\ninline bool  //\nwuffs_base__pixel_config::is_valid() {\n  return wuffs_base__pixel_config__is_valid(this);\n}\n\ninline wuffs_base__pixel_format  //\nwuffs_base__pixel_config::pixel_format() {\n  return wuffs_base__pixel_config__pixel_format(this);\n}\n\ninline wuffs_base__pixel_subsampling  //\nwuffs_base__pixel_config::pixel_subsampling() {\n  return wuffs_base__pixel_config__pixel_subsampling(this);\n}\n\ninline wuffs_base__rect_ie_u32  //\nwuffs_base__pixel_config::bounds() {\n  return wuffs_base__pixel_config__bounds(this);\n}\n\ninline uint32_t  //\nwuffs_base__pixel_config::width() {\n  return wuffs_base__pixel_config__width(this);\n}\n\ninline uint32_t  //\nwuffs_base__pixel_config::height() {\n  return wuffs_base__pixel_config__height(this);\n}\n\ninline size_t  //\nwuffs_base__pixel_config::pixbuf_len() {\n  return wuffs_base__pixel_config__pixbuf_len(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct {\n  wuffs_base__pixel_config pixcfg;\n\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    wuffs_base__range_ii_u64 workbuf_len;\n    uint64_t first_frame_io_position;\n    uint32_t num_loops;\n    bool first_frame_is_opaque;\n  } private_impl;\n\n#ifdef __cplusplus\n  inline void initialize(wuffs_base__pixel_format pixfmt,\n                         wuffs_base__pixel_subsampling pixsub,\n                         uint32_t width,\n                         uint32_t height,\n                         uint64_t workbuf_len0,\n                         uint64_t workbuf_len1,\n                         uint32_t num_loops,\n                         uint64_t first_frame_io_position,\n                         bool first_frame_is_opaque);\n  inline void invalidate();\n  inline bool is_valid();\n  inline wuffs_base__range_ii_u64 workbuf_len();\n  inline uint32_t num_loops();\n  inline uint64_t first_frame_io_position();\n  inline" +
	" bool first_frame_is_opaque();\n#endif  // __cplusplus\n\n} wuffs_base__image_config;\n\n// TODO: Should this function return bool? An error type?\nstatic inline void  //\nwuffs_base__image_config__initialize(wuffs_base__image_config* c,\n                                     wuffs_base__pixel_format pixfmt,\n                                     wuffs_base__pixel_subsampling pixsub,\n                                     uint32_t width,\n                                     uint32_t height,\n                                     uint64_t workbuf_len0,\n                                     uint64_t workbuf_len1,\n                                     uint32_t num_loops,\n                                     uint64_t first_frame_io_position,\n                                     bool first_frame_is_opaque) {\n  if (!c) {\n    return;\n  }\n  if (wuffs_base__pixel_format__is_valid(pixfmt)) {\n    c->pixcfg.private_impl.pixfmt = pixfmt;\n    c->pixcfg.private_impl.pixsub = pixsub;\n    c->pixcfg.private_impl.width = width;\n    c->pixcfg.pr" +
	"ivate_impl.height = height;\n    c->private_impl.workbuf_len.min_incl = workbuf_len0;\n    c->private_impl.workbuf_len.max_incl = workbuf_len1;\n    c->private_impl.first_frame_io_position = first_frame_io_position;\n    c->private_impl.num_loops = num_loops;\n    c->private_impl.first_frame_is_opaque = first_frame_is_opaque;\n    return;\n  }\n  *c = ((wuffs_base__image_config){});\n}\n\nstatic inline void  //\nwuffs_base__image_config__invalidate(wuffs_base__image_config* c) {\n  if (c) {\n    *c = ((wuffs_base__image_config){});\n  }\n}\n\nstatic inline bool  //\nwuffs_base__image_config__is_valid(wuffs_base__image_config* c) {\n  return c && wuffs_base__pixel_config__is_valid(&(c->pixcfg));\n}\n\nstatic inline wuffs_base__range_ii_u64  //\nwuffs_base__image_config__workbuf_len(wuffs_base__image_config* c) {\n  return c ? c->private_impl.workbuf_len : ((wuffs_base__range_ii_u64){});\n}\n\nstatic inline uint32_t  //\nwuffs_base__image_config__num_loops(wuffs_base__image_config* c) {\n  return c ? c->private_impl.num_loops : 0;\n}\n\nstatic" +
	" inline uint64_t  //\nwuffs_base__image_config__first_frame_io_position(wuffs_base__image_config* c) {\n  return c ? c->private_impl.first_frame_io_position : 0;\n}\n\nstatic inline bool  //\nwuffs_base__image_config__first_frame_is_opaque(wuffs_base__image_config* c) {\n  return c ? c->private_impl.first_frame_is_opaque : false;\n}\n\n#ifdef __cplusplus\n\ninline void  //\nwuffs_base__image_config::initialize(wuffs_base__pixel_format pixfmt,\n                                     wuffs_base__pixel_subsampling pixsub,\n                                     uint32_t width,\n                                     uint32_t height,\n                                     uint64_t workbuf_len0,\n                                     uint64_t workbuf_len1,\n                                     uint32_t num_loops,\n                                     uint64_t first_frame_io_position,\n                                     bool first_frame_is_opaque) {\n  wuffs_base__image_config__initialize(\n      this, pixfmt, pixsub, width, height, workbuf_le" +
	"n0, workbuf_len1,\n      num_loops, first_frame_io_position, first_frame_is_opaque);\n}\n\ninline void  //\nwuffs_base__image_config::invalidate() {\n  wuffs_base__image_config__invalidate(this);\n}\n\ninline bool  //\nwuffs_base__image_config::is_valid() {\n  return wuffs_base__image_config__is_valid(this);\n}\n\ninline wuffs_base__range_ii_u64  //\nwuffs_base__image_config::workbuf_len() {\n  return wuffs_base__image_config__workbuf_len(this);\n}\n\ninline uint32_t  //\nwuffs_base__image_config::num_loops() {\n  return wuffs_base__image_config__num_loops(this);\n}\n\ninline uint64_t  //\nwuffs_base__image_config::first_frame_io_position() {\n  return wuffs_base__image_config__first_frame_io_position(this);\n}\n\ninline bool  //\nwuffs_base__image_config::first_frame_is_opaque() {\n  return wuffs_base__image_config__first_frame_is_opaque(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\n// wuffs_base__animation_blend encodes, for an animated image, how to blend the\n// transparent pixels of this frame with the existing canvas. In Porter-Duff\n// compositing operator terminology:\n//  - 0 means the frame may be transparent, and should be blended \"src over\n//    dst\", also known as just \"over\".\n//  - 1 means the frame may be transparent, and should be blended \"src\".\n//  - 2 means the frame is completely opaque, so that \"src over dst\" and \"src\"\n//    are equivalent.\n//\n// These semantics are conservative. It is valid for a completely opaque frame\n// to have a blend value other than 2.\ntypedef uint8_t wuffs_base__animation_blend;\n\n#define WUFFS_BASE__ANIMATION_BLEND__SRC_OVER_DST \\\n  ((wuffs_base__animation_blend)0)\n#define WUFFS_BASE__ANIMATION_BLEND__SRC ((wuffs_base__animation_blend)1)\n#define WUFFS_BASE__ANIMATION_BLEND__OPAQUE ((wuffs_base__animation_blend)2)\n\n" +
	"" +
	"// --------\n\n// wuffs_base__animation_disposal encodes, for an animated image, how to\n// dispose of a frame after displaying it:\n//  - None means to draw the next frame on top of this one.\n//  - Restore Background means to clear the frame's dirty rectangle to \"the\n//    background color\" (in practice, this means transparent black) before\n//    drawing the next frame.\n//  - Restore Previous means to undo the current frame, so that the next frame\n//    is drawn on top of the previous one.\ntypedef uint8_t wuffs_base__animation_disposal;\n\n#define WUFFS_BASE__ANIMATION_DISPOSAL__NONE ((wuffs_base__animation_disposal)0)\n#define WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_BACKGROUND \\\n  ((wuffs_base__animation_disposal)1)\n#define WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_PREVIOUS \\\n  ((wuffs_base__animation_disposal)2)\n\n" +
	"" +
	"// --------\n\ntypedef struct {\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    wuffs_base__rect_ie_u32 bounds;\n    wuffs_base__flicks duration;\n    uint64_t index;\n    uint64_t io_position;\n    wuffs_base__animation_blend blend;\n    wuffs_base__animation_disposal disposal;\n  } private_impl;\n\n#ifdef __cplusplus\n  inline void update(wuffs_base__rect_ie_u32 bounds,\n                     wuffs_base__flicks duration,\n                     uint64_t index,\n                     uint64_t io_position,\n                     wuffs_base__animation_blend blend,\n                     wuffs_base__animation_disposal disposal);\n  inline wuffs_base__rect_ie_u32 bounds();\n  inline uint32_t width();\n  inline uint32_t height();\n  inline wuffs_base__flicks duration();\n  inline uint64_t index();\n  inline uint64_t io_position();\n  inline wuffs_base__animation_blend blend();\n  inline wuffs_base__animation_disposal disposal();\n#endif  // __cpluspl" +
	"us\n\n} wuffs_base__frame_config;\n\nstatic inline void  //\nwuffs_base__frame_config__update(wuffs_base__frame_config* c,\n                                 wuffs_base__rect_ie_u32 bounds,\n                                 wuffs_base__flicks duration,\n                                 uint64_t index,\n                                 uint64_t io_position,\n                                 wuffs_base__animation_blend blend,\n                                 wuffs_base__animation_disposal disposal) {\n  if (!c) {\n    return;\n  }\n\n  c->private_impl.bounds = bounds;\n  c->private_impl.duration = duration;\n  c->private_impl.index = index;\n  c->private_impl.io_position = io_position;\n  c->private_impl.blend = blend;\n  c->private_impl.disposal = disposal;\n}\n\nstatic inline wuffs_base__rect_ie_u32  //\nwuffs_base__frame_config__bounds(wuffs_base__frame_config* c) {\n  return c ? c->private_impl.bounds : ((wuffs_base__rect_ie_u32){});\n}\n\nstatic inline uint32_t  //\nwuffs_base__frame_config__width(wuffs_base__frame_config* c) {\n  retur" +
	"n c ? wuffs_base__rect_ie_u32__width(&c->private_impl.bounds) : 0;\n}\n\nstatic inline uint32_t  //\nwuffs_base__frame_config__height(wuffs_base__frame_config* c) {\n  return c ? wuffs_base__rect_ie_u32__height(&c->private_impl.bounds) : 0;\n}\n\n// wuffs_base__frame_config__duration returns the amount of time to display\n// this frame. Zero means to display forever - a still (non-animated) image.\nstatic inline wuffs_base__flicks  //\nwuffs_base__frame_config__duration(wuffs_base__frame_config* c) {\n  return c ? c->private_impl.duration : 0;\n}\n\n// wuffs_base__frame_config__index returns the index of this frame. The first\n// frame in an image has index 0, the second frame has index 1, and so on.\nstatic inline uint64_t  //\nwuffs_base__frame_config__index(wuffs_base__frame_config* c) {\n  return c ? c->private_impl.index : 0;\n}\n\n// wuffs_base__frame_config__io_position returns the I/O stream position before\n// the frame config.\nstatic inline uint64_t  //\nwuffs_base__frame_config__io_position(wuffs_base__frame_config* c) {\n" +
	"  return c ? c->private_impl.io_position : 0;\n}\n\n// wuffs_base__frame_config__blend returns, for an animated image, how to blend\n// the transparent pixels of this frame with the existing canvas.\nstatic inline wuffs_base__animation_blend  //\nwuffs_base__frame_config__blend(wuffs_base__frame_config* c) {\n  return c ? c->private_impl.blend : 0;\n}\n\n// wuffs_base__frame_config__disposal returns, for an animated image, how to\n// dispose of this frame after displaying it.\nstatic inline wuffs_base__animation_disposal  //\nwuffs_base__frame_config__disposal(wuffs_base__frame_config* c) {\n  return c ? c->private_impl.disposal : 0;\n}\n\n#ifdef __cplusplus\n\ninline void  //\nwuffs_base__frame_config::update(wuffs_base__rect_ie_u32 bounds,\n                                 wuffs_base__flicks duration,\n                                 uint64_t index,\n                                 uint64_t io_position,\n                                 wuffs_base__animation_blend blend,\n                                 wuffs_base__animation_dis" +
	"posal disposal) {\n  wuffs_base__frame_config__update(this, bounds, duration, index, io_position,\n                                   blend, disposal);\n}\n\ninline wuffs_base__rect_ie_u32  //\nwuffs_base__frame_config::bounds() {\n  return wuffs_base__frame_config__bounds(this);\n}\n\ninline uint32_t  //\nwuffs_base__frame_config::width() {\n  return wuffs_base__frame_config__width(this);\n}\n\ninline uint32_t  //\nwuffs_base__frame_config::height() {\n  return wuffs_base__frame_config__height(this);\n}\n\ninline wuffs_base__flicks  //\nwuffs_base__frame_config::duration() {\n  return wuffs_base__frame_config__duration(this);\n}\n\ninline uint64_t  //\nwuffs_base__frame_config::index() {\n  return wuffs_base__frame_config__index(this);\n}\n\ninline uint64_t  //\nwuffs_base__frame_config::io_position() {\n  return wuffs_base__frame_config__io_position(this);\n}\n\ninline wuffs_base__animation_blend  //\nwuffs_base__frame_config::blend() {\n  return wuffs_base__frame_config__blend(this);\n}\n\ninline wuffs_base__animation_disposal  //\nwuffs_base__fr" +
	"ame_config::disposal() {\n  return wuffs_base__frame_config__disposal(this);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct {\n  wuffs_base__pixel_config pixcfg;\n\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    wuffs_base__table_u8 planes[WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX];\n    // TODO: color spaces.\n  } private_impl;\n\n#ifdef __cplusplus\n  inline wuffs_base__status set_from_slice(wuffs_base__pixel_config* pixcfg,\n                                           wuffs_base__slice_u8 pixbuf_memory);\n  inline wuffs_base__slice_u8 palette();\n  inline wuffs_base__table_u8 plane(uint32_t p);\n#endif  // __cplusplus\n\n} wuffs_base__pixel_buffer;\n\nstatic inline wuffs_base__status  //\nwuffs_base__pixel_buffer__set_from_slice(wuffs_base__pixel_buffer* b,\n                                         wuffs_base__pixel_config* pixcfg,\n                                         wuffs_base__slice_u8 pixbuf_memory) {\n  if (!b) {\n    return wuffs_base__error__bad_receiver;\n  }\n  *b = ((wuffs_base__pixel_buffer){});\n  if (!pixcfg) {\n  " +
	"  return wuffs_base__error__bad_argument;\n  }\n\n  uint8_t* ptr = pixbuf_memory.ptr;\n  size_t len = pixbuf_memory.len;\n  if (wuffs_base__pixel_format__is_indexed(pixcfg->private_impl.pixfmt)) {\n    // Split a 1024 byte chunk (256 palette entries  4 bytes per entry) from\n    // the start of pixbuf_memory. We split from the start, not the end, so\n    // that the both chunks' pointers have the same alignment as the original\n    // pointer, up to an alignment of 1024.\n    if (len < 1024) {\n      return wuffs_base__error__bad_argument_length_too_short;\n    }\n    wuffs_base__table_u8* tab =\n        &b->private_impl.planes[WUFFS_BASE__PIXEL_FORMAT__INDEXED__COLOR_PLANE];\n    tab->ptr = ptr;\n    tab->width = 1024;\n    tab->height = 1;\n    tab->stride = 1024;\n    ptr += 1024;\n    len -= 1024;\n  }\n\n  // TODO: don't assume 1 byte per pixel. Don't assume packed.\n  uint64_t wh = ((uint64_t)pixcfg->private_impl.width) *\n                ((uint64_t)pixcfg->private_impl.height);\n  if (wh > len) {\n    return wuffs_base__error_" +
	"_bad_argument_length_too_short;\n  }\n  b->pixcfg = *pixcfg;\n  wuffs_base__table_u8* tab = &b->private_impl.planes[0];\n  tab->ptr = ptr;\n  tab->width = pixcfg->private_impl.width;\n  tab->height = pixcfg->private_impl.height;\n  tab->stride = pixcfg->private_impl.width;\n  return NULL;\n}\n\n// wuffs_base__pixel_buffer__palette returns the palette color data. If\n// non-empty, it will have length 1024.\nstatic inline wuffs_base__slice_u8  //\nwuffs_base__pixel_buffer__palette(wuffs_base__pixel_buffer* b) {\n  if (b &&\n      wuffs_base__pixel_format__is_indexed(b->pixcfg.private_impl.pixfmt)) {\n    wuffs_base__table_u8* tab =\n        &b->private_impl.planes[WUFFS_BASE__PIXEL_FORMAT__INDEXED__COLOR_PLANE];\n    if ((tab->width == 1024) && (tab->height == 1)) {\n      return ((wuffs_base__slice_u8){\n          .ptr = tab->ptr,\n          .len = 1024,\n      });\n    }\n  }\n  return ((wuffs_base__slice_u8){});\n}\n\nstatic inline wuffs_base__table_u8  //\nwuffs_base__pixel_buffer__plane(wuffs_base__pixel_buffer* b, uint32_t p) {\n  retu" +
	"rn (b && (p < WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX))\n             ? b->private_impl.planes[p]\n             : ((wuffs_base__table_u8){});\n}\n\n#ifdef __cplusplus\n\ninline wuffs_base__status  //\nwuffs_base__pixel_buffer::set_from_slice(wuffs_base__pixel_config* pixcfg,\n                                         wuffs_base__slice_u8 pixbuf_memory) {\n  return wuffs_base__pixel_buffer__set_from_slice(this, pixcfg, pixbuf_memory);\n}\n\ninline wuffs_base__slice_u8  //\nwuffs_base__pixel_buffer::palette() {\n  return wuffs_base__pixel_buffer__palette(this);\n}\n\ninline wuffs_base__table_u8  //\nwuffs_base__pixel_buffer::plane(uint32_t p) {\n  return wuffs_base__pixel_buffer__plane(this, p);\n}\n\n#endif  // __cplusplus\n\n" +
	"" +
	"// --------\n\ntypedef struct {\n  // Do not access the private_impl's fields directly. There is no API/ABI\n  // compatibility or safety guarantee if you do so.\n  struct {\n    uint8_t TODO;\n  } private_impl;\n\n#ifdef __cplusplus\n#endif  // __cplusplus\n\n} wuffs_base__decode_frame_options;\n\n#ifdef __cplusplus\n\n#endif  // __cplusplus\n\n#ifdef __cplusplus\n}  // extern \"C\"\n#endif\n" +
	""
