#ifndef WUFFS_INCLUDE_GUARD
#define WUFFS_INCLUDE_GUARD

// Wuffs ships as a "single file C library" or "header file library" as per
// https://github.com/nothings/stb/blob/master/docs/stb_howto.txt
//
// To use that single file as a "foo.c"-like implementation, instead of a
// "foo.h"-like header, #define WUFFS_IMPLEMENTATION before #include'ing or
// compiling it.

// Copyright 2018 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by wuffs-c. DO NOT EDIT.

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

// Wuffs assumes that:
//  - converting a uint32_t to a size_t will never overflow.
//  - converting a size_t to a uint64_t will never overflow.
#ifdef __WORDSIZE
#if (__WORDSIZE != 32) && (__WORDSIZE != 64)
#error "Wuffs requires a word size of either 32 or 64 bits"
#endif
#endif

// WUFFS_VERSION is the major.minor.patch version, as per https://semver.org/,
// as a uint64_t. The major number is the high 32 bits. The minor number is the
// middle 16 bits. The patch number is the low 16 bits. The version extension
// (such as "", "beta" or "rc.1") is part of the string representation (such as
// "1.2.3-beta") but not the uint64_t representation.
//
// All three of major, minor and patch being zero means that this is a
// work-in-progress version, not a release version, and has no backwards or
// forwards compatibility guarantees.
//
// WUFFS_VERSION was overridden by "wuffs gen -version" on 2018-07-21 UTC,
// based on revision 9514b12c7f0a36a4bbab178d0d5fcb1b87a34011.
#define WUFFS_VERSION ((uint64_t)0x0000000000020000)
#define WUFFS_VERSION_MAJOR ((uint64_t)0x00000000)
#define WUFFS_VERSION_MINOR ((uint64_t)0x0002)
#define WUFFS_VERSION_PATCH ((uint64_t)0x0000)
#define WUFFS_VERSION_EXTENSION "alpha.8"
#define WUFFS_VERSION_STRING "0.2.0-alpha.8"

// Define WUFFS_CONFIG__STATIC_FUNCTIONS to make all of Wuffs' functions have
// static storage. The motivation is discussed in the "ALLOW STATIC
// IMPLEMENTATION" section of
// https://raw.githubusercontent.com/nothings/stb/master/docs/stb_howto.txt
#ifdef WUFFS_CONFIG__STATIC_FUNCTIONS
#define WUFFS_BASE__MAYBE_STATIC static
#else
#define WUFFS_BASE__MAYBE_STATIC
#endif

// wuffs_base__empty_struct is used when a Wuffs function returns an empty
// struct. In C, if a function f returns void, you can't say "x = f()", but in
// Wuffs, if a function g returns empty, you can say "y = g()".
typedef struct {
  // private_impl is a placeholder field. It isn't explicitly used, except that
  // without it, the sizeof a struct with no fields can differ across C/C++
  // compilers, and it is undefined behavior in C99. For example, gcc says that
  // the sizeof an empty struct is 0, and g++ says that it is 1. This leads to
  // ABI incompatibility if a Wuffs .c file is processed by one compiler and
  // its .h file with another compiler.
  //
  // Instead, we explicitly insert an otherwise unused field, so that the
  // sizeof this struct is always 1.
  uint8_t private_impl;
} wuffs_base__empty_struct;

// wuffs_base__utility is a placeholder receiver type. It enables what Java
// calls static methods, as opposed to regular methods.
typedef struct {
  // private_impl is a placeholder field. It isn't explicitly used, except that
  // without it, the sizeof a struct with no fields can differ across C/C++
  // compilers, and it is undefined behavior in C99. For example, gcc says that
  // the sizeof an empty struct is 0, and g++ says that it is 1. This leads to
  // ABI incompatibility if a Wuffs .c file is processed by one compiler and
  // its .h file with another compiler.
  //
  // Instead, we explicitly insert an otherwise unused field, so that the
  // sizeof this struct is always 1.
  uint8_t private_impl;
} wuffs_base__utility;

// --------

// A status code is either zero (OK), positive (a recoverable suspension or
// pause in processing) or negative (a non-recoverable error). Its bits:
//  - bit        31 (the sign bit) indicates unrecoverable-ness: an error.
//  - bits 30 .. 24 are a package-namespaced numeric code
//  - bits 23 .. 21 are reserved.
//  - bits 20 ..  0 are the packageid (a namespace) as a base38 value.
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_base__status__is_error instead.
typedef int32_t wuffs_base__status;

#define WUFFS_BASE__STATUS_OK 0                                    // 0x00000000
#define WUFFS_BASE__ERROR_BAD_WUFFS_VERSION -16777216              // 0xFF000000
#define WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER -33554432            // 0xFE000000
#define WUFFS_BASE__ERROR_BAD_RECEIVER -50331648                   // 0xFD000000
#define WUFFS_BASE__ERROR_BAD_ARGUMENT -67108864                   // 0xFC000000
#define WUFFS_BASE__ERROR_BAD_ARGUMENT_LENGTH_TOO_SHORT -67108864  // 0xFC000000
#define WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED \
  -268435456  // 0xF0000000
#define WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE \
  -285212672                                                     // 0xEF000000
#define WUFFS_BASE__ERROR_INVALID_CALL_SEQUENCE -301989888       // 0xEE000000
#define WUFFS_BASE__ERROR_CANNOT_RETURN_A_SUSPENSION -536870912  // 0xE0000000
#define WUFFS_BASE__ERROR_UNEXPECTED_EOF -805306368              // 0xD0000000
#define WUFFS_BASE__ERROR_CLOSED_FOR_WRITES -822083584           // 0xCF000000
#define WUFFS_BASE__SUSPENSION_END_OF_DATA 16777216              // 0x01000000
#define WUFFS_BASE__SUSPENSION_SHORT_READ 33554432               // 0x02000000
#define WUFFS_BASE__SUSPENSION_SHORT_WRITE 50331648              // 0x03000000

static inline bool  //
wuffs_base__status__is_error(wuffs_base__status s) {
  return s < 0;
}

static inline bool  //
wuffs_base__status__is_ok(wuffs_base__status s) {
  return s == 0;
}

static inline bool  //
wuffs_base__status__is_suspension(wuffs_base__status s) {
  return s > 0;
}

const char*  //
wuffs_base__status__string(wuffs_base__status s);

// --------

// Flicks are a unit of time. One flick (frame-tick) is 1 / 705_600_000 of a
// second. See https://github.com/OculusVR/Flicks
typedef int64_t wuffs_base__flicks;

#define WUFFS_BASE__FLICKS_PER_SECOND ((uint64_t)705600000)
#define WUFFS_BASE__FLICKS_PER_MILLISECOND ((uint64_t)705600)

// ---------------- Numeric Types

static inline uint8_t  //
wuffs_base__u8__min(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint8_t  //
wuffs_base__u8__max(uint8_t x, uint8_t y) {
  return x > y ? x : y;
}

static inline uint16_t  //
wuffs_base__u16__min(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint16_t  //
wuffs_base__u16__max(uint16_t x, uint16_t y) {
  return x > y ? x : y;
}

static inline uint32_t  //
wuffs_base__u32__min(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint32_t  //
wuffs_base__u32__max(uint32_t x, uint32_t y) {
  return x > y ? x : y;
}

static inline uint64_t  //
wuffs_base__u64__min(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline uint64_t  //
wuffs_base__u64__max(uint64_t x, uint64_t y) {
  return x > y ? x : y;
}

// --------

// Saturating arithmetic (sat_add, sat_sub) branchless bit-twiddling algorithms
// are per https://locklessinc.com/articles/sat_arithmetic/
//
// It is important that the underlying types are unsigned integers, as signed
// integer arithmetic overflow is undefined behavior in C.

static inline uint8_t  //
wuffs_base__u8__sat_add(uint8_t x, uint8_t y) {
  uint8_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint8_t  //
wuffs_base__u8__sat_sub(uint8_t x, uint8_t y) {
  uint8_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint16_t  //
wuffs_base__u16__sat_add(uint16_t x, uint16_t y) {
  uint16_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint16_t  //
wuffs_base__u16__sat_sub(uint16_t x, uint16_t y) {
  uint16_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint32_t  //
wuffs_base__u32__sat_add(uint32_t x, uint32_t y) {
  uint32_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint32_t  //
wuffs_base__u32__sat_sub(uint32_t x, uint32_t y) {
  uint32_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint64_t  //
wuffs_base__u64__sat_add(uint64_t x, uint64_t y) {
  uint64_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint64_t  //
wuffs_base__u64__sat_sub(uint64_t x, uint64_t y) {
  uint64_t res = x - y;
  res &= -(res <= x);
  return res;
}

// --------

// Clang also defines "__GNUC__".

static inline uint16_t  //
wuffs_base__u16__byte_swapped(uint16_t x) {
#if defined(__GNUC__)
  return __builtin_bswap16(x);
#else
  return (x >> 8) | (x << 8);
#endif
}

static inline uint32_t  //
wuffs_base__u32__byte_swapped(uint32_t x) {
#if defined(__GNUC__)
  return __builtin_bswap32(x);
#else
  static const uint32_t mask8 = 0x00FF00FF;
  x = ((x >> 8) & mask8) | ((x & mask8) << 8);
  return (x >> 16) | (x << 16);
#endif
}

static inline uint64_t  //
wuffs_base__u64__byte_swapped(uint64_t x) {
#if defined(__GNUC__)
  return __builtin_bswap64(x);
#else
  static const uint64_t mask8 = 0x00FF00FF00FF00FF;
  static const uint64_t mask16 = 0x0000FFFF0000FFFF;
  x = ((x >> 8) & mask8) | ((x & mask8) << 8);
  x = ((x >> 16) & mask16) | ((x & mask16) << 16);
  return (x >> 32) | (x << 32);
#endif
}

// ---------------- Slices and Tables

// WUFFS_BASE__SLICE is a 1-dimensional buffer.
//
// A value with all fields NULL or zero is a valid, empty slice.
#define WUFFS_BASE__SLICE(T) \
  struct {                   \
    T* ptr;                  \
    size_t len;              \
  }

// WUFFS_BASE__TABLE is a 2-dimensional buffer.
//
// A value with all fields NULL or zero is a valid, empty table.
#define WUFFS_BASE__TABLE(T) \
  struct {                   \
    T* ptr;                  \
    size_t width;            \
    size_t height;           \
    size_t stride;           \
  }

typedef WUFFS_BASE__SLICE(uint8_t) wuffs_base__slice_u8;
typedef WUFFS_BASE__SLICE(uint16_t) wuffs_base__slice_u16;
typedef WUFFS_BASE__SLICE(uint32_t) wuffs_base__slice_u32;
typedef WUFFS_BASE__SLICE(uint64_t) wuffs_base__slice_u64;

typedef WUFFS_BASE__TABLE(uint8_t) wuffs_base__table_u8;
typedef WUFFS_BASE__TABLE(uint16_t) wuffs_base__table_u16;
typedef WUFFS_BASE__TABLE(uint32_t) wuffs_base__table_u32;
typedef WUFFS_BASE__TABLE(uint64_t) wuffs_base__table_u64;

// ---------------- Ranges and Rects

// Ranges are either inclusive ("range_ii") or exclusive ("range_ie") on the
// high end. Both the "ii" and "ie" flavors are useful in practice.
//
// The "ei" and "ee" flavors also exist in theory, but aren't widely used. In
// Wuffs, the low end is always inclusive.
//
// The "ii" (closed interval) flavor is useful when refining e.g. "the set of
// all uint32_t values" to a contiguous subset: "uint32_t values in the closed
// interval [M, N]", for uint32_t values M and N. An unrefined type (in other
// words, the set of all uint32_t values) is not representable in the "ie"
// flavor because if N equals ((1<<32) - 1) then (N + 1) will overflow.
//
// On the other hand, the "ie" (half-open interval) flavor is recommended by
// Dijkstra's "Why numbering should start at zero" at
// http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF and a further
// discussion of motivating rationale is at
// https://www.quora.com/Why-are-Python-ranges-half-open-exclusive-instead-of-closed-inclusive
//
// For example, with "ie", the number of elements in "uint32_t values in the
// half-open interval [M, N)" is equal to max(0, N-M). Furthermore, that number
// of elements (in one dimension, a length, in two dimensions, a width or
// height) is itself representable as a uint32_t without overflow, again for
// uint32_t values M and N. In the contrasting "ii" flavor, the length of the
// closed interval [0, (1<<32) - 1] is 1<<32, which cannot be represented as a
// uint32_t. In Wuffs, because of this potential overflow, the "ie" flavor has
// length / width / height methods, but the "ii" flavor does not.
//
// It is valid for min > max (for range_ii) or for min >= max (for range_ie),
// in which case the range is empty. There are multiple representations of an
// empty range.

typedef struct wuffs_base__range_ii_u32__struct {
  uint32_t min_incl;
  uint32_t max_incl;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__range_ii_u32__struct s);
  inline bool contains(uint32_t x);
  inline wuffs_base__range_ii_u32__struct intersect(
      wuffs_base__range_ii_u32__struct s);
  inline wuffs_base__range_ii_u32__struct unite(
      wuffs_base__range_ii_u32__struct s);
#endif  // __cplusplus

} wuffs_base__range_ii_u32;

static inline bool  //
wuffs_base__range_ii_u32__is_empty(wuffs_base__range_ii_u32* r) {
  return r->min_incl > r->max_incl;
}

static inline bool  //
wuffs_base__range_ii_u32__equals(wuffs_base__range_ii_u32* r,
                                 wuffs_base__range_ii_u32 s) {
  return (r->min_incl == s.min_incl && r->max_incl == s.max_incl) ||
         (wuffs_base__range_ii_u32__is_empty(r) &&
          wuffs_base__range_ii_u32__is_empty(&s));
}

static inline bool  //
wuffs_base__range_ii_u32__contains(wuffs_base__range_ii_u32* r, uint32_t x) {
  return (r->min_incl <= x) && (x <= r->max_incl);
}

static inline  //
    wuffs_base__range_ii_u32
    wuffs_base__range_ii_u32__intersect(wuffs_base__range_ii_u32* r,
                                        wuffs_base__range_ii_u32 s) {
  wuffs_base__range_ii_u32 t;
  t.min_incl = wuffs_base__u32__max(r->min_incl, s.min_incl);
  t.max_incl = wuffs_base__u32__min(r->max_incl, s.max_incl);
  return t;
}

static inline  //
    wuffs_base__range_ii_u32
    wuffs_base__range_ii_u32__unite(wuffs_base__range_ii_u32* r,
                                    wuffs_base__range_ii_u32 s) {
  if (wuffs_base__range_ii_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ii_u32__is_empty(&s)) {
    return *r;
  }
  wuffs_base__range_ii_u32 t;
  t.min_incl = wuffs_base__u32__min(r->min_incl, s.min_incl);
  t.max_incl = wuffs_base__u32__max(r->max_incl, s.max_incl);
  return t;
}

#ifdef __cplusplus

inline bool  //
wuffs_base__range_ii_u32::is_empty() {
  return wuffs_base__range_ii_u32__is_empty(this);
}

inline bool  //
wuffs_base__range_ii_u32::equals(wuffs_base__range_ii_u32 s) {
  return wuffs_base__range_ii_u32__equals(this, s);
}

inline bool  //
wuffs_base__range_ii_u32::contains(uint32_t x) {
  return wuffs_base__range_ii_u32__contains(this, x);
}

inline wuffs_base__range_ii_u32  //
wuffs_base__range_ii_u32::intersect(wuffs_base__range_ii_u32 s) {
  return wuffs_base__range_ii_u32__intersect(this, s);
}

inline wuffs_base__range_ii_u32  //
wuffs_base__range_ii_u32::unite(wuffs_base__range_ii_u32 s) {
  return wuffs_base__range_ii_u32__unite(this, s);
}

#endif  // __cplusplus

// --------

typedef struct wuffs_base__range_ie_u32__struct {
  uint32_t min_incl;
  uint32_t max_excl;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__range_ie_u32__struct s);
  inline bool contains(uint32_t x);
  inline wuffs_base__range_ie_u32__struct intersect(
      wuffs_base__range_ie_u32__struct s);
  inline wuffs_base__range_ie_u32__struct unite(
      wuffs_base__range_ie_u32__struct s);
  inline uint32_t length();
#endif  // __cplusplus

} wuffs_base__range_ie_u32;

static inline bool  //
wuffs_base__range_ie_u32__is_empty(wuffs_base__range_ie_u32* r) {
  return r->min_incl >= r->max_excl;
}

static inline bool  //
wuffs_base__range_ie_u32__equals(wuffs_base__range_ie_u32* r,
                                 wuffs_base__range_ie_u32 s) {
  return (r->min_incl == s.min_incl && r->max_excl == s.max_excl) ||
         (wuffs_base__range_ie_u32__is_empty(r) &&
          wuffs_base__range_ie_u32__is_empty(&s));
}

static inline bool  //
wuffs_base__range_ie_u32__contains(wuffs_base__range_ie_u32* r, uint32_t x) {
  return (r->min_incl <= x) && (x < r->max_excl);
}

static inline wuffs_base__range_ie_u32  //
wuffs_base__range_ie_u32__intersect(wuffs_base__range_ie_u32* r,
                                    wuffs_base__range_ie_u32 s) {
  wuffs_base__range_ie_u32 t;
  t.min_incl = wuffs_base__u32__max(r->min_incl, s.min_incl);
  t.max_excl = wuffs_base__u32__min(r->max_excl, s.max_excl);
  return t;
}

static inline wuffs_base__range_ie_u32  //
wuffs_base__range_ie_u32__unite(wuffs_base__range_ie_u32* r,
                                wuffs_base__range_ie_u32 s) {
  if (wuffs_base__range_ie_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ie_u32__is_empty(&s)) {
    return *r;
  }
  wuffs_base__range_ie_u32 t;
  t.min_incl = wuffs_base__u32__min(r->min_incl, s.min_incl);
  t.max_excl = wuffs_base__u32__max(r->max_excl, s.max_excl);
  return t;
}

static inline uint32_t  //
wuffs_base__range_ie_u32__length(wuffs_base__range_ie_u32* r) {
  return wuffs_base__u32__sat_sub(r->max_excl, r->min_incl);
}

#ifdef __cplusplus

inline bool  //
wuffs_base__range_ie_u32::is_empty() {
  return wuffs_base__range_ie_u32__is_empty(this);
}

inline bool  //
wuffs_base__range_ie_u32::equals(wuffs_base__range_ie_u32 s) {
  return wuffs_base__range_ie_u32__equals(this, s);
}

inline bool  //
wuffs_base__range_ie_u32::contains(uint32_t x) {
  return wuffs_base__range_ie_u32__contains(this, x);
}

inline wuffs_base__range_ie_u32  //
wuffs_base__range_ie_u32::intersect(wuffs_base__range_ie_u32 s) {
  return wuffs_base__range_ie_u32__intersect(this, s);
}

inline wuffs_base__range_ie_u32  //
wuffs_base__range_ie_u32::unite(wuffs_base__range_ie_u32 s) {
  return wuffs_base__range_ie_u32__unite(this, s);
}

inline uint32_t  //
wuffs_base__range_ie_u32::length() {
  return wuffs_base__range_ie_u32__length(this);
}

#endif  // __cplusplus

// --------

typedef struct wuffs_base__range_ii_u64__struct {
  uint64_t min_incl;
  uint64_t max_incl;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__range_ii_u64__struct s);
  inline bool contains(uint64_t x);
  inline wuffs_base__range_ii_u64__struct intersect(
      wuffs_base__range_ii_u64__struct s);
  inline wuffs_base__range_ii_u64__struct unite(
      wuffs_base__range_ii_u64__struct s);
#endif  // __cplusplus

} wuffs_base__range_ii_u64;

static inline bool  //
wuffs_base__range_ii_u64__is_empty(wuffs_base__range_ii_u64* r) {
  return r->min_incl > r->max_incl;
}

static inline bool  //
wuffs_base__range_ii_u64__equals(wuffs_base__range_ii_u64* r,
                                 wuffs_base__range_ii_u64 s) {
  return (r->min_incl == s.min_incl && r->max_incl == s.max_incl) ||
         (wuffs_base__range_ii_u64__is_empty(r) &&
          wuffs_base__range_ii_u64__is_empty(&s));
}

static inline bool  //
wuffs_base__range_ii_u64__contains(wuffs_base__range_ii_u64* r, uint64_t x) {
  return (r->min_incl <= x) && (x <= r->max_incl);
}

static inline wuffs_base__range_ii_u64  //
wuffs_base__range_ii_u64__intersect(wuffs_base__range_ii_u64* r,
                                    wuffs_base__range_ii_u64 s) {
  wuffs_base__range_ii_u64 t;
  t.min_incl = wuffs_base__u64__max(r->min_incl, s.min_incl);
  t.max_incl = wuffs_base__u64__min(r->max_incl, s.max_incl);
  return t;
}

static inline wuffs_base__range_ii_u64  //
wuffs_base__range_ii_u64__unite(wuffs_base__range_ii_u64* r,
                                wuffs_base__range_ii_u64 s) {
  if (wuffs_base__range_ii_u64__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ii_u64__is_empty(&s)) {
    return *r;
  }
  wuffs_base__range_ii_u64 t;
  t.min_incl = wuffs_base__u64__min(r->min_incl, s.min_incl);
  t.max_incl = wuffs_base__u64__max(r->max_incl, s.max_incl);
  return t;
}

#ifdef __cplusplus

inline bool  //
wuffs_base__range_ii_u64::is_empty() {
  return wuffs_base__range_ii_u64__is_empty(this);
}

inline bool  //
wuffs_base__range_ii_u64::equals(wuffs_base__range_ii_u64 s) {
  return wuffs_base__range_ii_u64__equals(this, s);
}

inline bool  //
wuffs_base__range_ii_u64::contains(uint64_t x) {
  return wuffs_base__range_ii_u64__contains(this, x);
}

inline wuffs_base__range_ii_u64  //
wuffs_base__range_ii_u64::intersect(wuffs_base__range_ii_u64 s) {
  return wuffs_base__range_ii_u64__intersect(this, s);
}

inline wuffs_base__range_ii_u64  //
wuffs_base__range_ii_u64::unite(wuffs_base__range_ii_u64 s) {
  return wuffs_base__range_ii_u64__unite(this, s);
}

#endif  // __cplusplus

// --------

typedef struct wuffs_base__range_ie_u64__struct {
  uint64_t min_incl;
  uint64_t max_excl;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__range_ie_u64__struct s);
  inline bool contains(uint64_t x);
  inline wuffs_base__range_ie_u64__struct intersect(
      wuffs_base__range_ie_u64__struct s);
  inline wuffs_base__range_ie_u64__struct unite(
      wuffs_base__range_ie_u64__struct s);
  inline uint64_t length();
#endif  // __cplusplus

} wuffs_base__range_ie_u64;

static inline bool  //
wuffs_base__range_ie_u64__is_empty(wuffs_base__range_ie_u64* r) {
  return r->min_incl >= r->max_excl;
}

static inline bool  //
wuffs_base__range_ie_u64__equals(wuffs_base__range_ie_u64* r,
                                 wuffs_base__range_ie_u64 s) {
  return (r->min_incl == s.min_incl && r->max_excl == s.max_excl) ||
         (wuffs_base__range_ie_u64__is_empty(r) &&
          wuffs_base__range_ie_u64__is_empty(&s));
}

static inline bool  //
wuffs_base__range_ie_u64__contains(wuffs_base__range_ie_u64* r, uint64_t x) {
  return (r->min_incl <= x) && (x < r->max_excl);
}

static inline wuffs_base__range_ie_u64  //
wuffs_base__range_ie_u64__intersect(wuffs_base__range_ie_u64* r,
                                    wuffs_base__range_ie_u64 s) {
  wuffs_base__range_ie_u64 t;
  t.min_incl = wuffs_base__u64__max(r->min_incl, s.min_incl);
  t.max_excl = wuffs_base__u64__min(r->max_excl, s.max_excl);
  return t;
}

static inline wuffs_base__range_ie_u64  //
wuffs_base__range_ie_u64__unite(wuffs_base__range_ie_u64* r,
                                wuffs_base__range_ie_u64 s) {
  if (wuffs_base__range_ie_u64__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ie_u64__is_empty(&s)) {
    return *r;
  }
  wuffs_base__range_ie_u64 t;
  t.min_incl = wuffs_base__u64__min(r->min_incl, s.min_incl);
  t.max_excl = wuffs_base__u64__max(r->max_excl, s.max_excl);
  return t;
}

static inline uint64_t  //
wuffs_base__range_ie_u64__length(wuffs_base__range_ie_u64* r) {
  return wuffs_base__u64__sat_sub(r->max_excl, r->min_incl);
}

#ifdef __cplusplus

inline bool  //
wuffs_base__range_ie_u64::is_empty() {
  return wuffs_base__range_ie_u64__is_empty(this);
}

inline bool  //
wuffs_base__range_ie_u64::equals(wuffs_base__range_ie_u64 s) {
  return wuffs_base__range_ie_u64__equals(this, s);
}

inline bool  //
wuffs_base__range_ie_u64::contains(uint64_t x) {
  return wuffs_base__range_ie_u64__contains(this, x);
}

inline wuffs_base__range_ie_u64  //
wuffs_base__range_ie_u64::intersect(wuffs_base__range_ie_u64 s) {
  return wuffs_base__range_ie_u64__intersect(this, s);
}

inline wuffs_base__range_ie_u64  //
wuffs_base__range_ie_u64::unite(wuffs_base__range_ie_u64 s) {
  return wuffs_base__range_ie_u64__unite(this, s);
}

inline uint64_t  //
wuffs_base__range_ie_u64::length() {
  return wuffs_base__range_ie_u64__length(this);
}

#endif  // __cplusplus

// --------

// wuffs_base__rect_ii_u32 is a rectangle (a 2-dimensional range) on the
// integer grid. The "ii" means that the bounds are inclusive on the low end
// and inclusive on the high end. It contains all points (x, y) such that
// ((min_incl_x <= x) && (x <= max_incl_x)) and likewise for y.
//
// It is valid for min > max, in which case the rectangle is empty. There are
// multiple representations of an empty rectangle.
//
// The X and Y axes increase right and down.
typedef struct wuffs_base__rect_ii_u32__struct {
  uint32_t min_incl_x;
  uint32_t min_incl_y;
  uint32_t max_incl_x;
  uint32_t max_incl_y;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__rect_ii_u32__struct s);
  inline bool contains(uint32_t x, uint32_t y);
  inline wuffs_base__rect_ii_u32__struct intersect(
      wuffs_base__rect_ii_u32__struct s);
  inline wuffs_base__rect_ii_u32__struct unite(
      wuffs_base__rect_ii_u32__struct s);
#endif  // __cplusplus

} wuffs_base__rect_ii_u32;

static inline bool  //
wuffs_base__rect_ii_u32__is_empty(wuffs_base__rect_ii_u32* r) {
  return (r->min_incl_x > r->max_incl_x) || (r->min_incl_y > r->max_incl_y);
}

static inline bool  //
wuffs_base__rect_ii_u32__equals(wuffs_base__rect_ii_u32* r,
                                wuffs_base__rect_ii_u32 s) {
  return (r->min_incl_x == s.min_incl_x && r->min_incl_y == s.min_incl_y &&
          r->max_incl_x == s.max_incl_x && r->max_incl_y == s.max_incl_y) ||
         (wuffs_base__rect_ii_u32__is_empty(r) &&
          wuffs_base__rect_ii_u32__is_empty(&s));
}

static inline bool  //
wuffs_base__rect_ii_u32__contains(wuffs_base__rect_ii_u32* r,
                                  uint32_t x,
                                  uint32_t y) {
  return (r->min_incl_x <= x) && (x <= r->max_incl_x) && (r->min_incl_y <= y) &&
         (y <= r->max_incl_y);
}

static inline wuffs_base__rect_ii_u32  //
wuffs_base__rect_ii_u32__intersect(wuffs_base__rect_ii_u32* r,
                                   wuffs_base__rect_ii_u32 s) {
  wuffs_base__rect_ii_u32 t;
  t.min_incl_x = wuffs_base__u32__max(r->min_incl_x, s.min_incl_x);
  t.min_incl_y = wuffs_base__u32__max(r->min_incl_y, s.min_incl_y);
  t.max_incl_x = wuffs_base__u32__min(r->max_incl_x, s.max_incl_x);
  t.max_incl_y = wuffs_base__u32__min(r->max_incl_y, s.max_incl_y);
  return t;
}

static inline wuffs_base__rect_ii_u32  //
wuffs_base__rect_ii_u32__unite(wuffs_base__rect_ii_u32* r,
                               wuffs_base__rect_ii_u32 s) {
  if (wuffs_base__rect_ii_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__rect_ii_u32__is_empty(&s)) {
    return *r;
  }
  wuffs_base__rect_ii_u32 t;
  t.min_incl_x = wuffs_base__u32__min(r->min_incl_x, s.min_incl_x);
  t.min_incl_y = wuffs_base__u32__min(r->min_incl_y, s.min_incl_y);
  t.max_incl_x = wuffs_base__u32__max(r->max_incl_x, s.max_incl_x);
  t.max_incl_y = wuffs_base__u32__max(r->max_incl_y, s.max_incl_y);
  return t;
}

#ifdef __cplusplus

inline bool  //
wuffs_base__rect_ii_u32::is_empty() {
  return wuffs_base__rect_ii_u32__is_empty(this);
}

inline bool  //
wuffs_base__rect_ii_u32::equals(wuffs_base__rect_ii_u32 s) {
  return wuffs_base__rect_ii_u32__equals(this, s);
}

inline bool  //
wuffs_base__rect_ii_u32::contains(uint32_t x, uint32_t y) {
  return wuffs_base__rect_ii_u32__contains(this, x, y);
}

inline wuffs_base__rect_ii_u32  //
wuffs_base__rect_ii_u32::intersect(wuffs_base__rect_ii_u32 s) {
  return wuffs_base__rect_ii_u32__intersect(this, s);
}

inline wuffs_base__rect_ii_u32  //
wuffs_base__rect_ii_u32::unite(wuffs_base__rect_ii_u32 s) {
  return wuffs_base__rect_ii_u32__unite(this, s);
}

#endif  // __cplusplus

// --------

// wuffs_base__rect_ie_u32 is a rectangle (a 2-dimensional range) on the
// integer grid. The "ie" means that the bounds are inclusive on the low end
// and exclusive on the high end. It contains all points (x, y) such that
// ((min_incl_x <= x) && (x < max_excl_x)) and likewise for y.
//
// It is valid for min >= max, in which case the rectangle is empty. There are
// multiple representations of an empty rectangle, including a value with all
// fields zero.
//
// The X and Y axes increase right and down.
typedef struct wuffs_base__rect_ie_u32__struct {
  uint32_t min_incl_x;
  uint32_t min_incl_y;
  uint32_t max_excl_x;
  uint32_t max_excl_y;

#ifdef __cplusplus
  inline bool is_empty();
  inline bool equals(wuffs_base__rect_ie_u32__struct s);
  inline bool contains(uint32_t x, uint32_t y);
  inline wuffs_base__rect_ie_u32__struct intersect(
      wuffs_base__rect_ie_u32__struct s);
  inline wuffs_base__rect_ie_u32__struct unite(
      wuffs_base__rect_ie_u32__struct s);
  inline uint32_t width();
  inline uint32_t height();
#endif  // __cplusplus

} wuffs_base__rect_ie_u32;

static inline bool  //
wuffs_base__rect_ie_u32__is_empty(wuffs_base__rect_ie_u32* r) {
  return (r->min_incl_x >= r->max_excl_x) || (r->min_incl_y >= r->max_excl_y);
}

static inline bool  //
wuffs_base__rect_ie_u32__equals(wuffs_base__rect_ie_u32* r,
                                wuffs_base__rect_ie_u32 s) {
  return (r->min_incl_x == s.min_incl_x && r->min_incl_y == s.min_incl_y &&
          r->max_excl_x == s.max_excl_x && r->max_excl_y == s.max_excl_y) ||
         (wuffs_base__rect_ie_u32__is_empty(r) &&
          wuffs_base__rect_ie_u32__is_empty(&s));
}

static inline bool  //
wuffs_base__rect_ie_u32__contains(wuffs_base__rect_ie_u32* r,
                                  uint32_t x,
                                  uint32_t y) {
  return (r->min_incl_x <= x) && (x < r->max_excl_x) && (r->min_incl_y <= y) &&
         (y < r->max_excl_y);
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__rect_ie_u32__intersect(wuffs_base__rect_ie_u32* r,
                                   wuffs_base__rect_ie_u32 s) {
  wuffs_base__rect_ie_u32 t;
  t.min_incl_x = wuffs_base__u32__max(r->min_incl_x, s.min_incl_x);
  t.min_incl_y = wuffs_base__u32__max(r->min_incl_y, s.min_incl_y);
  t.max_excl_x = wuffs_base__u32__min(r->max_excl_x, s.max_excl_x);
  t.max_excl_y = wuffs_base__u32__min(r->max_excl_y, s.max_excl_y);
  return t;
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__rect_ie_u32__unite(wuffs_base__rect_ie_u32* r,
                               wuffs_base__rect_ie_u32 s) {
  if (wuffs_base__rect_ie_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__rect_ie_u32__is_empty(&s)) {
    return *r;
  }
  wuffs_base__rect_ie_u32 t;
  t.min_incl_x = wuffs_base__u32__min(r->min_incl_x, s.min_incl_x);
  t.min_incl_y = wuffs_base__u32__min(r->min_incl_y, s.min_incl_y);
  t.max_excl_x = wuffs_base__u32__max(r->max_excl_x, s.max_excl_x);
  t.max_excl_y = wuffs_base__u32__max(r->max_excl_y, s.max_excl_y);
  return t;
}

static inline uint32_t  //
wuffs_base__rect_ie_u32__width(wuffs_base__rect_ie_u32* r) {
  return wuffs_base__u32__sat_sub(r->max_excl_x, r->min_incl_x);
}

static inline uint32_t  //
wuffs_base__rect_ie_u32__height(wuffs_base__rect_ie_u32* r) {
  return wuffs_base__u32__sat_sub(r->max_excl_y, r->min_incl_y);
}

#ifdef __cplusplus

inline bool  //
wuffs_base__rect_ie_u32::is_empty() {
  return wuffs_base__rect_ie_u32__is_empty(this);
}

inline bool  //
wuffs_base__rect_ie_u32::equals(wuffs_base__rect_ie_u32 s) {
  return wuffs_base__rect_ie_u32__equals(this, s);
}

inline bool  //
wuffs_base__rect_ie_u32::contains(uint32_t x, uint32_t y) {
  return wuffs_base__rect_ie_u32__contains(this, x, y);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__rect_ie_u32::intersect(wuffs_base__rect_ie_u32 s) {
  return wuffs_base__rect_ie_u32__intersect(this, s);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__rect_ie_u32::unite(wuffs_base__rect_ie_u32 s) {
  return wuffs_base__rect_ie_u32__unite(this, s);
}

inline uint32_t  //
wuffs_base__rect_ie_u32::width() {
  return wuffs_base__rect_ie_u32__width(this);
}

inline uint32_t  //
wuffs_base__rect_ie_u32::height() {
  return wuffs_base__rect_ie_u32__height(this);
}

#endif  // __cplusplus

// ---------------- I/O

struct wuffs_base__io_buffer__struct;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    struct wuffs_base__io_buffer__struct* buf;
    // The bounds values are typically NULL, when created by the Wuffs public
    // API. NULL means that the callee substitutes the implicit bounds derived
    // from buf.
    uint8_t* bounds[2];
  } private_impl;
} wuffs_base__io_reader;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    struct wuffs_base__io_buffer__struct* buf;
    // The bounds values are typically NULL, when created by the Wuffs public
    // API. NULL means that the callee substitutes the implicit bounds derived
    // from buf.
    uint8_t* bounds[2];
  } private_impl;
} wuffs_base__io_writer;

// wuffs_base__io_buffer is a 1-dimensional buffer (a pointer and length), plus
// additional indexes into that buffer, plus an opened / closed flag.
//
// A value with all fields NULL or zero is a valid, empty buffer.
typedef struct wuffs_base__io_buffer__struct {
  uint8_t* ptr;  // Pointer.
  size_t len;    // Length.
  size_t wi;     // Write index. Invariant: wi <= len.
  size_t ri;     // Read  index. Invariant: ri <= wi.
  bool closed;   // No further writes are expected.

#ifdef __cplusplus
  inline void compact();
  inline wuffs_base__io_reader reader();
  inline wuffs_base__io_writer writer();
#endif  // __cplusplus

} wuffs_base__io_buffer;

// wuffs_base__io_buffer__compact moves any written but unread bytes to the
// start of the buffer.
static inline void  //
wuffs_base__io_buffer__compact(wuffs_base__io_buffer* buf) {
  if (!buf || (buf->ri == 0)) {
    return;
  }
  size_t n = buf->wi - buf->ri;
  if (n != 0) {
    memmove(buf->ptr, buf->ptr + buf->ri, n);
  }
  buf->wi = n;
  buf->ri = 0;
}

static inline wuffs_base__io_reader  //
wuffs_base__io_buffer__reader(wuffs_base__io_buffer* buf) {
  wuffs_base__io_reader ret = ((wuffs_base__io_reader){});
  ret.private_impl.buf = buf;
  return ret;
}

static inline wuffs_base__io_writer  //
wuffs_base__io_buffer__writer(wuffs_base__io_buffer* buf) {
  wuffs_base__io_writer ret = ((wuffs_base__io_writer){});
  ret.private_impl.buf = buf;
  return ret;
}

#ifdef __cplusplus

inline void  //
wuffs_base__io_buffer__struct::compact() {
  wuffs_base__io_buffer__compact(this);
}

inline wuffs_base__io_reader  //
wuffs_base__io_buffer__struct::reader() {
  return wuffs_base__io_buffer__reader(this);
}

inline wuffs_base__io_writer  //
wuffs_base__io_buffer__struct::writer() {
  return wuffs_base__io_buffer__writer(this);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Images

// wuffs_base__color_u32argb is an 8 bit per channel Alpha, Red, Green, Blue
// color, as a uint32_t value. It is in word order, not byte order: its value
// is always 0xAARRGGBB, regardless of endianness. It uses premultiplied alpha.
typedef uint32_t wuffs_base__color_u32argb;

// --------

// wuffs_base__pixel_format encodes the format of the bytes that constitute an
// image frame's pixel data. Its bits:
//  - bit        31  is reserved.
//  - bits 30 .. 28 encodes color (and channel order, in terms of memory).
//  - bits 27 .. 26 are reserved.
//  - bits 25 .. 24 encodes transparency.
//  - bit        23 indicates big-endian/MSB-first (as opposed to little/LSB).
//  - bit        22 indicates floating point (as opposed to integer).
//  - bits 21 .. 20 are the number of planes, minus 1. Zero means packed.
//  - bits 19 .. 16 encodes the number of bits (depth) in an index value.
//                  Zero means direct, not palette-indexed.
//  - bits 15 .. 12 encodes the number of bits (depth) in the 3rd channel.
//  - bits 11 ..  8 encodes the number of bits (depth) in the 2nd channel.
//  - bits  7 ..  4 encodes the number of bits (depth) in the 1st channel.
//  - bits  3 ..  0 encodes the number of bits (depth) in the 0th channel.
//
// The bit fields of a wuffs_base__pixel_format are not independent. For
// example, the number of planes should not be greater than the number of
// channels. Similarly, bits 15..4 are unused (and should be zero) if bits
// 31..24 (color and transparency) together imply only 1 channel (gray, no
// alpha) and floating point samples should mean a bit depth of 16, 32 or 64.
//
// Formats hold between 1 and 4 channels. For example: Y (1 channel: gray), YA
// (2 channels: gray and alpha), BGR (3 channels: blue, green, red) or CMYK (4
// channels: cyan, magenta, yellow, black).
//
// For direct formats with N > 1 channels, those channels can be laid out in
// either 1 (packed) or N (planar) planes. For example, RGBA data is usually
// packed, but YUV data is usually planar, due to chroma subsampling (for
// details, see the wuffs_base__pixel_subsampling type). For indexed formats,
// the palette (always 256 × 4 bytes) holds up to 4 packed bytes of color data
// per index value, and there is only 1 plane (for the index). The distance
// between successive palette elements is always 4 bytes.
//
// The color field is encoded in 3 bits:
//  - 0 means                 A (Alpha).
//  - 1 means   Y       or   YA (Gray, Alpha).
//  - 2 means BGR, BGRX or BGRA (Blue, Green, Red, X-padding or Alpha).
//  - 3 means RGB, RGBX or RGBA (Red, Green, Blue, X-padding or Alpha).
//  - 4 means YUV       or YUVA (Luma, Chroma-blue, Chroma-red, Alpha).
//  - 5 means CMY       or CMYK (Cyan, Magenta, Yellow, Black).
//  - all other values are reserved.
//
// In Wuffs, channels are given in memory order (also known as byte order),
// regardless of endianness, since the C type for the pixel data is an array of
// bytes, not an array of uint32_t. For example, packed BGRA with 8 bits per
// channel means that the bytes in memory are always Blue, Green, Red then
// Alpha. On big-endian systems, that is the uint32_t 0xBBGGRRAA. On
// little-endian, 0xAARRGGBB.
//
// When the color field (3 bits) encodes multiple options, the transparency
// field (2 bits) distinguishes them:
//  - 0 means fully opaque, no extra channels
//  - 1 means fully opaque, one extra channel (X or K, padding or black).
//  - 2 means one extra alpha channel, other channels are non-premultiplied.
//  - 3 means one extra alpha channel, other channels are     premultiplied.
//
// The zero wuffs_base__pixel_format value is an invalid pixel format, as it is
// invalid to combine the zero color (alpha only) with the zero transparency.
//
// Bit depth is encoded in 4 bits:
//  -  0 means the channel or index is unused.
//  -  x means a bit depth of  x, for x in the range 1..8.
//  -  9 means a bit depth of 10.
//  - 10 means a bit depth of 12.
//  - 11 means a bit depth of 16.
//  - 12 means a bit depth of 24.
//  - 13 means a bit depth of 32.
//  - 14 means a bit depth of 48.
//  - 15 means a bit depth of 64.
//
// For example, wuffs_base__pixel_format 0x3280BBBB is a natural format for
// decoding a PNG image - network byte order (also known as big-endian),
// packed, non-premultiplied alpha - that happens to be 16-bit-depth truecolor
// with alpha (RGBA). In memory order:
//
//  ptr+0  ptr+1  ptr+2  ptr+3  ptr+4  ptr+5  ptr+6  ptr+7
//  Rhi    Rlo    Ghi    Glo    Bhi    Blo    Ahi    Alo
//
// For example, the value wuffs_base__pixel_format 0x20000565 means BGR with no
// alpha or padding, 5/6/5 bits for blue/green/red, packed 2 bytes per pixel,
// laid out LSB-first in memory order:
//
//  ptr+0...........  ptr+1...........
//  MSB          LSB  MSB          LSB
//  G₂G₁G₀B₄B₃B₂B₁B₀  R₄R₃R₂R₁R₀G₅G₄G₃
//
// On little-endian systems (but not big-endian), this Wuffs pixel format value
// (0x20000565) corresponds to the Cairo library's CAIRO_FORMAT_RGB16_565, the
// SDL2 (Simple DirectMedia Layer 2) library's SDL_PIXELFORMAT_RGB565 and the
// Skia library's kRGB_565_SkColorType. Note BGR in Wuffs versus RGB in the
// other libraries.
//
// Regardless of endianness, this Wuffs pixel format value (0x20000565)
// corresponds to the V4L2 (Video For Linux 2) library's V4L2_PIX_FMT_RGB565
// and the Wayland-DRM library's WL_DRM_FORMAT_RGB565.
//
// Different software libraries name their pixel formats (and especially their
// channel order) either according to memory layout or as bits of a native
// integer type like uint32_t. The two conventions differ because of a system's
// endianness. As mentioned earlier, Wuffs pixel formats are always in memory
// order. More detail of other software libraries' naming conventions is in the
// Pixel Format Guide at https://afrantzis.github.io/pixel-format-guide/
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_base__pixel_format__num_planes instead.
typedef uint32_t wuffs_base__pixel_format;

// Common 8-bit-depth pixel formats. This list is not exhaustive; not all valid
// wuffs_base__pixel_format values are present.

#define WUFFS_BASE__PIXEL_FORMAT__INVALID ((wuffs_base__pixel_format)0x00000000)

#define WUFFS_BASE__PIXEL_FORMAT__A ((wuffs_base__pixel_format)0x02000008)

#define WUFFS_BASE__PIXEL_FORMAT__Y ((wuffs_base__pixel_format)0x10000008)
#define WUFFS_BASE__PIXEL_FORMAT__YA_NONPREMUL \
  ((wuffs_base__pixel_format)0x12000008)
#define WUFFS_BASE__PIXEL_FORMAT__YA_PREMUL \
  ((wuffs_base__pixel_format)0x13000008)

#define WUFFS_BASE__PIXEL_FORMAT__BGR ((wuffs_base__pixel_format)0x20000888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRX ((wuffs_base__pixel_format)0x21008888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRX_INDEXED \
  ((wuffs_base__pixel_format)0x21088888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL \
  ((wuffs_base__pixel_format)0x22008888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL_INDEXED \
  ((wuffs_base__pixel_format)0x22088888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_PREMUL \
  ((wuffs_base__pixel_format)0x23008888)

#define WUFFS_BASE__PIXEL_FORMAT__RGB ((wuffs_base__pixel_format)0x30000888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBX ((wuffs_base__pixel_format)0x31008888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBX_INDEXED \
  ((wuffs_base__pixel_format)0x31088888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL \
  ((wuffs_base__pixel_format)0x32008888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL_INDEXED \
  ((wuffs_base__pixel_format)0x32088888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_PREMUL \
  ((wuffs_base__pixel_format)0x33008888)

#define WUFFS_BASE__PIXEL_FORMAT__YUV ((wuffs_base__pixel_format)0x40200888)
#define WUFFS_BASE__PIXEL_FORMAT__YUVK ((wuffs_base__pixel_format)0x41308888)
#define WUFFS_BASE__PIXEL_FORMAT__YUVA_NONPREMUL \
  ((wuffs_base__pixel_format)0x42308888)

#define WUFFS_BASE__PIXEL_FORMAT__CMY ((wuffs_base__pixel_format)0x50200888)
#define WUFFS_BASE__PIXEL_FORMAT__CMYK ((wuffs_base__pixel_format)0x51308888)

static inline bool  //
wuffs_base__pixel_format__is_valid(wuffs_base__pixel_format f) {
  return f != 0;
}

static inline bool  //
wuffs_base__pixel_format__is_indexed(wuffs_base__pixel_format f) {
  return ((f >> 16) & 0x0F) != 0;
}

#define WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX 4

static inline uint32_t  //
wuffs_base__pixel_format__num_planes(wuffs_base__pixel_format f) {
  return f ? (((f >> 20) & 0x03) + 1) : 0;
}

// --------

// wuffs_base__pixel_subsampling encodes the mapping of pixel space coordinates
// (x, y) to pixel buffer indices (i, j). That mapping can differ for each
// plane p. For a depth of 8 bits (1 byte), the p'th plane's sample starts at
// (planes[p].ptr + (j * planes[p].stride) + i).
//
// For packed pixel formats, the mapping is trivial: i = x and j = y. For
// planar pixel formats, the mapping can differ due to chroma subsampling. For
// example, consider a three plane YUV pixel format with 4:2:2 subsampling. For
// the luma (Y) channel, there is one sample for every pixel, but for the
// chroma (U, V) channels, there is one sample for every two pixels: pairs of
// horizontally adjacent pixels form one macropixel, i = x / 2 and j == y. In
// general, for a given p:
//  - i = (x + bias_x) >> shift_x.
//  - j = (y + bias_y) >> shift_y.
// where biases and shifts are in the range 0..3 and 0..2 respectively.
//
// In general, the biases will be zero after decoding an image. However, making
// a sub-image may change the bias, since the (x, y) coordinates are relative
// to the sub-image's top-left origin, but the backing pixel buffers were
// created relative to the original image's origin.
//
// For each plane p, each of those four numbers (biases and shifts) are encoded
// in two bits, which combine to form an 8 bit unsigned integer:
//
//  e_p = (bias_x << 6) | (shift_x << 4) | (bias_y << 2) | (shift_y << 0)
//
// Those e_p values (e_0 for the first plane, e_1 for the second plane, etc)
// combine to form a wuffs_base__pixel_subsampling value:
//
//  pixsub = (e_3 << 24) | (e_2 << 16) | (e_1 << 8) | (e_0 << 0)
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_base__pixel_subsampling__bias_x instead.
typedef uint32_t wuffs_base__pixel_subsampling;

#define WUFFS_BASE__PIXEL_SUBSAMPLING__NONE ((wuffs_base__pixel_subsampling)0)

#define WUFFS_BASE__PIXEL_SUBSAMPLING__444 \
  ((wuffs_base__pixel_subsampling)0x000000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__440 \
  ((wuffs_base__pixel_subsampling)0x010100)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__422 \
  ((wuffs_base__pixel_subsampling)0x101000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__420 \
  ((wuffs_base__pixel_subsampling)0x111100)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__411 \
  ((wuffs_base__pixel_subsampling)0x202000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__410 \
  ((wuffs_base__pixel_subsampling)0x212100)

static inline uint32_t  //
wuffs_base__pixel_subsampling__bias_x(wuffs_base__pixel_subsampling s,
                                      uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 6;
  return (s >> shift) & 0x03;
}

static inline uint32_t  //
wuffs_base__pixel_subsampling__shift_x(wuffs_base__pixel_subsampling s,
                                       uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 4;
  return (s >> shift) & 0x03;
}

static inline uint32_t  //
wuffs_base__pixel_subsampling__bias_y(wuffs_base__pixel_subsampling s,
                                      uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 2;
  return (s >> shift) & 0x03;
}

static inline uint32_t  //
wuffs_base__pixel_subsampling__shift_y(wuffs_base__pixel_subsampling s,
                                       uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 0;
  return (s >> shift) & 0x03;
}

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__pixel_format pixfmt;
    wuffs_base__pixel_subsampling pixsub;
    uint32_t width;
    uint32_t height;
  } private_impl;

#ifdef __cplusplus
  inline void initialize(wuffs_base__pixel_format pixfmt,
                         wuffs_base__pixel_subsampling pixsub,
                         uint32_t width,
                         uint32_t height);
  inline void invalidate();
  inline bool is_valid();
  inline wuffs_base__pixel_format pixel_format();
  inline wuffs_base__pixel_subsampling pixel_subsampling();
  inline wuffs_base__rect_ie_u32 bounds();
  inline uint32_t width();
  inline uint32_t height();
  inline size_t pixbuf_size();
#endif  // __cplusplus

} wuffs_base__pixel_config;

// TODO: Should this function return bool? An error type?
static inline void  //
wuffs_base__pixel_config__initialize(wuffs_base__pixel_config* c,
                                     wuffs_base__pixel_format pixfmt,
                                     wuffs_base__pixel_subsampling pixsub,
                                     uint32_t width,
                                     uint32_t height) {
  if (!c) {
    return;
  }
  if (pixfmt) {
    uint64_t wh = ((uint64_t)width) * ((uint64_t)height);
    // TODO: handle things other than 1 byte per pixel.
    if (wh <= ((uint64_t)SIZE_MAX)) {
      c->private_impl.pixfmt = pixfmt;
      c->private_impl.pixsub = pixsub;
      c->private_impl.width = width;
      c->private_impl.height = height;
      return;
    }
  }
  *c = ((wuffs_base__pixel_config){});
}

static inline void  //
wuffs_base__pixel_config__invalidate(wuffs_base__pixel_config* c) {
  if (c) {
    *c = ((wuffs_base__pixel_config){});
  }
}

static inline bool  //
wuffs_base__pixel_config__is_valid(wuffs_base__pixel_config* c) {
  return c && c->private_impl.pixfmt;
}

static inline wuffs_base__pixel_format  //
wuffs_base__pixel_config__pixel_format(wuffs_base__pixel_config* c) {
  return c ? c->private_impl.pixfmt : 0;
}

static inline wuffs_base__pixel_subsampling  //
wuffs_base__pixel_config__pixel_subsampling(wuffs_base__pixel_config* c) {
  return c ? c->private_impl.pixsub : 0;
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__pixel_config__bounds(wuffs_base__pixel_config* c) {
  return c ? ((wuffs_base__rect_ie_u32){
                 .min_incl_x = 0,
                 .min_incl_y = 0,
                 .max_excl_x = c->private_impl.width,
                 .max_excl_y = c->private_impl.height,
             })
           : ((wuffs_base__rect_ie_u32){});
}

static inline uint32_t  //
wuffs_base__pixel_config__width(wuffs_base__pixel_config* c) {
  return c ? c->private_impl.width : 0;
}

static inline uint32_t  //
wuffs_base__pixel_config__height(wuffs_base__pixel_config* c) {
  return c ? c->private_impl.height : 0;
}

// TODO: this is the right API for planar (not packed) pixbufs? Should it allow
// decoding into a color model different from the format's intrinsic one? For
// example, decoding a JPEG image straight to RGBA instead of to YCbCr?
static inline size_t  //
wuffs_base__pixel_config__pixbuf_size(wuffs_base__pixel_config* c) {
  if (c) {
    uint64_t wh =
        ((uint64_t)c->private_impl.width) * ((uint64_t)c->private_impl.height);
    // TODO: handle things other than 1 byte per pixel.
    return (size_t)wh;
  }
  return 0;
}

#ifdef __cplusplus

inline void  //
wuffs_base__pixel_config::initialize(wuffs_base__pixel_format pixfmt,
                                     wuffs_base__pixel_subsampling pixsub,
                                     uint32_t width,
                                     uint32_t height) {
  wuffs_base__pixel_config__initialize(this, pixfmt, pixsub, width, height);
}

inline void  //
wuffs_base__pixel_config::invalidate() {
  wuffs_base__pixel_config__invalidate(this);
}

inline bool  //
wuffs_base__pixel_config::is_valid() {
  return wuffs_base__pixel_config__is_valid(this);
}

inline wuffs_base__pixel_format  //
wuffs_base__pixel_config::pixel_format() {
  return wuffs_base__pixel_config__pixel_format(this);
}

inline wuffs_base__pixel_subsampling  //
wuffs_base__pixel_config::pixel_subsampling() {
  return wuffs_base__pixel_config__pixel_subsampling(this);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__pixel_config::bounds() {
  return wuffs_base__pixel_config__bounds(this);
}

inline uint32_t  //
wuffs_base__pixel_config::width() {
  return wuffs_base__pixel_config__width(this);
}

inline uint32_t  //
wuffs_base__pixel_config::height() {
  return wuffs_base__pixel_config__height(this);
}

inline size_t  //
wuffs_base__pixel_config::pixbuf_size() {
  return wuffs_base__pixel_config__pixbuf_size(this);
}

#endif  // __cplusplus

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__pixel_config pixcfg;
    uint32_t num_loops;
    bool first_frame_is_opaque;
  } private_impl;

#ifdef __cplusplus
  inline void initialize(wuffs_base__pixel_format pixfmt,
                         wuffs_base__pixel_subsampling pixsub,
                         uint32_t width,
                         uint32_t height,
                         uint32_t num_loops,
                         bool first_frame_is_opaque);
  inline void invalidate();
  inline bool is_valid();
  inline wuffs_base__pixel_config* pixel_config();
  inline wuffs_base__pixel_format pixel_format();
  inline wuffs_base__pixel_subsampling pixel_subsampling();
  inline wuffs_base__rect_ie_u32 bounds();
  inline uint32_t width();
  inline uint32_t height();
  inline uint32_t num_loops();
  inline uint32_t first_frame_is_opaque();
#endif  // __cplusplus

} wuffs_base__image_config;

// TODO: Should this function return bool? An error type?
static inline void  //
wuffs_base__image_config__initialize(wuffs_base__image_config* c,
                                     wuffs_base__pixel_format pixfmt,
                                     wuffs_base__pixel_subsampling pixsub,
                                     uint32_t width,
                                     uint32_t height,
                                     uint32_t num_loops,
                                     bool first_frame_is_opaque) {
  if (!c) {
    return;
  }
  if (wuffs_base__pixel_format__is_valid(pixfmt)) {
    c->private_impl.pixcfg.private_impl.pixfmt = pixfmt;
    c->private_impl.pixcfg.private_impl.pixsub = pixsub;
    c->private_impl.pixcfg.private_impl.width = width;
    c->private_impl.pixcfg.private_impl.height = height;
    c->private_impl.num_loops = num_loops;
    c->private_impl.first_frame_is_opaque = first_frame_is_opaque;
    return;
  }
  *c = ((wuffs_base__image_config){});
}

static inline void  //
wuffs_base__image_config__invalidate(wuffs_base__image_config* c) {
  if (c) {
    *c = ((wuffs_base__image_config){});
  }
}

static inline bool  //
wuffs_base__image_config__is_valid(wuffs_base__image_config* c) {
  return c && wuffs_base__pixel_config__is_valid(&(c->private_impl.pixcfg));
}

static inline wuffs_base__pixel_config*  //
wuffs_base__image_config__pixel_config(wuffs_base__image_config* c) {
  return c ? &c->private_impl.pixcfg : NULL;
}

static inline wuffs_base__pixel_format  //
wuffs_base__image_config__pixel_format(wuffs_base__image_config* c) {
  return c ? c->private_impl.pixcfg.private_impl.pixfmt : 0;
}

static inline wuffs_base__pixel_subsampling  //
wuffs_base__image_config__pixel_subsampling(wuffs_base__image_config* c) {
  return c ? c->private_impl.pixcfg.private_impl.pixsub : 0;
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__image_config__bounds(wuffs_base__image_config* c) {
  return c ? ((wuffs_base__rect_ie_u32){
                 .min_incl_x = 0,
                 .min_incl_y = 0,
                 .max_excl_x = c->private_impl.pixcfg.private_impl.width,
                 .max_excl_y = c->private_impl.pixcfg.private_impl.height,
             })
           : ((wuffs_base__rect_ie_u32){});
}

static inline uint32_t  //
wuffs_base__image_config__width(wuffs_base__image_config* c) {
  return c ? c->private_impl.pixcfg.private_impl.width : 0;
}

static inline uint32_t  //
wuffs_base__image_config__height(wuffs_base__image_config* c) {
  return c ? c->private_impl.pixcfg.private_impl.height : 0;
}

static inline uint32_t  //
wuffs_base__image_config__num_loops(wuffs_base__image_config* c) {
  return c ? c->private_impl.num_loops : 0;
}

static inline uint32_t  //
wuffs_base__image_config__first_frame_is_opaque(wuffs_base__image_config* c) {
  return c ? c->private_impl.first_frame_is_opaque : false;
}

#ifdef __cplusplus

inline void  //
wuffs_base__image_config::initialize(wuffs_base__pixel_format pixfmt,
                                     wuffs_base__pixel_subsampling pixsub,
                                     uint32_t width,
                                     uint32_t height,
                                     uint32_t num_loops,
                                     bool first_frame_is_opaque) {
  wuffs_base__image_config__initialize(this, pixfmt, pixsub, width, height,
                                       num_loops, first_frame_is_opaque);
}

inline void  //
wuffs_base__image_config::invalidate() {
  wuffs_base__image_config__invalidate(this);
}

inline bool  //
wuffs_base__image_config::is_valid() {
  return wuffs_base__image_config__is_valid(this);
}

inline wuffs_base__pixel_config*  //
wuffs_base__image_config::pixel_config() {
  return wuffs_base__image_config__pixel_config(this);
}

inline wuffs_base__pixel_format  //
wuffs_base__image_config::pixel_format() {
  return wuffs_base__image_config__pixel_format(this);
}

inline wuffs_base__pixel_subsampling  //
wuffs_base__image_config::pixel_subsampling() {
  return wuffs_base__image_config__pixel_subsampling(this);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__image_config::bounds() {
  return wuffs_base__image_config__bounds(this);
}

inline uint32_t  //
wuffs_base__image_config::width() {
  return wuffs_base__image_config__width(this);
}

inline uint32_t  //
wuffs_base__image_config::height() {
  return wuffs_base__image_config__height(this);
}

inline uint32_t  //
wuffs_base__image_config::num_loops() {
  return wuffs_base__image_config__num_loops(this);
}

inline uint32_t  //
wuffs_base__image_config::first_frame_is_opaque() {
  return wuffs_base__image_config__first_frame_is_opaque(this);
}

#endif  // __cplusplus

// --------

// wuffs_base__animation_disposal encodes, for an animated image, how to
// dispose of a frame after displaying it:
//  - None means to draw the next frame on top of this one.
//  - Restore Background means to clear the frame's dirty rectangle to "the
//    background color" (in practice, this means transparent black) before
//    drawing the next frame.
//  - Restore Previous means to undo the current frame, so that the next frame
//    is drawn on top of the previous one.
typedef uint8_t wuffs_base__animation_disposal;

#define WUFFS_BASE__ANIMATION_DISPOSAL__NONE ((wuffs_base__animation_disposal)0)
#define WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_BACKGROUND \
  ((wuffs_base__animation_disposal)1)
#define WUFFS_BASE__ANIMATION_DISPOSAL__RESTORE_PREVIOUS \
  ((wuffs_base__animation_disposal)2)

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__rect_ie_u32 bounds;
    wuffs_base__flicks duration;
    bool blend;
    wuffs_base__animation_disposal disposal;
    bool palette_changed;
  } private_impl;

#ifdef __cplusplus
  inline void update(wuffs_base__rect_ie_u32 bounds,
                     wuffs_base__flicks duration,
                     bool blend,
                     wuffs_base__animation_disposal disposal,
                     bool palette_changed);
  inline wuffs_base__rect_ie_u32 bounds();
  inline uint32_t width();
  inline uint32_t height();
  inline wuffs_base__flicks duration();
  inline bool blend();
  inline wuffs_base__animation_disposal disposal();
  inline bool palette_changed();
#endif  // __cplusplus

} wuffs_base__frame_config;

static inline void  //
wuffs_base__frame_config__update(wuffs_base__frame_config* c,
                                 wuffs_base__rect_ie_u32 bounds,
                                 wuffs_base__flicks duration,
                                 bool blend,
                                 wuffs_base__animation_disposal disposal,
                                 bool palette_changed) {
  if (!c) {
    return;
  }

  c->private_impl.bounds = bounds;
  c->private_impl.duration = duration;
  c->private_impl.blend = blend;
  c->private_impl.disposal = disposal;
  c->private_impl.palette_changed = palette_changed;
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__frame_config__bounds(wuffs_base__frame_config* c) {
  return c ? c->private_impl.bounds : ((wuffs_base__rect_ie_u32){});
}

static inline uint32_t  //
wuffs_base__frame_config__width(wuffs_base__frame_config* c) {
  return c ? wuffs_base__rect_ie_u32__width(&c->private_impl.bounds) : 0;
}

static inline uint32_t  //
wuffs_base__frame_config__height(wuffs_base__frame_config* c) {
  return c ? wuffs_base__rect_ie_u32__height(&c->private_impl.bounds) : 0;
}

// wuffs_base__frame_config__duration returns the amount of time to display
// this frame. Zero means to display forever - a still (non-animated) image.
static inline wuffs_base__flicks  //
wuffs_base__frame_config__duration(wuffs_base__frame_config* c) {
  return c ? c->private_impl.duration : 0;
}

// wuffs_base__frame_config__blend returns, for a transparent image, whether to
// blend this frame with the existing canvas.
//
// In Porter-Duff compositing operator terminology, false means "src" and true
// means "src over dst".
static inline bool  //
wuffs_base__frame_config__blend(wuffs_base__frame_config* c) {
  return c && c->private_impl.blend;
}

// wuffs_base__frame_config__disposal returns, for an animated image, how to
// dispose of this frame after displaying it.
static inline wuffs_base__animation_disposal  //
wuffs_base__frame_config__disposal(wuffs_base__frame_config* c) {
  return c ? c->private_impl.disposal : 0;
}

// wuffs_base__frame_config__palette_changed returns whether this frame's
// palette differs from the previous frame. It is conservative and may return
// false positives (but never false negatives).
static inline bool  //
wuffs_base__frame_config__palette_changed(wuffs_base__frame_config* c) {
  return c && c->private_impl.palette_changed;
}

#ifdef __cplusplus

inline void  //
wuffs_base__frame_config::update(wuffs_base__rect_ie_u32 bounds,
                                 wuffs_base__flicks duration,
                                 bool blend,
                                 wuffs_base__animation_disposal disposal,
                                 bool palette_changed) {
  wuffs_base__frame_config__update(this, bounds, duration, blend, disposal,
                                   palette_changed);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__frame_config::bounds() {
  return wuffs_base__frame_config__bounds(this);
}

inline uint32_t  //
wuffs_base__frame_config::width() {
  return wuffs_base__frame_config__width(this);
}

inline uint32_t  //
wuffs_base__frame_config::height() {
  return wuffs_base__frame_config__height(this);
}

inline wuffs_base__flicks  //
wuffs_base__frame_config::duration() {
  return wuffs_base__frame_config__duration(this);
}

inline bool  //
wuffs_base__frame_config::blend() {
  return wuffs_base__frame_config__blend(this);
}

inline wuffs_base__animation_disposal  //
wuffs_base__frame_config::disposal() {
  return wuffs_base__frame_config__disposal(this);
}

inline bool  //
wuffs_base__frame_config::palette_changed() {
  return wuffs_base__frame_config__palette_changed(this);
}

#endif  // __cplusplus

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__pixel_config pixcfg;
    wuffs_base__table_u8 planes[WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX];
    uint8_t palette[1024];
    // TODO: color spaces.
  } private_impl;

#ifdef __cplusplus
  inline wuffs_base__status set_from_slice(wuffs_base__pixel_config* pixcfg,
                                           wuffs_base__slice_u8 pixbuf_memory);
  inline void set_palette(wuffs_base__slice_u8 palette);
  inline wuffs_base__pixel_config* pixel_config();
  inline wuffs_base__rect_ie_u32 bounds();
  inline uint32_t width();
  inline uint32_t height();
  inline wuffs_base__table_u8 plane(uint32_t p);
  inline wuffs_base__slice_u8 palette();
#endif  // __cplusplus

} wuffs_base__pixel_buffer;

static inline wuffs_base__status  //
wuffs_base__pixel_buffer__set_from_slice(wuffs_base__pixel_buffer* b,
                                         wuffs_base__pixel_config* pixcfg,
                                         wuffs_base__slice_u8 pixbuf_memory) {
  if (!b) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  *b = ((wuffs_base__pixel_buffer){});
  if (!pixcfg) {
    return WUFFS_BASE__ERROR_BAD_ARGUMENT;
  }
  // TODO: don't assume 1 byte per pixel. Don't assume packed.
  uint64_t wh = ((uint64_t)pixcfg->private_impl.width) *
                ((uint64_t)pixcfg->private_impl.height);
  if (wh > pixbuf_memory.len) {
    return WUFFS_BASE__ERROR_BAD_ARGUMENT_LENGTH_TOO_SHORT;
  }
  b->private_impl.pixcfg = *pixcfg;
  wuffs_base__table_u8* tab = &b->private_impl.planes[0];
  tab->ptr = pixbuf_memory.ptr;
  tab->width = pixcfg->private_impl.width;
  tab->height = pixcfg->private_impl.height;
  tab->stride = pixcfg->private_impl.width;
  return WUFFS_BASE__STATUS_OK;
}

// The palette argument is ignored unless its length is exactly 1024.
static inline void  //
wuffs_base__pixel_buffer__set_palette(wuffs_base__pixel_buffer* b,
                                      wuffs_base__slice_u8 palette) {
  if (b && palette.ptr && (palette.len == 1024)) {
    memmove(b->private_impl.palette, palette.ptr, 1024);
  }
}

// wuffs_base__pixel_config returns the overall configuration for this frame.
static inline wuffs_base__pixel_config*  //
wuffs_base__pixel_buffer__pixel_config(wuffs_base__pixel_buffer* b) {
  return b ? &b->private_impl.pixcfg : NULL;
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__pixel_buffer__bounds(wuffs_base__pixel_buffer* b) {
  return b ? wuffs_base__pixel_config__bounds(&b->private_impl.pixcfg)
           : ((wuffs_base__rect_ie_u32){});
}

static inline uint32_t  //
wuffs_base__pixel_buffer__width(wuffs_base__pixel_buffer* b) {
  return b ? wuffs_base__pixel_config__width(&b->private_impl.pixcfg) : 0;
}

static inline uint32_t  //
wuffs_base__pixel_buffer__height(wuffs_base__pixel_buffer* b) {
  return b ? wuffs_base__pixel_config__height(&b->private_impl.pixcfg) : 0;
}

static inline wuffs_base__table_u8  //
wuffs_base__pixel_buffer__plane(wuffs_base__pixel_buffer* b, uint32_t p) {
  return (b && (p < WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX))
             ? b->private_impl.planes[p]
             : ((wuffs_base__table_u8){});
}

// wuffs_base__pixel_buffer__palette returns the palette that the pixel data
// can index. The backing array is inside b and has length 1024.
static inline wuffs_base__slice_u8  //
wuffs_base__pixel_buffer__palette(wuffs_base__pixel_buffer* b) {
  return b ? ((wuffs_base__slice_u8){.ptr = b->private_impl.palette,
                                     .len = 1024})
           : ((wuffs_base__slice_u8){});
}

#ifdef __cplusplus

inline wuffs_base__status  //
wuffs_base__pixel_buffer::set_from_slice(wuffs_base__pixel_config* pixcfg,
                                         wuffs_base__slice_u8 pixbuf_memory) {
  return wuffs_base__pixel_buffer__set_from_slice(this, pixcfg, pixbuf_memory);
}

inline void  //
wuffs_base__pixel_buffer::set_palette(wuffs_base__slice_u8 palette) {
  wuffs_base__pixel_buffer__set_palette(this, palette);
}

inline wuffs_base__pixel_config*  //
wuffs_base__pixel_buffer::pixel_config() {
  return wuffs_base__pixel_buffer__pixel_config(this);
}

inline wuffs_base__rect_ie_u32  //
wuffs_base__pixel_buffer::bounds() {
  return wuffs_base__pixel_buffer__bounds(this);
}

inline uint32_t  //
wuffs_base__pixel_buffer::width() {
  return wuffs_base__pixel_buffer__width(this);
}

inline uint32_t  //
wuffs_base__pixel_buffer::height() {
  return wuffs_base__pixel_buffer__height(this);
}

inline wuffs_base__table_u8  //
wuffs_base__pixel_buffer::plane(uint32_t p) {
  return wuffs_base__pixel_buffer__plane(this, p);
}

inline wuffs_base__slice_u8  //
wuffs_base__pixel_buffer::palette() {
  return wuffs_base__pixel_buffer__palette(this);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_adler32__packageid 681002  // 0x000A642A

const char* wuffs_adler32__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_adler32__hasher__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    uint32_t f_state;
    bool f_started;

  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline uint32_t update(wuffs_base__slice_u8 a_x);
#endif  // __cplusplus

} wuffs_adler32__hasher;

// ---------------- Public Initializer Prototypes

// wuffs_adler32__hasher__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_adler32__hasher__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_adler32__hasher__check_wuffs_version(wuffs_adler32__hasher* self,
                                                size_t sizeof_star_self,
                                                uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC uint32_t  //
wuffs_adler32__hasher__update(wuffs_adler32__hasher* self,
                              wuffs_base__slice_u8 a_x);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_adler32__hasher::check_wuffs_version(size_t sizeof_star_self,
                                           uint64_t wuffs_version) {
  wuffs_adler32__hasher__check_wuffs_version(this, sizeof_star_self,
                                             wuffs_version);
}

inline uint32_t  //
wuffs_adler32__hasher::update(wuffs_base__slice_u8 a_x) {
  return wuffs_adler32__hasher__update(this, a_x);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_crc32__packageid 810620  // 0x000C5E7C

const char* wuffs_crc32__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_crc32__ieee_hasher__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    uint32_t f_state;

  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline uint32_t update(wuffs_base__slice_u8 a_x);
#endif  // __cplusplus

} wuffs_crc32__ieee_hasher;

// ---------------- Public Initializer Prototypes

// wuffs_crc32__ieee_hasher__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_crc32__ieee_hasher__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_crc32__ieee_hasher__check_wuffs_version(
    wuffs_crc32__ieee_hasher* self,
    size_t sizeof_star_self,
    uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC uint32_t  //
wuffs_crc32__ieee_hasher__update(wuffs_crc32__ieee_hasher* self,
                                 wuffs_base__slice_u8 a_x);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_crc32__ieee_hasher::check_wuffs_version(size_t sizeof_star_self,
                                              uint64_t wuffs_version) {
  wuffs_crc32__ieee_hasher__check_wuffs_version(this, sizeof_star_self,
                                                wuffs_version);
}

inline uint32_t  //
wuffs_crc32__ieee_hasher::update(wuffs_base__slice_u8 a_x) {
  return wuffs_crc32__ieee_hasher__update(this, a_x);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_deflate__packageid 848533  // 0x000CF295

#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_OVER_SUBSCRIBED \
  -15928683  // 0xFF0CF295
#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_UNDER_SUBSCRIBED \
  -32705899  // 0xFE0CF295
#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT \
  -49483115  // 0xFD0CF295
#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_LENGTH_REPETITION \
  -66260331                                              // 0xFC0CF295
#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE -83037547  // 0xFB0CF295
#define WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_MINIMUM_CODE_LENGTH \
  -99814763                                                      // 0xFA0CF295
#define WUFFS_DEFLATE__ERROR_BAD_BLOCK -116591979                // 0xF90CF295
#define WUFFS_DEFLATE__ERROR_BAD_DISTANCE -133369195             // 0xF80CF295
#define WUFFS_DEFLATE__ERROR_BAD_DISTANCE_CODE_COUNT -150146411  // 0xF70CF295
#define WUFFS_DEFLATE__ERROR_BAD_LITERAL_LENGTH_CODE_COUNT \
  -166923627  // 0xF60CF295
#define WUFFS_DEFLATE__ERROR_INCONSISTENT_STORED_BLOCK_LENGTH \
  -183700843                                                       // 0xF50CF295
#define WUFFS_DEFLATE__ERROR_MISSING_END_OF_BLOCK_CODE -200478059  // 0xF40CF295
#define WUFFS_DEFLATE__ERROR_NO_HUFFMAN_CODES -217255275           // 0xF30CF295
#define WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE \
  -1072893291  // 0xC00CF295
#define WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_END_OF_BLOCK \
  -1089670507  // 0xBF0CF295
#define WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_I_O \
  -1106447723  // 0xBE0CF295
#define WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_DISTANCE \
  -1123224939  // 0xBD0CF295
#define WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS \
  -1140002155  // 0xBC0CF295

const char* wuffs_deflate__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_deflate__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    uint32_t f_bits;
    uint32_t f_n_bits;
    uint32_t f_huffs[2][1234];
    uint32_t f_n_huffs_bits[2];
    uint8_t f_history[32768];
    uint32_t f_history_index;
    uint8_t f_code_lengths[320];
    bool f_end_of_block;

    struct {
      uint32_t coro_susp_point;
      wuffs_base__status v_z;
      uint64_t v_n_copied;
      uint32_t v_already_full;
    } c_decode[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_final;
      uint32_t v_type;
    } c_decode_blocks[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_length;
      uint32_t v_n_copied;
      uint64_t scratch;
    } c_decode_uncompressed[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_i;
    } c_init_fixed_huffman[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_n_lit;
      uint32_t v_n_dist;
      uint32_t v_n_clen;
      uint32_t v_i;
      uint32_t v_mask;
      uint32_t v_table_entry;
      uint32_t v_table_entry_n_bits;
      uint32_t v_n_extra_bits;
      uint8_t v_rep_symbol;
      uint32_t v_rep_count;
    } c_init_dynamic_huffman[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_table_entry;
      uint32_t v_table_entry_n_bits;
      uint32_t v_lmask;
      uint32_t v_dmask;
      uint32_t v_redir_top;
      uint32_t v_redir_mask;
      uint32_t v_length;
      uint32_t v_dist_minus_1;
      uint32_t v_n_copied;
      uint32_t v_hlen;
      uint32_t v_hdist;
    } c_decode_huffman_slow[1];
  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline wuffs_base__status decode(wuffs_base__io_writer a_dst,
                                   wuffs_base__io_reader a_src);
#endif  // __cplusplus

} wuffs_deflate__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_deflate__decoder__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_deflate__decoder__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_deflate__decoder__check_wuffs_version(wuffs_deflate__decoder* self,
                                                 size_t sizeof_star_self,
                                                 uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_deflate__decoder__decode(wuffs_deflate__decoder* self,
                               wuffs_base__io_writer a_dst,
                               wuffs_base__io_reader a_src);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_deflate__decoder::check_wuffs_version(size_t sizeof_star_self,
                                            uint64_t wuffs_version) {
  wuffs_deflate__decoder__check_wuffs_version(this, sizeof_star_self,
                                              wuffs_version);
}

inline wuffs_base__status  //
wuffs_deflate__decoder::decode(wuffs_base__io_writer a_dst,
                               wuffs_base__io_reader a_src) {
  return wuffs_deflate__decoder__decode(this, a_dst, a_src);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

// ---------------- BEGIN USE "std/lzw"

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_lzw__packageid 1316776  // 0x001417A8

#define WUFFS_LZW__ERROR_BAD_CODE -15460440               // 0xFF1417A8
#define WUFFS_LZW__ERROR_CYCLICAL_PREFIX_CHAIN -32237656  // 0xFE1417A8

const char* wuffs_lzw__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_lzw__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    uint32_t f_literal_width;
    uint8_t f_stack[4096];
    uint8_t f_suffixes[4096];
    uint16_t f_prefixes[4096];

    struct {
      uint32_t coro_susp_point;
      uint32_t v_literal_width;
      uint32_t v_clear_code;
      uint32_t v_end_code;
      uint32_t v_save_code;
      uint32_t v_prev_code;
      uint32_t v_width;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_code;
      uint32_t v_s;
      uint32_t v_c;
      uint64_t v_n_copied;
    } c_decode[1];
  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline void set_literal_width(uint32_t a_lw);
  inline wuffs_base__status decode(wuffs_base__io_writer a_dst,
                                   wuffs_base__io_reader a_src);
#endif  // __cplusplus

} wuffs_lzw__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_lzw__decoder__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_lzw__decoder__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_lzw__decoder__check_wuffs_version(wuffs_lzw__decoder* self,
                                             size_t sizeof_star_self,
                                             uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_lzw__decoder__set_literal_width(wuffs_lzw__decoder* self, uint32_t a_lw);

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_lzw__decoder__decode(wuffs_lzw__decoder* self,
                           wuffs_base__io_writer a_dst,
                           wuffs_base__io_reader a_src);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_lzw__decoder::check_wuffs_version(size_t sizeof_star_self,
                                        uint64_t wuffs_version) {
  wuffs_lzw__decoder__check_wuffs_version(this, sizeof_star_self,
                                          wuffs_version);
}

inline void  //
wuffs_lzw__decoder::set_literal_width(uint32_t a_lw) {
  return wuffs_lzw__decoder__set_literal_width(this, a_lw);
}

inline wuffs_base__status  //
wuffs_lzw__decoder::decode(wuffs_base__io_writer a_dst,
                           wuffs_base__io_reader a_src) {
  return wuffs_lzw__decoder__decode(this, a_dst, a_src);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// ---------------- END   USE "std/lzw"

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_gif__packageid 1017222  // 0x000F8586

#define WUFFS_GIF__ERROR_BAD_BLOCK -15759994              // 0xFF0F8586
#define WUFFS_GIF__ERROR_BAD_EXTENSION_LABEL -32537210    // 0xFE0F8586
#define WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL -49314426    // 0xFD0F8586
#define WUFFS_GIF__ERROR_BAD_HEADER -66091642             // 0xFC0F8586
#define WUFFS_GIF__ERROR_BAD_LITERAL_WIDTH -82868858      // 0xFB0F8586
#define WUFFS_GIF__ERROR_NOT_ENOUGH_PIXEL_DATA -99646074  // 0xFA0F8586
#define WUFFS_GIF__ERROR_TOO_MUCH_PIXEL_DATA -116423290   // 0xF90F8586
#define WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI \
  -1072724602  // 0xC00F8586

const char* wuffs_gif__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gif__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    uint32_t f_width;
    uint32_t f_height;
    uint8_t f_call_sequence;
    bool f_end_of_data;
    bool f_previous_lzw_decode_ended_abruptly;
    bool f_previous_use_global_palette;
    bool f_has_full_global_palette;
    bool f_has_full_palette;
    bool f_use_local_palette;
    uint8_t f_which_palette;
    uint8_t f_interlace;
    bool f_seen_num_loops;
    uint32_t f_num_loops;
    bool f_seen_graphic_control;
    bool f_gc_has_transparent_index;
    uint8_t f_gc_transparent_index;
    uint8_t f_gc_disposal;
    uint64_t f_gc_duration;
    uint64_t f_frame_count_value;
    uint32_t f_frame_rect_x0;
    uint32_t f_frame_rect_y0;
    uint32_t f_frame_rect_x1;
    uint32_t f_frame_rect_y1;
    uint32_t f_dst_x;
    uint32_t f_dst_y;
    uint32_t f_uncompressed_ri;
    uint32_t f_uncompressed_wi;
    uint8_t f_uncompressed[4096];
    uint8_t f_palettes[2][1024];
    wuffs_base__utility f_util;
    wuffs_lzw__decoder f_lzw;

    struct {
      uint32_t coro_susp_point;
      uint32_t v_num_loops;
      bool v_ffio;
    } c_decode_image_config[1];
    struct {
      uint32_t coro_susp_point;
    } c_decode_frame_config[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_lw;
    } c_skip_frame[1];
    struct {
      uint32_t coro_susp_point;
    } c_decode_frame[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_block_type;
    } c_decode_up_to_id_part1[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c[6];
      uint32_t v_i;
    } c_decode_header[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_flags;
      uint32_t v_num_palette_entries;
      uint32_t v_i;
      uint32_t v_argb;
      uint64_t scratch;
    } c_decode_lsd[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_label;
    } c_decode_extension[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_block_size;
      uint64_t scratch;
    } c_skip_blocks[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c;
      uint8_t v_block_size;
      bool v_not_animexts;
      bool v_not_netscape;
      uint64_t scratch;
    } c_decode_ae[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c;
      uint8_t v_flags;
      uint64_t scratch;
    } c_decode_gc[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_flags;
      uint32_t v_num_palette_entries;
      uint32_t v_i;
      uint32_t v_argb;
      uint64_t scratch;
    } c_decode_id_part0[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_lw;
      uint64_t v_block_size;
      wuffs_base__status v_z;
    } c_decode_id_part1[1];
  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline wuffs_base__status decode_image_config(wuffs_base__image_config* a_dst,
                                                wuffs_base__io_reader a_src);
  inline uint64_t frame_count();
  inline wuffs_base__range_ii_u64 work_buffer_size();
  inline wuffs_base__status decode_frame_config(wuffs_base__frame_config* a_dst,
                                                wuffs_base__io_reader a_src);
  inline wuffs_base__status decode_frame(wuffs_base__pixel_buffer* a_dst,
                                         wuffs_base__io_reader a_src,
                                         wuffs_base__slice_u8 a_work_buffer,
                                         uint32_t a_pixbuf_origin_x,
                                         uint32_t a_pixbuf_origin_y);
#endif  // __cplusplus

} wuffs_gif__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_gif__decoder__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_gif__decoder__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_gif__decoder__check_wuffs_version(wuffs_gif__decoder* self,
                                             size_t sizeof_star_self,
                                             uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_image_config(wuffs_gif__decoder* self,
                                        wuffs_base__image_config* a_dst,
                                        wuffs_base__io_reader a_src);

WUFFS_BASE__MAYBE_STATIC uint64_t  //
wuffs_gif__decoder__frame_count(wuffs_gif__decoder* self);

WUFFS_BASE__MAYBE_STATIC wuffs_base__range_ii_u64  //
wuffs_gif__decoder__work_buffer_size(wuffs_gif__decoder* self);

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_frame_config(wuffs_gif__decoder* self,
                                        wuffs_base__frame_config* a_dst,
                                        wuffs_base__io_reader a_src);

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_frame(wuffs_gif__decoder* self,
                                 wuffs_base__pixel_buffer* a_dst,
                                 wuffs_base__io_reader a_src,
                                 wuffs_base__slice_u8 a_work_buffer,
                                 uint32_t a_pixbuf_origin_x,
                                 uint32_t a_pixbuf_origin_y);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_gif__decoder::check_wuffs_version(size_t sizeof_star_self,
                                        uint64_t wuffs_version) {
  wuffs_gif__decoder__check_wuffs_version(this, sizeof_star_self,
                                          wuffs_version);
}

inline wuffs_base__status  //
wuffs_gif__decoder::decode_image_config(wuffs_base__image_config* a_dst,
                                        wuffs_base__io_reader a_src) {
  return wuffs_gif__decoder__decode_image_config(this, a_dst, a_src);
}

inline uint64_t  //
wuffs_gif__decoder::frame_count() {
  return wuffs_gif__decoder__frame_count(this);
}

inline wuffs_base__range_ii_u64  //
wuffs_gif__decoder::work_buffer_size() {
  return wuffs_gif__decoder__work_buffer_size(this);
}

inline wuffs_base__status  //
wuffs_gif__decoder::decode_frame_config(wuffs_base__frame_config* a_dst,
                                        wuffs_base__io_reader a_src) {
  return wuffs_gif__decoder__decode_frame_config(this, a_dst, a_src);
}

inline wuffs_base__status  //
wuffs_gif__decoder::decode_frame(wuffs_base__pixel_buffer* a_dst,
                                 wuffs_base__io_reader a_src,
                                 wuffs_base__slice_u8 a_work_buffer,
                                 uint32_t a_pixbuf_origin_x,
                                 uint32_t a_pixbuf_origin_y) {
  return wuffs_gif__decoder__decode_frame(this, a_dst, a_src, a_work_buffer,
                                          a_pixbuf_origin_x, a_pixbuf_origin_y);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

// ---------------- BEGIN USE "std/crc32"

// ---------------- END   USE "std/crc32"

// ---------------- BEGIN USE "std/deflate"

// ---------------- END   USE "std/deflate"

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_gzip__packageid 1041911  // 0x000FE5F7

#define WUFFS_GZIP__ERROR_BAD_CHECKSUM -15735305            // 0xFF0FE5F7
#define WUFFS_GZIP__ERROR_BAD_COMPRESSION_METHOD -32512521  // 0xFE0FE5F7
#define WUFFS_GZIP__ERROR_BAD_ENCODING_FLAGS -49289737      // 0xFD0FE5F7
#define WUFFS_GZIP__ERROR_BAD_HEADER -66066953              // 0xFC0FE5F7

const char* wuffs_gzip__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gzip__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    wuffs_deflate__decoder f_flate;
    wuffs_crc32__ieee_hasher f_checksum;
    bool f_ignore_checksum;

    struct {
      uint32_t coro_susp_point;
      uint8_t v_c;
      uint8_t v_flags;
      uint16_t v_xlen;
      uint32_t v_checksum_got;
      uint32_t v_decoded_length_got;
      wuffs_base__status v_z;
      uint32_t v_checksum_want;
      uint32_t v_decoded_length_want;
      uint64_t scratch;
    } c_decode[1];
  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline void set_ignore_checksum(bool a_ic);
  inline wuffs_base__status decode(wuffs_base__io_writer a_dst,
                                   wuffs_base__io_reader a_src);
#endif  // __cplusplus

} wuffs_gzip__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_gzip__decoder__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_gzip__decoder__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_gzip__decoder__check_wuffs_version(wuffs_gzip__decoder* self,
                                              size_t sizeof_star_self,
                                              uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_gzip__decoder__set_ignore_checksum(wuffs_gzip__decoder* self, bool a_ic);

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gzip__decoder__decode(wuffs_gzip__decoder* self,
                            wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_gzip__decoder::check_wuffs_version(size_t sizeof_star_self,
                                         uint64_t wuffs_version) {
  wuffs_gzip__decoder__check_wuffs_version(this, sizeof_star_self,
                                           wuffs_version);
}

inline void  //
wuffs_gzip__decoder::set_ignore_checksum(bool a_ic) {
  return wuffs_gzip__decoder__set_ignore_checksum(this, a_ic);
}

inline wuffs_base__status  //
wuffs_gzip__decoder::decode(wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src) {
  return wuffs_gzip__decoder__decode(this, a_dst, a_src);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

// Code generated by wuffs-c. DO NOT EDIT.

// ---------------- Use Declarations

// ---------------- BEGIN USE "std/adler32"

// ---------------- END   USE "std/adler32"

// ---------------- BEGIN USE "std/deflate"

// ---------------- END   USE "std/deflate"

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

#define wuffs_zlib__packageid 2064249  // 0x001F7F79

#define WUFFS_ZLIB__ERROR_BAD_CHECKSUM -14712967                 // 0xFF1F7F79
#define WUFFS_ZLIB__ERROR_BAD_COMPRESSION_METHOD -31490183       // 0xFE1F7F79
#define WUFFS_ZLIB__ERROR_BAD_COMPRESSION_WINDOW_SIZE -48267399  // 0xFD1F7F79
#define WUFFS_ZLIB__ERROR_BAD_PARITY_CHECK -65044615             // 0xFC1F7F79
#define WUFFS_ZLIB__ERROR_TODO_UNSUPPORTED_PRESET_DICTIONARY \
  -1071677575  // 0xC01F7F79

const char* wuffs_zlib__status__string(wuffs_base__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_zlib__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_base__status status;
    uint32_t magic;

    wuffs_deflate__decoder f_flate;
    wuffs_adler32__hasher f_checksum;
    bool f_ignore_checksum;

    struct {
      uint32_t coro_susp_point;
      uint16_t v_x;
      uint32_t v_checksum_got;
      wuffs_base__status v_z;
      uint32_t v_checksum_want;
      uint64_t scratch;
    } c_decode[1];
  } private_impl;

#ifdef __cplusplus
  inline void check_wuffs_version(size_t sizeof_star_self,
                                  uint64_t wuffs_version);
  inline void set_ignore_checksum(bool a_ic);
  inline wuffs_base__status decode(wuffs_base__io_writer a_dst,
                                   wuffs_base__io_reader a_src);
#endif  // __cplusplus

} wuffs_zlib__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_zlib__decoder__check_wuffs_version is an initializer function.
//
// It should be called before any other wuffs_zlib__decoder__* function.
//
// Pass sizeof(*self) and WUFFS_VERSION for sizeof_star_self and wuffs_version.
void wuffs_zlib__decoder__check_wuffs_version(wuffs_zlib__decoder* self,
                                              size_t sizeof_star_self,
                                              uint64_t wuffs_version);

// ---------------- Public Function Prototypes

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_zlib__decoder__set_ignore_checksum(wuffs_zlib__decoder* self, bool a_ic);

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_zlib__decoder__decode(wuffs_zlib__decoder* self,
                            wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src);

// ---------------- C++ Convenience Methods

#ifdef __cplusplus

inline void  //
wuffs_zlib__decoder::check_wuffs_version(size_t sizeof_star_self,
                                         uint64_t wuffs_version) {
  wuffs_zlib__decoder__check_wuffs_version(this, sizeof_star_self,
                                           wuffs_version);
}

inline void  //
wuffs_zlib__decoder::set_ignore_checksum(bool a_ic) {
  return wuffs_zlib__decoder__set_ignore_checksum(this, a_ic);
}

inline wuffs_base__status  //
wuffs_zlib__decoder::decode(wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src) {
  return wuffs_zlib__decoder__decode(this, a_dst, a_src);
}

#endif  // __cplusplus

#ifdef __cplusplus
}  // extern "C"
#endif

#ifdef WUFFS_IMPLEMENTATION

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifdef __cplusplus
extern "C" {
#endif

#define WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(x) (void)(x)

// WUFFS_BASE__MAGIC is a magic number to check that initializers are called.
// It's not foolproof, given C doesn't automatically zero memory before use,
// but it should catch 99.99% of cases.
//
// Its (non-zero) value is arbitrary, based on md5sum("wuffs").
#define WUFFS_BASE__MAGIC ((uint32_t)0x3CCB6C71)

// Denote intentional fallthroughs for -Wimplicit-fallthrough.
//
// The order matters here. Clang also defines "__GNUC__".
#if defined(__clang__) && __cplusplus >= 201103L
#define WUFFS_BASE__FALLTHROUGH [[clang::fallthrough]]
#elif !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 7)
#define WUFFS_BASE__FALLTHROUGH __attribute__((fallthrough))
#else
#define WUFFS_BASE__FALLTHROUGH
#endif

// Use switch cases for coroutine suspension points, similar to the technique
// in https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
//
// We use trivial macros instead of an explicit assignment and case statement
// so that clang-format doesn't get confused by the unusual "case"s.
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0 case 0:;
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT(n) \
  coro_susp_point = n;                            \
  WUFFS_BASE__FALLTHROUGH;                        \
  case n:;

#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(n) \
  if (status < 0) {                                             \
    goto exit;                                                  \
  } else if (status == 0) {                                     \
    goto ok;                                                    \
  }                                                             \
  coro_susp_point = n;                                          \
  goto suspend;                                                 \
  case n:;

// Clang also defines "__GNUC__".
#if defined(__GNUC__)
#define WUFFS_BASE__LIKELY(expr) (__builtin_expect(!!(expr), 1))
#define WUFFS_BASE__UNLIKELY(expr) (__builtin_expect(!!(expr), 0))
#else
#define WUFFS_BASE__LIKELY(expr) (expr)
#define WUFFS_BASE__UNLIKELY(expr) (expr)
#endif

// The helpers below are functions, instead of macros, because their arguments
// can be an expression that we shouldn't evaluate more than once.
//
// They are static, so that linking multiple wuffs .o files won't complain about
// duplicate function definitions.
//
// They are explicitly marked inline, even if modern compilers don't use the
// inline attribute to guide optimizations such as inlining, to avoid the
// -Wunused-function warning, and we like to compile with -Wall -Werror.

static inline wuffs_base__empty_struct  //
wuffs_base__return_empty_struct() {
  return ((wuffs_base__empty_struct){});
}

// ---------------- Numeric Types

static inline uint8_t  //
wuffs_base__load_u8be(uint8_t* p) {
  return p[0];
}

static inline uint16_t  //
wuffs_base__load_u16be(uint8_t* p) {
  return ((uint16_t)(p[0]) << 8) | ((uint16_t)(p[1]) << 0);
}

static inline uint16_t  //
wuffs_base__load_u16le(uint8_t* p) {
  return ((uint16_t)(p[0]) << 0) | ((uint16_t)(p[1]) << 8);
}

static inline uint32_t  //
wuffs_base__load_u24be(uint8_t* p) {
  return ((uint32_t)(p[0]) << 16) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 0);
}

static inline uint32_t  //
wuffs_base__load_u24le(uint8_t* p) {
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16);
}

static inline uint32_t  //
wuffs_base__load_u32be(uint8_t* p) {
  return ((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |
         ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0);
}

static inline uint32_t  //
wuffs_base__load_u32le(uint8_t* p) {
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

static inline uint64_t  //
wuffs_base__load_u40be(uint8_t* p) {
  return ((uint64_t)(p[0]) << 32) | ((uint64_t)(p[1]) << 24) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 8) |
         ((uint64_t)(p[4]) << 0);
}

static inline uint64_t  //
wuffs_base__load_u40le(uint8_t* p) {
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 32);
}

static inline uint64_t  //
wuffs_base__load_u48be(uint8_t* p) {
  return ((uint64_t)(p[0]) << 40) | ((uint64_t)(p[1]) << 32) |
         ((uint64_t)(p[2]) << 24) | ((uint64_t)(p[3]) << 16) |
         ((uint64_t)(p[4]) << 8) | ((uint64_t)(p[5]) << 0);
}

static inline uint64_t  //
wuffs_base__load_u48le(uint8_t* p) {
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40);
}

static inline uint64_t  //
wuffs_base__load_u56be(uint8_t* p) {
  return ((uint64_t)(p[0]) << 48) | ((uint64_t)(p[1]) << 40) |
         ((uint64_t)(p[2]) << 32) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 16) | ((uint64_t)(p[5]) << 8) |
         ((uint64_t)(p[6]) << 0);
}

static inline uint64_t  //
wuffs_base__load_u56le(uint8_t* p) {
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40) |
         ((uint64_t)(p[6]) << 48);
}

static inline uint64_t  //
wuffs_base__load_u64be(uint8_t* p) {
  return ((uint64_t)(p[0]) << 56) | ((uint64_t)(p[1]) << 48) |
         ((uint64_t)(p[2]) << 40) | ((uint64_t)(p[3]) << 32) |
         ((uint64_t)(p[4]) << 24) | ((uint64_t)(p[5]) << 16) |
         ((uint64_t)(p[6]) << 8) | ((uint64_t)(p[7]) << 0);
}

static inline uint64_t  //
wuffs_base__load_u64le(uint8_t* p) {
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40) |
         ((uint64_t)(p[6]) << 48) | ((uint64_t)(p[7]) << 56);
}

// --------

static inline void  //
wuffs_base__store_u8be(uint8_t* p, uint8_t x) {
  p[0] = x;
}

static inline void  //
wuffs_base__store_u16be(uint8_t* p, uint16_t x) {
  p[0] = x >> 8;
  p[1] = x >> 0;
}

static inline void  //
wuffs_base__store_u16le(uint8_t* p, uint16_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
}

static inline void  //
wuffs_base__store_u24be(uint8_t* p, uint32_t x) {
  p[0] = x >> 16;
  p[1] = x >> 8;
  p[2] = x >> 0;
}

static inline void  //
wuffs_base__store_u24le(uint8_t* p, uint32_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
}

static inline void  //
wuffs_base__store_u32be(uint8_t* p, uint32_t x) {
  p[0] = x >> 24;
  p[1] = x >> 16;
  p[2] = x >> 8;
  p[3] = x >> 0;
}

static inline void  //
wuffs_base__store_u32le(uint8_t* p, uint32_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
  p[3] = x >> 24;
}

static inline void  //
wuffs_base__store_u40be(uint8_t* p, uint64_t x) {
  p[0] = x >> 32;
  p[1] = x >> 24;
  p[2] = x >> 16;
  p[3] = x >> 8;
  p[4] = x >> 0;
}

static inline void  //
wuffs_base__store_u40le(uint8_t* p, uint64_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
  p[3] = x >> 24;
  p[4] = x >> 32;
}

static inline void  //
wuffs_base__store_u48be(uint8_t* p, uint64_t x) {
  p[0] = x >> 40;
  p[1] = x >> 32;
  p[2] = x >> 24;
  p[3] = x >> 16;
  p[4] = x >> 8;
  p[5] = x >> 0;
}

static inline void  //
wuffs_base__store_u48le(uint8_t* p, uint64_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
  p[3] = x >> 24;
  p[4] = x >> 32;
  p[5] = x >> 40;
}

static inline void  //
wuffs_base__store_u56be(uint8_t* p, uint64_t x) {
  p[0] = x >> 48;
  p[1] = x >> 40;
  p[2] = x >> 32;
  p[3] = x >> 24;
  p[4] = x >> 16;
  p[5] = x >> 8;
  p[6] = x >> 0;
}

static inline void  //
wuffs_base__store_u56le(uint8_t* p, uint64_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
  p[3] = x >> 24;
  p[4] = x >> 32;
  p[5] = x >> 40;
  p[6] = x >> 48;
}

static inline void  //
wuffs_base__store_u64be(uint8_t* p, uint64_t x) {
  p[0] = x >> 56;
  p[1] = x >> 48;
  p[2] = x >> 40;
  p[3] = x >> 32;
  p[4] = x >> 24;
  p[5] = x >> 16;
  p[6] = x >> 8;
  p[7] = x >> 0;
}

static inline void  //
wuffs_base__store_u64le(uint8_t* p, uint64_t x) {
  p[0] = x >> 0;
  p[1] = x >> 8;
  p[2] = x >> 16;
  p[3] = x >> 24;
  p[4] = x >> 32;
  p[5] = x >> 40;
  p[6] = x >> 48;
  p[7] = x >> 56;
}

// --------

static inline void  //
wuffs_base__u8__sat_add_indirect(uint8_t* x, uint8_t y) {
  *x = wuffs_base__u8__sat_add(*x, y);
}

static inline void  //
wuffs_base__u8__sat_sub_indirect(uint8_t* x, uint8_t y) {
  *x = wuffs_base__u8__sat_sub(*x, y);
}

static inline void  //
wuffs_base__u16__sat_add_indirect(uint16_t* x, uint16_t y) {
  *x = wuffs_base__u16__sat_add(*x, y);
}

static inline void  //
wuffs_base__u16__sat_sub_indirect(uint16_t* x, uint16_t y) {
  *x = wuffs_base__u16__sat_sub(*x, y);
}

static inline void  //
wuffs_base__u32__sat_add_indirect(uint32_t* x, uint32_t y) {
  *x = wuffs_base__u32__sat_add(*x, y);
}

static inline void  //
wuffs_base__u32__sat_sub_indirect(uint32_t* x, uint32_t y) {
  *x = wuffs_base__u32__sat_sub(*x, y);
}

static inline void  //
wuffs_base__u64__sat_add_indirect(uint64_t* x, uint64_t y) {
  *x = wuffs_base__u64__sat_add(*x, y);
}

static inline void  //
wuffs_base__u64__sat_sub_indirect(uint64_t* x, uint64_t y) {
  *x = wuffs_base__u64__sat_sub(*x, y);
}

// ---------------- Slices and Tables

static inline wuffs_base__slice_u8  //
wuffs_base__slice_u8__subslice_i(wuffs_base__slice_u8 s, uint64_t i) {
  if ((i <= SIZE_MAX) && (i <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = s.len - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8  //
wuffs_base__slice_u8__subslice_j(wuffs_base__slice_u8 s, uint64_t j) {
  if ((j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){.ptr = s.ptr, .len = j});
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8  //
wuffs_base__slice_u8__subslice_ij(wuffs_base__slice_u8 s,
                                  uint64_t i,
                                  uint64_t j) {
  if ((i <= j) && (j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = j - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

// wuffs_base__slice_u8__prefix returns up to the first up_to bytes of s.
static inline wuffs_base__slice_u8  //
wuffs_base__slice_u8__prefix(wuffs_base__slice_u8 s, uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__suffix returns up to the last up_to bytes of s.
static inline wuffs_base__slice_u8  //
wuffs_base__slice_u8__suffix(wuffs_base__slice_u8 s, uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.ptr += (uint64_t)(s.len) - up_to;
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__copy_from_slice calls memmove(dst.ptr, src.ptr,
// length) where length is the minimum of dst.len and src.len.
//
// Passing a wuffs_base__slice_u8 with all fields NULL or zero (a valid, empty
// slice) is valid and results in a no-op.
static inline uint64_t  //
wuffs_base__slice_u8__copy_from_slice(wuffs_base__slice_u8 dst,
                                      wuffs_base__slice_u8 src) {
  size_t length = dst.len < src.len ? dst.len : src.len;
  if (length > 0) {
    memmove(dst.ptr, src.ptr, length);
  }
  return length;
}

// --------

static inline wuffs_base__slice_u8  //
wuffs_base__table_u8__row(wuffs_base__table_u8 t, uint32_t y) {
  if (y < t.height) {
    return ((wuffs_base__slice_u8){
        .ptr = t.ptr + (t.stride * y),
        .len = t.width,
    });
  }
  return ((wuffs_base__slice_u8){});
}

// ---------------- Utility

static inline wuffs_base__range_ii_u32  //
wuffs_base__utility__make_range_ii_u32(wuffs_base__utility* ignored,
                                       uint32_t min_incl,
                                       uint32_t max_incl) {
  return ((wuffs_base__range_ii_u32){
      .min_incl = min_incl,
      .max_incl = max_incl,
  });
}

static inline wuffs_base__range_ie_u32  //
wuffs_base__utility__make_range_ie_u32(wuffs_base__utility* ignored,
                                       uint32_t min_incl,
                                       uint32_t max_excl) {
  return ((wuffs_base__range_ie_u32){
      .min_incl = min_incl,
      .max_excl = max_excl,
  });
}

static inline wuffs_base__range_ii_u64  //
wuffs_base__utility__make_range_ii_u64(wuffs_base__utility* ignored,
                                       uint64_t min_incl,
                                       uint64_t max_incl) {
  return ((wuffs_base__range_ii_u64){
      .min_incl = min_incl,
      .max_incl = max_incl,
  });
}

static inline wuffs_base__range_ie_u64  //
wuffs_base__utility__make_range_ie_u64(wuffs_base__utility* ignored,
                                       uint64_t min_incl,
                                       uint64_t max_excl) {
  return ((wuffs_base__range_ie_u64){
      .min_incl = min_incl,
      .max_excl = max_excl,
  });
}

static inline wuffs_base__rect_ii_u32  //
wuffs_base__utility__make_rect_ii_u32(wuffs_base__utility* ignored,
                                      uint32_t min_incl_x,
                                      uint32_t min_incl_y,
                                      uint32_t max_incl_x,
                                      uint32_t max_incl_y) {
  return ((wuffs_base__rect_ii_u32){
      .min_incl_x = min_incl_x,
      .min_incl_y = min_incl_y,
      .max_incl_x = max_incl_x,
      .max_incl_y = max_incl_y,
  });
}

static inline wuffs_base__rect_ie_u32  //
wuffs_base__utility__make_rect_ie_u32(wuffs_base__utility* ignored,
                                      uint32_t min_incl_x,
                                      uint32_t min_incl_y,
                                      uint32_t max_excl_x,
                                      uint32_t max_excl_y) {
  return ((wuffs_base__rect_ie_u32){
      .min_incl_x = min_incl_x,
      .min_incl_y = min_incl_y,
      .max_excl_x = max_excl_x,
      .max_excl_y = max_excl_y,
  });
}

// ---------------- I/O

static inline bool  //
wuffs_base__io_buffer__is_valid(wuffs_base__io_buffer buf) {
  return (buf.ptr || (buf.len == 0)) && (buf.len >= buf.wi) &&
         (buf.wi >= buf.ri);
}

static inline bool  //
wuffs_base__io_reader__is_eof(wuffs_base__io_reader o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  return buf && buf->closed && (buf->ptr + buf->wi == o.private_impl.bounds[1]);
}

static inline bool  //
wuffs_base__io_reader__is_valid(wuffs_base__io_reader o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  // Note: if making this function public (i.e. moving it to base-header.h), it
  // also needs to allow NULL (i.e. implicit, callee-calculated) bounds.
  return buf ? ((buf->ptr <= o.private_impl.bounds[0]) &&
                (o.private_impl.bounds[0] <= o.private_impl.bounds[1]) &&
                (o.private_impl.bounds[1] <= buf->ptr + buf->len))
             : ((o.private_impl.bounds[0] == NULL) &&
                (o.private_impl.bounds[1] == NULL));
}

static inline bool  //
wuffs_base__io_writer__is_valid(wuffs_base__io_writer o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  // Note: if making this function public (i.e. moving it to base-header.h), it
  // also needs to allow NULL (i.e. implicit, callee-calculated) bounds.
  return buf ? ((buf->ptr <= o.private_impl.bounds[0]) &&
                (o.private_impl.bounds[0] <= o.private_impl.bounds[1]) &&
                (o.private_impl.bounds[1] <= buf->ptr + buf->len))
             : ((o.private_impl.bounds[0] == NULL) &&
                (o.private_impl.bounds[1] == NULL));
}

static inline uint32_t  //
wuffs_base__io_writer__copy_n_from_history(uint8_t** ptr_ptr,
                                           uint8_t* start,
                                           uint8_t* end,
                                           uint32_t length,
                                           uint32_t distance) {
  if (!distance) {
    return 0;
  }
  uint8_t* ptr = *ptr_ptr;
  if ((size_t)(ptr - start) < (size_t)(distance)) {
    return 0;
  }
  start = ptr - distance;
  size_t n = end - ptr;
  if ((size_t)(length) > n) {
    length = n;
  } else {
    n = length;
  }
  // TODO: unrolling by 3 seems best for the std/deflate benchmarks, but that
  // is mostly because 3 is the minimum length for the deflate format. This
  // function implementation shouldn't overfit to that one format. Perhaps the
  // copy_n_from_history Wuffs method should also take an unroll hint argument,
  // and the cgen can look if that argument is the constant expression '3'.
  //
  // See also wuffs_base__io_writer__copy_n_from_history_fast below.
  //
  // Alternatively, or additionally, have a sloppy_copy_n_from_history method
  // that copies 8 bytes at a time, possibly writing more than length bytes?
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

// wuffs_base__io_writer__copy_n_from_history_fast is like the
// wuffs_base__io_writer__copy_n_from_history function above, but has stronger
// pre-conditions. The caller needs to prove that:
//  - distance >  0
//  - distance <= (*ptr_ptr - start)
//  - length   <= (end      - *ptr_ptr)
static inline uint32_t  //
wuffs_base__io_writer__copy_n_from_history_fast(uint8_t** ptr_ptr,
                                                uint8_t* start,
                                                uint8_t* end,
                                                uint32_t length,
                                                uint32_t distance) {
  uint8_t* ptr = *ptr_ptr;
  start = ptr - distance;
  uint32_t n = length;
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

static inline uint32_t  //
wuffs_base__io_writer__copy_n_from_reader(uint8_t** ptr_ioptr_w,
                                          uint8_t* iobounds1_w,
                                          uint32_t length,
                                          uint8_t** ptr_ioptr_r,
                                          uint8_t* iobounds1_r) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = length;
  if (n > ((size_t)(iobounds1_w - ioptr_w))) {
    n = iobounds1_w - ioptr_w;
  }
  uint8_t* ioptr_r = *ptr_ioptr_r;
  if (n > ((size_t)(iobounds1_r - ioptr_r))) {
    n = iobounds1_r - ioptr_r;
  }
  if (n > 0) {
    memmove(ioptr_w, ioptr_r, n);
    *ptr_ioptr_w += n;
    *ptr_ioptr_r += n;
  }
  return n;
}

static inline uint64_t  //
wuffs_base__io_writer__copy_from_slice(uint8_t** ptr_ioptr_w,
                                       uint8_t* iobounds1_w,
                                       wuffs_base__slice_u8 src) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = src.len;
  if (n > ((size_t)(iobounds1_w - ioptr_w))) {
    n = iobounds1_w - ioptr_w;
  }
  if (n > 0) {
    memmove(ioptr_w, src.ptr, n);
    *ptr_ioptr_w += n;
  }
  return n;
}

static inline uint32_t  //
wuffs_base__io_writer__copy_n_from_slice(uint8_t** ptr_ioptr_w,
                                         uint8_t* iobounds1_w,
                                         uint32_t length,
                                         wuffs_base__slice_u8 src) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = src.len;
  if (n > length) {
    n = length;
  }
  if (n > ((size_t)(iobounds1_w - ioptr_w))) {
    n = iobounds1_w - ioptr_w;
  }
  if (n > 0) {
    memmove(ioptr_w, src.ptr, n);
    *ptr_ioptr_w += n;
  }
  return n;
}

static inline wuffs_base__empty_struct  //
wuffs_base__io_reader__set_limit(wuffs_base__io_reader* o,
                                 uint8_t* ioptr_r,
                                 uint64_t limit) {
  if (o && (((size_t)(o->private_impl.bounds[1] - ioptr_r)) > limit)) {
    o->private_impl.bounds[1] = ioptr_r + limit;
  }
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct  //
wuffs_base__io_reader__set_mark(wuffs_base__io_reader* o, uint8_t* mark) {
  o->private_impl.bounds[0] = mark;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct  //
wuffs_base__io_writer__set(wuffs_base__io_writer* o,
                           wuffs_base__io_buffer* b,
                           uint8_t** ioptr1_ptr,
                           uint8_t** ioptr2_ptr,
                           wuffs_base__slice_u8 s) {
  b->ptr = s.ptr;
  b->len = s.len;
  b->wi = 0;
  b->ri = 0;
  b->closed = false;
  o->private_impl.buf = b;
  o->private_impl.bounds[0] = s.ptr;
  o->private_impl.bounds[1] = s.ptr + s.len;
  *ioptr1_ptr = s.ptr;
  *ioptr2_ptr = s.ptr + s.len;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct  //
wuffs_base__io_writer__set_mark(wuffs_base__io_writer* o, uint8_t* mark) {
  o->private_impl.bounds[0] = mark;
  return ((wuffs_base__empty_struct){});
}

#ifdef __cplusplus
}  // extern "C"
#endif

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__BASE)

static const char wuffs_base__status__string_data[] = {
    0x00, 0x6F, 0x6B, 0x00, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64,
    0x61, 0x74, 0x61, 0x00, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x20, 0x72, 0x65,
    0x61, 0x64, 0x00, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x20, 0x77, 0x72, 0x69,
    0x74, 0x65, 0x00, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F,
    0x72, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x00, 0x75, 0x6E, 0x65,
    0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x45, 0x4F, 0x46, 0x00,
    0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
    0x6E, 0x20, 0x61, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x73, 0x69,
    0x6F, 0x6E, 0x00, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x63,
    0x61, 0x6C, 0x6C, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65,
    0x00, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x5F, 0x77, 0x75, 0x66, 0x66, 0x73,
    0x5F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6C,
    0x6C, 0x65, 0x64, 0x20, 0x74, 0x77, 0x69, 0x63, 0x65, 0x00, 0x63, 0x68,
    0x65, 0x63, 0x6B, 0x5F, 0x77, 0x75, 0x66, 0x66, 0x73, 0x5F, 0x76, 0x65,
    0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x61,
    0x6C, 0x6C, 0x65, 0x64, 0x00, 0x62, 0x61, 0x64, 0x20, 0x61, 0x72, 0x67,
    0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74,
    0x68, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x29,
    0x00, 0x62, 0x61, 0x64, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x72, 0x00, 0x62, 0x61, 0x64, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66,
    0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x72, 0x00, 0x62, 0x61,
    0x64, 0x20, 0x77, 0x75, 0x66, 0x66, 0x73, 0x20, 0x76, 0x65, 0x72, 0x73,
    0x69, 0x6F, 0x6E, 0x00,
};

static const uint16_t wuffs_base__status__string_offsets[] = {
    0x0001, 0x0004, 0x0010, 0x001B, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0027, 0x0039, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0048,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0063, 0x0079, 0x009A, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x00B9, 0x00D9, 0x00E6, 0x00FA,
};

const char*  //
wuffs_base__status__string(wuffs_base__status s) {
  uint16_t o = wuffs_base__status__string_offsets[(uint8_t)(s >> 24)];
  return o ? wuffs_base__status__string_data + o : "unknown status";
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__BASE)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__ADLER32)

// ---------------- Status Codes Implementations

static const char wuffs_adler32__status__string_data[] = {
    0x00,
};

static const uint16_t wuffs_adler32__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
};

const char* wuffs_adler32__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_adler32__packageid:
      o = wuffs_adler32__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_adler32__status__string_data + o;
      }
      break;
  }
  return "unknown status";
}

// ---------------- Private Consts

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

// ---------------- Initializer Implementations

void wuffs_adler32__hasher__check_wuffs_version(wuffs_adler32__hasher* self,
                                                size_t sizeof_star_self,
                                                uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
}

// ---------------- Function Implementations

// -------- func adler32.hasher.update

WUFFS_BASE__MAYBE_STATIC uint32_t  //
wuffs_adler32__hasher__update(wuffs_adler32__hasher* self,
                              wuffs_base__slice_u8 a_x) {
  if (!self) {
    return 0;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return 0;
  }

  uint32_t v_s1;
  uint32_t v_s2;
  wuffs_base__slice_u8 v_remaining;

  if (!self->private_impl.f_started) {
    self->private_impl.f_started = true;
    self->private_impl.f_state = 1;
  }
  v_s1 = ((self->private_impl.f_state) & ((1 << (16)) - 1));
  v_s2 = ((self->private_impl.f_state) >> (32 - (16)));
  while (((uint64_t)(a_x.len)) > 0) {
    v_remaining = ((wuffs_base__slice_u8){});
    if (((uint64_t)(a_x.len)) > 5552) {
      v_remaining = wuffs_base__slice_u8__subslice_i(a_x, 5552);
      a_x = wuffs_base__slice_u8__subslice_j(a_x, 5552);
    }
    {
      wuffs_base__slice_u8 i_slice_p = a_x;
      wuffs_base__slice_u8 v_p = i_slice_p;
      v_p.len = 1;
      uint8_t* i_end0_p = i_slice_p.ptr + (i_slice_p.len / 8) * 8;
      while (v_p.ptr < i_end0_p) {
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
      }
      v_p.len = 1;
      uint8_t* i_end1_p = i_slice_p.ptr + (i_slice_p.len / 1) * 1;
      while (v_p.ptr < i_end1_p) {
        v_s1 += ((uint32_t)(v_p.ptr[0]));
        v_s2 += v_s1;
        v_p.ptr += 1;
      }
    }
    v_s1 %= 65521;
    v_s2 %= 65521;
    a_x = v_remaining;
  }
  self->private_impl.f_state = (((v_s2 & 65535) << 16) | (v_s1 & 65535));
  return self->private_impl.f_state;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__ADLER32)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__CRC32)

// ---------------- Status Codes Implementations

static const char wuffs_crc32__status__string_data[] = {
    0x00,
};

static const uint16_t wuffs_crc32__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000,
};

const char* wuffs_crc32__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_crc32__packageid:
      o = wuffs_crc32__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_crc32__status__string_data + o;
      }
      break;
  }
  return "unknown status";
}

// ---------------- Private Consts

static const uint32_t wuffs_crc32__ieee_table[8][256] = {
    {
        0,          1996959894, 3993919788, 2567524794, 124634137,  1886057615,
        3915621685, 2657392035, 249268274,  2044508324, 3772115230, 2547177864,
        162941995,  2125561021, 3887607047, 2428444049, 498536548,  1789927666,
        4089016648, 2227061214, 450548861,  1843258603, 4107580753, 2211677639,
        325883990,  1684777152, 4251122042, 2321926636, 335633487,  1661365465,
        4195302755, 2366115317, 997073096,  1281953886, 3579855332, 2724688242,
        1006888145, 1258607687, 3524101629, 2768942443, 901097722,  1119000684,
        3686517206, 2898065728, 853044451,  1172266101, 3705015759, 2882616665,
        651767980,  1373503546, 3369554304, 3218104598, 565507253,  1454621731,
        3485111705, 3099436303, 671266974,  1594198024, 3322730930, 2970347812,
        795835527,  1483230225, 3244367275, 3060149565, 1994146192, 31158534,
        2563907772, 4023717930, 1907459465, 112637215,  2680153253, 3904427059,
        2013776290, 251722036,  2517215374, 3775830040, 2137656763, 141376813,
        2439277719, 3865271297, 1802195444, 476864866,  2238001368, 4066508878,
        1812370925, 453092731,  2181625025, 4111451223, 1706088902, 314042704,
        2344532202, 4240017532, 1658658271, 366619977,  2362670323, 4224994405,
        1303535960, 984961486,  2747007092, 3569037538, 1256170817, 1037604311,
        2765210733, 3554079995, 1131014506, 879679996,  2909243462, 3663771856,
        1141124467, 855842277,  2852801631, 3708648649, 1342533948, 654459306,
        3188396048, 3373015174, 1466479909, 544179635,  3110523913, 3462522015,
        1591671054, 702138776,  2966460450, 3352799412, 1504918807, 783551873,
        3082640443, 3233442989, 3988292384, 2596254646, 62317068,   1957810842,
        3939845945, 2647816111, 81470997,   1943803523, 3814918930, 2489596804,
        225274430,  2053790376, 3826175755, 2466906013, 167816743,  2097651377,
        4027552580, 2265490386, 503444072,  1762050814, 4150417245, 2154129355,
        426522225,  1852507879, 4275313526, 2312317920, 282753626,  1742555852,
        4189708143, 2394877945, 397917763,  1622183637, 3604390888, 2714866558,
        953729732,  1340076626, 3518719985, 2797360999, 1068828381, 1219638859,
        3624741850, 2936675148, 906185462,  1090812512, 3747672003, 2825379669,
        829329135,  1181335161, 3412177804, 3160834842, 628085408,  1382605366,
        3423369109, 3138078467, 570562233,  1426400815, 3317316542, 2998733608,
        733239954,  1555261956, 3268935591, 3050360625, 752459403,  1541320221,
        2607071920, 3965973030, 1969922972, 40735498,   2617837225, 3943577151,
        1913087877, 83908371,   2512341634, 3803740692, 2075208622, 213261112,
        2463272603, 3855990285, 2094854071, 198958881,  2262029012, 4057260610,
        1759359992, 534414190,  2176718541, 4139329115, 1873836001, 414664567,
        2282248934, 4279200368, 1711684554, 285281116,  2405801727, 4167216745,
        1634467795, 376229701,  2685067896, 3608007406, 1308918612, 956543938,
        2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836,
        1088359270, 936918000,  2847714899, 3736837829, 1202900863, 817233897,
        3183342108, 3401237130, 1404277552, 615818150,  3134207493, 3453421203,
        1423857449, 601450431,  3009837614, 3294710456, 1567103746, 711928724,
        3020668471, 3272380065, 1510334235, 755167117,
    },
    {
        0,          421212481,  842424962,  724390851,  1684849924, 2105013317,
        1448781702, 1329698503, 3369699848, 3519200073, 4210026634, 3824474571,
        2897563404, 3048111693, 2659397006, 2274893007, 1254232657, 1406739216,
        2029285587, 1643069842, 783210325,  934667796,  479770071,  92505238,
        2182846553, 2600511768, 2955803355, 2838940570, 3866582365, 4285295644,
        3561045983, 3445231262, 2508465314, 2359236067, 2813478432, 3198777185,
        4058571174, 3908292839, 3286139684, 3670389349, 1566420650, 1145479147,
        1869335592, 1987116393, 959540142,  539646703,  185010476,  303839341,
        3745920755, 3327985586, 3983561841, 4100678960, 3140154359, 2721170102,
        2300350837, 2416418868, 396344571,  243568058,  631889529,  1018359608,
        1945336319, 1793607870, 1103436669, 1490954812, 4034481925, 3915546180,
        3259968903, 3679722694, 2484439553, 2366552896, 2787371139, 3208174018,
        950060301,  565965900,  177645455,  328046286,  1556873225, 1171730760,
        1861902987, 2011255754, 3132841300, 2745199637, 2290958294, 2442530455,
        3738671184, 3352078609, 3974232786, 4126854035, 1919080284, 1803150877,
        1079293406, 1498383519, 370020952,  253043481,  607678682,  1025720731,
        1711106983, 2095471334, 1472923941, 1322268772, 26324643,   411738082,
        866634785,  717028704,  2904875439, 3024081134, 2668790573, 2248782444,
        3376948395, 3495106026, 4219356713, 3798300520, 792689142,  908347575,
        487136116,  68299317,   1263779058, 1380486579, 2036719216, 1618931505,
        3890672638, 4278043327, 3587215740, 3435896893, 2206873338, 2593195963,
        2981909624, 2829542713, 998479947,  580430090,  162921161,  279890824,
        1609522511, 1190423566, 1842954189, 1958874764, 4082766403, 3930137346,
        3245109441, 3631694208, 2536953671, 2385372678, 2768287173, 3155920004,
        1900120602, 1750776667, 1131931800, 1517083097, 355290910,  204897887,
        656092572,  1040194781, 3113746450, 2692952403, 2343461520, 2461357009,
        3723805974, 3304059991, 4022511508, 4141455061, 2919742697, 3072101800,
        2620513899, 2234183466, 3396041197, 3547351212, 4166851439, 3779471918,
        1725839073, 2143618976, 1424512099, 1307796770, 45282277,   464110244,
        813994343,  698327078,  3838160568, 4259225593, 3606301754, 3488152955,
        2158586812, 2578602749, 2996767038, 2877569151, 740041904,  889656817,
        506086962,  120682355,  1215357364, 1366020341, 2051441462, 1667084919,
        3422213966, 3538019855, 4190942668, 3772220557, 2945847882, 3062702859,
        2644537544, 2226864521, 52649286,   439905287,  823476164,  672009861,
        1733269570, 2119477507, 1434057408, 1281543041, 2167981343, 2552493150,
        3004082077, 2853541596, 3847487515, 4233048410, 3613549209, 3464057816,
        1239502615, 1358593622, 2077699477, 1657543892, 764250643,  882293586,
        532408465,  111204816,  1585378284, 1197851309, 1816695150, 1968414767,
        974272232,  587794345,  136598634,  289367339,  2527558116, 2411481253,
        2760973158, 3179948583, 4073438432, 3956313505, 3237863010, 3655790371,
        347922877,  229101820,  646611775,  1066513022, 1892689081, 1774917112,
        1122387515, 1543337850, 3697634229, 3313392372, 3998419255, 4148705398,
        3087642289, 2702352368, 2319436851, 2468674930,
    },
    {
        0,          29518391,   59036782,   38190681,   118073564,  114017003,
        76381362,   89069189,   236147128,  265370511,  228034006,  206958561,
        152762724,  148411219,  178138378,  190596925,  472294256,  501532999,
        530741022,  509615401,  456068012,  451764635,  413917122,  426358261,
        305525448,  334993663,  296822438,  275991697,  356276756,  352202787,
        381193850,  393929805,  944588512,  965684439,  1003065998, 973863097,
        1061482044, 1049003019, 1019230802, 1023561829, 912136024,  933002607,
        903529270,  874031361,  827834244,  815125939,  852716522,  856752605,
        611050896,  631869351,  669987326,  640506825,  593644876,  580921211,
        551983394,  556069653,  712553512,  733666847,  704405574,  675154545,
        762387700,  749958851,  787859610,  792175277,  1889177024, 1901651959,
        1931368878, 1927033753, 2006131996, 1985040171, 1947726194, 1976933189,
        2122964088, 2135668303, 2098006038, 2093965857, 2038461604, 2017599123,
        2047123658, 2076625661, 1824272048, 1836991623, 1866005214, 1861914857,
        1807058540, 1786244187, 1748062722, 1777547317, 1655668488, 1668093247,
        1630251878, 1625932113, 1705433044, 1684323811, 1713505210, 1742760333,
        1222101792, 1226154263, 1263738702, 1251046777, 1339974652, 1310460363,
        1281013650, 1301863845, 1187289752, 1191637167, 1161842422, 1149379777,
        1103966788, 1074747507, 1112139306, 1133218845, 1425107024, 1429406311,
        1467333694, 1454888457, 1408811148, 1379576507, 1350309090, 1371438805,
        1524775400, 1528845279, 1499917702, 1487177649, 1575719220, 1546255107,
        1584350554, 1605185389, 3778354048, 3774312887, 3803303918, 3816007129,
        3862737756, 3892238699, 3854067506, 3833203973, 4012263992, 4007927823,
        3970080342, 3982554209, 3895452388, 3924658387, 3953866378, 3932773565,
        4245928176, 4241609415, 4271336606, 4283762345, 4196012076, 4225268251,
        4187931714, 4166823541, 4076923208, 4072833919, 4035198246, 4047918865,
        4094247316, 4123732899, 4153251322, 4132437965, 3648544096, 3636082519,
        3673983246, 3678331705, 3732010428, 3753090955, 3723829714, 3694611429,
        3614117080, 3601426159, 3572488374, 3576541825, 3496125444, 3516976691,
        3555094634, 3525581405, 3311336976, 3298595879, 3336186494, 3340255305,
        3260503756, 3281337595, 3251864226, 3222399125, 3410866088, 3398419871,
        3368647622, 3372945905, 3427010420, 3448139075, 3485520666, 3456284973,
        2444203584, 2423127159, 2452308526, 2481530905, 2527477404, 2539934891,
        2502093554, 2497740997, 2679949304, 2659102159, 2620920726, 2650438049,
        2562027300, 2574714131, 2603727690, 2599670141, 2374579504, 2353749767,
        2383274334, 2412743529, 2323684844, 2336421851, 2298759554, 2294686645,
        2207933576, 2186809023, 2149495014, 2178734801, 2224278612, 2236720739,
        2266437690, 2262135309, 2850214048, 2820717207, 2858812622, 2879680249,
        2934667388, 2938704459, 2909776914, 2897069605, 2817622296, 2788420399,
        2759153014, 2780249921, 2700618180, 2704950259, 2742877610, 2730399645,
        3049550800, 3020298727, 3057690558, 3078802825, 2999835404, 3004150075,
        2974355298, 2961925461, 3151438440, 3121956959, 3092510214, 3113327665,
        3168701108, 3172786307, 3210370778, 3197646061,
    },
    {
        0,          3099354981, 2852767883, 313896942,  2405603159, 937357362,
        627793884,  2648127673, 3316918511, 2097696650, 1874714724, 3607201537,
        1255587768, 4067088605, 3772741427, 1482887254, 1343838111, 3903140090,
        4195393300, 1118632049, 3749429448, 1741137837, 1970407491, 3452858150,
        2511175536, 756094997,  1067759611, 2266550430, 449832999,  2725482306,
        2965774508, 142231497,  2687676222, 412010587,  171665333,  2995192016,
        793786473,  2548850444, 2237264098, 1038456711, 1703315409, 3711623348,
        3482275674, 1999841343, 3940814982, 1381529571, 1089329165, 4166106984,
        4029413537, 1217896388, 1512189994, 3802027855, 2135519222, 3354724499,
        3577784189, 1845280792, 899665998,  2367928107, 2677414085, 657096608,
        3137160985, 37822588,   284462994,  2823350519, 2601801789, 598228824,
        824021174,  2309093331, 343330666,  2898962447, 3195996129, 113467524,
        1587572946, 3860600759, 4104763481, 1276501820, 3519211397, 1769898208,
        2076913422, 3279374443, 3406630818, 1941006535, 1627703081, 3652755532,
        1148164341, 4241751952, 3999682686, 1457141531, 247015245,  3053797416,
        2763059142, 470583459,  2178658330, 963106687,  735213713,  2473467892,
        992409347,  2207944806, 2435792776, 697522413,  3024379988, 217581361,
        508405983,  2800865210, 4271038444, 1177467017, 1419450215, 3962007554,
        1911572667, 3377213406, 3690561584, 1665525589, 1799331996, 3548628985,
        3241568279, 2039091058, 3831314379, 1558270126, 1314193216, 4142438437,
        2928380019, 372764438,  75645176,   3158189981, 568925988,  2572515393,
        2346768303, 861712586,  3982079547, 1441124702, 1196457648, 4293663189,
        1648042348, 3666298377, 3358779879, 1888390786, 686661332,  2421291441,
        2196002399, 978858298,  2811169155, 523464422,  226935048,  3040519789,
        3175145892, 100435649,  390670639,  2952089162, 841119475,  2325614998,
        2553003640, 546822429,  2029308235, 3225988654, 3539796416, 1782671013,
        4153826844, 1328167289, 1570739863, 3844338162, 1298864389, 4124540512,
        3882013070, 1608431339, 3255406162, 2058742071, 1744848601, 3501990332,
        2296328682, 811816591,  584513889,  2590678532, 129869501,  3204563416,
        2914283062, 352848211,  494030490,  2781751807, 3078325777, 264757620,
        2450577869, 715964072,  941166918,  2158327331, 3636881013, 1618608400,
        1926213374, 3396585883, 1470427426, 4011365959, 4255988137, 1158766284,
        1984818694, 3471935843, 3695453837, 1693991400, 4180638033, 1100160564,
        1395044826, 3952793279, 3019491049, 189112716,  435162722,  2706139399,
        1016811966, 2217162459, 2526189877, 774831696,  643086745,  2666061564,
        2354934034, 887166583,  2838900430, 294275499,  54519365,   3145957664,
        3823145334, 1532818963, 1240029693, 4048895640, 1820460577, 3560857924,
        3331051178, 2117577167, 3598663992, 1858283101, 2088143283, 3301633750,
        1495127663, 3785470218, 4078182116, 1269332353, 332098007,  2876706482,
        3116540252, 25085497,   2628386432, 605395429,  916469259,  2384220526,
        2254837415, 1054503362, 745528876,  2496903497, 151290352,  2981684885,
        2735556987, 464596510,  1137851976, 4218313005, 3923506883, 1365741990,
        3434129695, 1946996346, 1723425172, 3724871409,
    },
    {
        0,          1029712304, 2059424608, 1201699536, 4118849216, 3370159984,
        2403399072, 2988497936, 812665793,  219177585,  1253054625, 2010132753,
        3320900865, 4170237105, 3207642721, 2186319825, 1625331586, 1568718386,
        438355170,  658566482,  2506109250, 2818578674, 4020265506, 3535817618,
        1351670851, 1844508147, 709922595,  389064339,  2769320579, 2557498163,
        3754961379, 3803185235, 3250663172, 4238411444, 3137436772, 2254525908,
        876710340,  153198708,  1317132964, 1944187668, 4054934725, 3436268917,
        2339452837, 3054575125, 70369797,   961670069,  2129760613, 1133623509,
        2703341702, 2621542710, 3689016294, 3867263574, 1419845190, 1774270454,
        778128678,  318858390,  2438067015, 2888948471, 3952189479, 3606153623,
        1691440519, 1504803895, 504432359,  594620247,  1492342857, 1704161785,
        573770537,  525542041,  2910060169, 2417219385, 3618876905, 3939730521,
        1753420680, 1440954936, 306397416,  790849880,  2634265928, 2690882808,
        3888375336, 3668168600, 940822475,  91481723,   1121164459, 2142483739,
        3448989963, 4042473659, 3075684971, 2318603227, 140739594,  889433530,
        1923340138, 1338244826, 4259521226, 3229813626, 2267247018, 3124975642,
        2570221389, 2756861693, 3824297005, 3734113693, 1823658381, 1372780605,
        376603373,  722643805,  2839690380, 2485261628, 3548540908, 4007806556,
        1556257356, 1638052860, 637716780,  459464860,  4191346895, 3300051327,
        2199040943, 3195181599, 206718479,  825388991,  1989285231, 1274166495,
        3382881038, 4106388158, 3009607790, 2382549470, 1008864718, 21111934,
        1189240494, 2072147742, 2984685714, 2357631266, 3408323570, 4131834434,
        1147541074, 2030452706, 1051084082, 63335554,   2174155603, 3170292451,
        4216760371, 3325460867, 1947622803, 1232499747, 248909555,  867575619,
        3506841360, 3966111392, 2881909872, 2527485376, 612794832,  434546784,
        1581699760, 1663499008, 3782634705, 3692447073, 2612412337, 2799048193,
        351717905,  697754529,  1849071985, 1398190273, 1881644950, 1296545318,
        182963446,  931652934,  2242328918, 3100053734, 4284967478, 3255255942,
        1079497815, 2100821479, 983009079,  133672583,  3050795671, 2293717799,
        3474399735, 4067887175, 281479188,  765927844,  1778867060, 1466397380,
        3846680276, 3626469220, 2676489652, 2733102084, 548881365,  500656741,
        1517752501, 1729575173, 3577210133, 3898068133, 2952246901, 2459410373,
        3910527195, 3564487019, 2480257979, 2931134987, 479546907,  569730987,
        1716854139, 1530213579, 3647316762, 3825568426, 2745561210, 2663766474,
        753206746,  293940330,  1445287610, 1799716618, 2314567513, 3029685993,
        4080348217, 3461678473, 2088098201, 1091956777, 112560889,  1003856713,
        3112514712, 2229607720, 3276105720, 4263857736, 1275433560, 1902492648,
        918929720,  195422344,  685033439,  364179055,  1377080511, 1869921551,
        3713294623, 3761522863, 2811507327, 2599689167, 413436958,  633644462,
        1650777982, 1594160846, 3978570462, 3494118254, 2548332990, 2860797966,
        1211387997, 1968470509, 854852413,  261368461,  3182753437, 2161434413,
        3346310653, 4195650637, 2017729436, 1160000044, 42223868,   1071931724,
        2378480988, 2963576044, 4144295484, 3395602316,
    },
    {
        0,          3411858341, 1304994059, 2257875630, 2609988118, 1355649459,
        3596215069, 486879416,  3964895853, 655315400,  2711298918, 1791488195,
        2009251963, 3164476382, 973758832,  4048990933, 64357019,   3364540734,
        1310630800, 2235723829, 2554806413, 1394316072, 3582976390, 517157411,
        4018503926, 618222419,  2722963965, 1762783832, 1947517664, 3209171269,
        970744811,  4068520014, 128714038,  3438335635, 1248109629, 2167961496,
        2621261600, 1466012805, 3522553387, 447296910,  3959392091, 547575038,
        2788632144, 1835791861, 1886307661, 3140622056, 1034314822, 4143626211,
        75106221,   3475428360, 1236444838, 2196665603, 2682996155, 1421317662,
        3525567664, 427767573,  3895035328, 594892389,  2782995659, 1857943406,
        1941489622, 3101955187, 1047553757, 4113347960, 257428076,  3288652233,
        1116777319, 2311878850, 2496219258, 1603640287, 3640781169, 308099796,
        3809183745, 676813732,  2932025610, 1704983215, 2023410199, 3016104370,
        894593820,  4262377657, 210634999,  3352484690, 1095150076, 2316991065,
        2535410401, 1547934020, 3671583722, 294336591,  3772615322, 729897279,
        2903845777, 1716123700, 2068629644, 2953845545, 914647431,  4258839074,
        150212442,  3282623743, 1161604689, 2388688372, 2472889676, 1480171241,
        3735940167, 368132066,  3836185911, 805002898,  2842635324, 1647574937,
        2134298401, 3026852996, 855535146,  4188192143, 186781121,  3229539940,
        1189784778, 2377547631, 2427670487, 1542429810, 3715886812, 371670393,
        3882979244, 741170185,  2864262823, 1642462466, 2095107514, 3082559007,
        824732849,  4201955092, 514856152,  3589064573, 1400419795, 2552522358,
        2233554638, 1316849003, 3370776517, 62202976,   4075001525, 968836368,
        3207280574, 1954014235, 1769133219, 2720925446, 616199592,  4024870413,
        493229635,  3594175974, 1353627464, 2616354029, 2264355925, 1303087088,
        3409966430, 6498043,    4046820398, 979978123,  3170710821, 2007099008,
        1789187640, 2717386141, 661419827,  3962610838, 421269998,  3527459403,
        1423225061, 2676515648, 2190300152, 1238466653, 3477467891, 68755798,
        4115633027, 1041448998, 3095868040, 1943789869, 1860096405, 2776760880,
        588673182,  3897205563, 449450869,  3516317904, 1459794558, 2623431131,
        2170245475, 1242006214, 3432247400, 131015629,  4137259288, 1036337853,
        3142660115, 1879958454, 1829294862, 2790523051, 549483013,  3952910752,
        300424884,  3669282065, 1545650111, 2541513754, 2323209378, 1092980487,
        3350330793, 216870412,  4256931033, 921128828,  2960342482, 2066738807,
        1714085583, 2910195050, 736264132,  3770592353, 306060335,  3647131530,
        1610005796, 2494197377, 2309971513, 1123257756, 3295149874, 255536279,
        4268596802, 892423655,  3013951305, 2029645036, 1711070292, 2929725425,
        674528607,  3815288570, 373562242,  3709388839, 1535949449, 2429577516,
        2379569556, 1183418929, 3223189663, 188820282,  4195850735, 827017802,
        3084859620, 2089020225, 1636228089, 2866415708, 743340786,  3876759895,
        361896217,  3738094268, 1482340370, 2466671543, 2382584591, 1163888810,
        3284924932, 144124321,  4190215028, 849168593,  3020503679, 2136336858,
        1649465698, 2836138695, 798521449,  3838094284,
    },
    {
        0,          2792819636, 2543784233, 837294749,  4098827283, 1379413927,
        1674589498, 3316072078, 871321191,  2509784531, 2758827854, 34034938,
        3349178996, 1641505216, 1346337629, 4131942633, 1742642382, 3249117050,
        4030828007, 1446413907, 2475800797, 904311657,  68069876,   2725880384,
        1412551337, 4064729373, 3283010432, 1708771380, 2692675258, 101317902,
        937551763,  2442587175, 3485284764, 1774858792, 1478633653, 4266992385,
        1005723023, 2642744891, 2892827814, 169477906,  4233263099, 1512406095,
        1808623314, 3451546982, 136139752,  2926205020, 2676114113, 972376437,
        2825102674, 236236518,  1073525883, 2576072655, 1546420545, 4200303349,
        3417542760, 1841601500, 2609703733, 1039917185, 202635804,  2858742184,
        1875103526, 3384067218, 4166835727, 1579931067, 1141601657, 3799809741,
        3549717584, 1977839588, 2957267306, 372464350,  668680259,  2175552503,
        2011446046, 3516084394, 3766168119, 1175200131, 2209029901, 635180217,
        338955812,  2990736784, 601221559,  2242044419, 3024812190, 306049834,
        3617246628, 1911408144, 1074125965, 3866285881, 272279504,  3058543716,
        2275784441, 567459149,  3832906691, 1107462263, 1944752874, 3583875422,
        2343980261, 767641425,  472473036,  3126744696, 2147051766, 3649987394,
        3899029983, 1309766251, 3092841090, 506333494,  801510315,  2310084639,
        1276520081, 3932237093, 3683203000, 2113813516, 3966292011, 1243601823,
        2079834370, 3716205238, 405271608,  3192979340, 2411259153, 701492901,
        3750207052, 2045810168, 1209569125, 4000285905, 734575199,  2378150379,
        3159862134, 438345922,  2283203314, 778166598,  529136603,  3120492655,
        2086260449, 3660498261, 3955679176, 1303499900, 3153699989, 495890209,
        744928700,  2316418568, 1337360518, 3921775410, 3626602927, 2120129051,
        4022892092, 1237286280, 2018993941, 3726666913, 461853231,  3186645403,
        2350400262, 711936178,  3693557851, 2052076527, 1270360434, 3989775046,
        677911624,  2384402428, 3220639073, 427820757,  1202443118, 3789347034,
        3493118535, 1984154099, 3018127229, 362020041,  612099668,  2181885408,
        1950653705, 3526596285, 3822816288, 1168934804, 2148251930, 645706414,
        395618355,  2984485767, 544559008,  2248295444, 3085590153, 295523645,
        3560598451, 1917673479, 1134918298, 3855773998, 328860103,  3052210803,
        2214924526, 577903450,  3889505748, 1101147744, 1883911421, 3594338121,
        3424493451, 1785369663, 1535282850, 4260726038, 944946072,  2653270060,
        2949491377, 163225861,  4294103532, 1501944408, 1752023237, 3457862513,
        196998655,  2915761739, 2619532502, 978710370,  2881684293, 229902577,
        1012666988, 2586515928, 1603020630, 4193987810, 3356702335, 1852063179,
        2553040162, 1046169238, 263412747,  2848217023, 1818454321, 3390333573,
        4227627032, 1569420204, 60859927,   2782375331, 2487203646, 843627658,
        4159668740, 1368951216, 1617990445, 3322386585, 810543216,  2520310724,
        2815490393, 27783917,   3288386659, 1652017111, 1402985802, 4125677310,
        1685994201, 3255382381, 4091620336, 1435902020, 2419138250, 910562686,
        128847843,  2715354199, 1469150398, 4058414858, 3222168983, 1719234083,
        2749255853, 94984985,   876691844,  2453031472,
    },
    {
        0,          3433693342, 1109723005, 2391738339, 2219446010, 1222643300,
        3329165703, 180685081,  3555007413, 525277995,  2445286600, 1567235158,
        1471092047, 2600801745, 361370162,  3642757804, 2092642603, 2953916853,
        1050555990, 4063508168, 4176560081, 878395215,  3134470316, 1987983410,
        2942184094, 1676945920, 3984272867, 567356797,  722740324,  3887998202,
        1764827929, 2778407815, 4185285206, 903635656,  3142804779, 2012833205,
        2101111980, 2979425330, 1058630609, 4088621903, 714308067,  3862526333,
        1756790430, 2753330688, 2933487385, 1651734407, 3975966820, 542535930,
        2244825981, 1231508451, 3353891840, 188896414,  25648519,   3442302233,
        1134713594, 2399689316, 1445480648, 2592229462, 336416693,  3634843435,
        3529655858, 516441772,  2420588879, 1559052753, 698204909,  3845636723,
        1807271312, 2803025166, 2916600855, 1635634313, 4025666410, 593021940,
        4202223960, 919787974,  3093159461, 1962401467, 2117261218, 2996361020,
        1008193759, 4038971457, 1428616134, 2576151384, 386135227,  3685348389,
        3513580860, 499580322,  2471098945, 1608776415, 2260985971, 1248454893,
        3303468814, 139259792,  42591881,   3458459159, 1085071860, 2349261162,
        3505103035, 474062885,  2463016902, 1583654744, 1419882049, 2550902495,
        377792828,  3660491170, 51297038,   3483679632, 1093385331, 2374089965,
        2269427188, 1273935210, 3311514249, 164344343,  2890961296, 1627033870,
        4000683757, 585078387,  672833386,  3836780532, 1782552599, 2794821769,
        2142603813, 3005188795, 1032883544, 4047146438, 4227826911, 928351297,
        3118105506, 1970307900, 1396409818, 2677114180, 287212199,  3719594553,
        3614542624, 467372990,  2505346141, 1509854403, 2162073199, 1282711281,
        3271268626, 240228748,  76845205,   3359543307, 1186043880, 2317064054,
        796964081,  3811226735, 1839575948, 2702160658, 2882189835, 1734392469,
        3924802934, 625327592,  4234522436, 818917338,  3191908409, 1927981223,
        2016387518, 3028656416, 973776579,  4137723485, 2857232268, 1726474002,
        3899187441, 616751215,  772270454,  3803048424, 1814228491, 2693328533,
        2041117753, 3036871847, 999160644,  4146592730, 4259508931, 826864221,
        3217552830, 1936586016, 3606501031, 442291769,  2496909786, 1484378436,
        1388107869, 2652297411, 278519584,  3694387134, 85183762,   3384397196,
        1194773103, 2342308593, 2170143720, 1307820918, 3279733909, 265733131,
        2057717559, 3054258089, 948125770,  4096344276, 4276898253, 843467091,
        3167309488, 1885556270, 2839764098, 1709792284, 3949353983, 667704161,
        755585656,  3785577190, 1865176325, 2743489947, 102594076,  3401021058,
        1144549729, 2291298815, 2186770662, 1325234296, 3228729243, 215514885,
        3589828009, 424832311,  2547870420, 1534552650, 1370645331, 2635621325,
        328688686,  3745342640, 2211456353, 1333405183, 3254067740, 224338562,
        127544219,  3408931589, 1170156774, 2299866232, 1345666772, 2627681866,
        303053225,  3736746295, 3565105198, 416624816,  2522494803, 1525692365,
        4285207626, 868291796,  3176010551, 1910772649, 2065767088, 3079346734,
        956571085,  4121828691, 747507711,  3760459617, 1856702594, 2717976604,
        2831417605, 1684930971, 3940615800, 642451174,
    },
};

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

// ---------------- Initializer Implementations

void wuffs_crc32__ieee_hasher__check_wuffs_version(
    wuffs_crc32__ieee_hasher* self,
    size_t sizeof_star_self,
    uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
}

// ---------------- Function Implementations

// -------- func crc32.ieee_hasher.update

WUFFS_BASE__MAYBE_STATIC uint32_t  //
wuffs_crc32__ieee_hasher__update(wuffs_crc32__ieee_hasher* self,
                                 wuffs_base__slice_u8 a_x) {
  if (!self) {
    return 0;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return 0;
  }

  uint32_t v_s;

  v_s = (4294967295 ^ self->private_impl.f_state);
  {
    wuffs_base__slice_u8 i_slice_p = a_x;
    wuffs_base__slice_u8 v_p = i_slice_p;
    v_p.len = 8;
    uint8_t* i_end0_p = i_slice_p.ptr + (i_slice_p.len / 64) * 64;
    while (v_p.ptr < i_end0_p) {
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
    }
    v_p.len = 8;
    uint8_t* i_end1_p = i_slice_p.ptr + (i_slice_p.len / 8) * 8;
    while (v_p.ptr < i_end1_p) {
      v_s ^=
          ((((uint32_t)(v_p.ptr[0])) << 0) | (((uint32_t)(v_p.ptr[1])) << 8) |
           (((uint32_t)(v_p.ptr[2])) << 16) | (((uint32_t)(v_p.ptr[3])) << 24));
      v_s = (wuffs_crc32__ieee_table[0][v_p.ptr[7]] ^
             wuffs_crc32__ieee_table[1][v_p.ptr[6]] ^
             wuffs_crc32__ieee_table[2][v_p.ptr[5]] ^
             wuffs_crc32__ieee_table[3][v_p.ptr[4]] ^
             wuffs_crc32__ieee_table[4][(255 & (v_s >> 24))] ^
             wuffs_crc32__ieee_table[5][(255 & (v_s >> 16))] ^
             wuffs_crc32__ieee_table[6][(255 & (v_s >> 8))] ^
             wuffs_crc32__ieee_table[7][(255 & (v_s >> 0))]);
      v_p.ptr += 8;
    }
    v_p.len = 1;
    uint8_t* i_end2_p = i_slice_p.ptr + (i_slice_p.len / 1) * 1;
    while (v_p.ptr < i_end2_p) {
      v_s =
          (wuffs_crc32__ieee_table[0][(((uint8_t)((v_s & 255))) ^ v_p.ptr[0])] ^
           (v_s >> 8));
      v_p.ptr += 1;
    }
  }
  self->private_impl.f_state = (4294967295 ^ v_s);
  return self->private_impl.f_state;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__CRC32)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__DEFLATE)

// ---------------- Status Codes Implementations

static const char wuffs_deflate__status__string_data[] = {
    0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x69, 0x6E,
    0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72,
    0x3A, 0x20, 0x69, 0x6E, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74, 0x65,
    0x6E, 0x74, 0x20, 0x6E, 0x5F, 0x62, 0x69, 0x74, 0x73, 0x00, 0x64, 0x65,
    0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72,
    0x6E, 0x61, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0x69,
    0x6E, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x20,
    0x64, 0x69, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 0x64, 0x65, 0x66,
    0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E,
    0x61, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0x69, 0x6E,
    0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x49,
    0x2F, 0x4F, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20,
    0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x72, 0x72,
    0x6F, 0x72, 0x3A, 0x20, 0x69, 0x6E, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73,
    0x74, 0x65, 0x6E, 0x74, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61, 0x6E,
    0x20, 0x65, 0x6E, 0x64, 0x5F, 0x6F, 0x66, 0x5F, 0x62, 0x6C, 0x6F, 0x63,
    0x6B, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x69,
    0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F,
    0x72, 0x3A, 0x20, 0x69, 0x6E, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74,
    0x65, 0x6E, 0x74, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61, 0x6E, 0x20,
    0x64, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74,
    0x65, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x6E,
    0x6F, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61, 0x6E, 0x20, 0x63, 0x6F,
    0x64, 0x65, 0x73, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A,
    0x20, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x6E, 0x64,
    0x2D, 0x6F, 0x66, 0x2D, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x63, 0x6F,
    0x64, 0x65, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20,
    0x69, 0x6E, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74,
    0x20, 0x73, 0x74, 0x6F, 0x72, 0x65, 0x64, 0x20, 0x62, 0x6C, 0x6F, 0x63,
    0x6B, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x00, 0x64, 0x65, 0x66,
    0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x6C, 0x69,
    0x74, 0x65, 0x72, 0x61, 0x6C, 0x2F, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68,
    0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00,
    0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64,
    0x20, 0x64, 0x69, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x63, 0x6F,
    0x64, 0x65, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x64, 0x65, 0x66,
    0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x64, 0x69,
    0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61,
    0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x62, 0x6C, 0x6F, 0x63,
    0x6B, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x62,
    0x61, 0x64, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61, 0x6E, 0x20, 0x6D,
    0x69, 0x6E, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20,
    0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61,
    0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x48, 0x75, 0x66, 0x66,
    0x6D, 0x61, 0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x00, 0x64, 0x65, 0x66,
    0x6C, 0x61, 0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x48, 0x75,
    0x66, 0x66, 0x6D, 0x61, 0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x6C,
    0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x72, 0x65, 0x70, 0x65, 0x74, 0x69,
    0x74, 0x69, 0x6F, 0x6E, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65,
    0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61,
    0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74,
    0x68, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x64, 0x65, 0x66, 0x6C,
    0x61, 0x74, 0x65, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x48, 0x75, 0x66,
    0x66, 0x6D, 0x61, 0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x28, 0x75,
    0x6E, 0x64, 0x65, 0x72, 0x2D, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x64, 0x29, 0x00, 0x64, 0x65, 0x66, 0x6C, 0x61, 0x74, 0x65,
    0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x48, 0x75, 0x66, 0x66, 0x6D, 0x61,
    0x6E, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x28, 0x6F, 0x76, 0x65, 0x72,
    0x2D, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x29,
    0x00,
};

static const uint16_t wuffs_deflate__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001,
    0x002E, 0x005D, 0x0087, 0x00C2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x00FE, 0x0118, 0x013B, 0x0165, 0x018C, 0x01AD, 0x01C3, 0x01D6, 0x01FF,
    0x0219, 0x0245, 0x026C, 0x0299,
};

const char* wuffs_deflate__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_deflate__packageid:
      o = wuffs_deflate__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_deflate__status__string_data + o;
      }
      break;
  }
  return "unknown status";
}

// ---------------- Private Consts

static const uint8_t wuffs_deflate__code_order[19] = {
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
};

static const uint8_t wuffs_deflate__reverse8[256] = {
    0,  128, 64, 192, 32, 160, 96,  224, 16, 144, 80, 208, 48, 176, 112, 240,
    8,  136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
    4,  132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
    12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
    2,  130, 66, 194, 34, 162, 98,  226, 18, 146, 82, 210, 50, 178, 114, 242,
    10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
    6,  134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
    14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
    1,  129, 65, 193, 33, 161, 97,  225, 17, 145, 81, 209, 49, 177, 113, 241,
    9,  137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
    5,  133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
    13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
    3,  131, 67, 195, 35, 163, 99,  227, 19, 147, 83, 211, 51, 179, 115, 243,
    11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
    7,  135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
    15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255,
};

static const uint32_t wuffs_deflate__lcode_magic_numbers[32] = {
    1073742592, 1073742848, 1073743104, 1073743360, 1073743616, 1073743872,
    1073744128, 1073744384, 1073744656, 1073745168, 1073745680, 1073746192,
    1073746720, 1073747744, 1073748768, 1073749792, 1073750832, 1073752880,
    1073754928, 1073756976, 1073759040, 1073763136, 1073767232, 1073771328,
    1073775440, 1073783632, 1073791824, 1073800016, 1073807872, 134217728,
    134217728,  134217728,
};

static const uint32_t wuffs_deflate__dcode_magic_numbers[32] = {
    1073741824, 1073742080, 1073742336, 1073742592, 1073742864, 1073743376,
    1073743904, 1073744928, 1073745968, 1073748016, 1073750080, 1073754176,
    1073758288, 1073766480, 1073774688, 1073791072, 1073807472, 1073840240,
    1073873024, 1073938560, 1074004112, 1074135184, 1074266272, 1074528416,
    1074790576, 1075314864, 1075839168, 1076887744, 1077936336, 1080033488,
    134217728,  134217728,
};

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

static wuffs_base__status  //
wuffs_deflate__decoder__decode_blocks(wuffs_deflate__decoder* self,
                                      wuffs_base__io_writer a_dst,
                                      wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_deflate__decoder__decode_uncompressed(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_deflate__decoder__init_fixed_huffman(wuffs_deflate__decoder* self);

static wuffs_base__status  //
wuffs_deflate__decoder__init_dynamic_huffman(wuffs_deflate__decoder* self,
                                             wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_deflate__decoder__init_huff(wuffs_deflate__decoder* self,
                                  uint32_t a_which,
                                  uint32_t a_n_codes0,
                                  uint32_t a_n_codes1,
                                  uint32_t a_base_symbol);

static wuffs_base__status  //
wuffs_deflate__decoder__decode_huffman_fast(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_deflate__decoder__decode_huffman_slow(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src);

// ---------------- Initializer Implementations

void wuffs_deflate__decoder__check_wuffs_version(wuffs_deflate__decoder* self,
                                                 size_t sizeof_star_self,
                                                 uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
}

// ---------------- Function Implementations

// -------- func deflate.decoder.decode

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_deflate__decoder__decode(wuffs_deflate__decoder* self,
                               wuffs_base__io_writer a_dst,
                               wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  wuffs_base__status v_z;
  wuffs_base__slice_u8 v_written;
  uint64_t v_n_copied;
  uint32_t v_already_full;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_z = self->private_impl.c_decode[0].v_z;
    v_written = ((wuffs_base__slice_u8){});
    v_n_copied = self->private_impl.c_decode[0].v_n_copied;
    v_already_full = self->private_impl.c_decode[0].v_already_full;
  } else {
    v_written = ((wuffs_base__slice_u8){});
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      wuffs_base__io_writer__set_mark(&a_dst, ioptr_dst);
      {
        if (a_dst.private_impl.buf) {
          a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
        }
        wuffs_base__status t_0 =
            wuffs_deflate__decoder__decode_blocks(self, a_dst, a_src);
        if (a_dst.private_impl.buf) {
          ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
        }
        v_z = t_0;
      }
      if (!(v_z > 0)) {
        status = v_z;
        if (status == 0) {
          goto ok;
        } else if (status > 0) {
          status = WUFFS_BASE__ERROR_CANNOT_RETURN_A_SUSPENSION;
        }
        goto exit;
      }
      v_written = ((wuffs_base__slice_u8){
          .ptr = a_dst.private_impl.bounds[0],
          .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
      });
      if (((uint64_t)(v_written.len)) >= 32768) {
        v_written = wuffs_base__slice_u8__suffix(v_written, 32768);
        wuffs_base__slice_u8__copy_from_slice(
            ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                    .len = 32768}),
            v_written);
        self->private_impl.f_history_index = 32768;
      } else {
        v_n_copied = wuffs_base__slice_u8__copy_from_slice(
            wuffs_base__slice_u8__subslice_i(
                ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                        .len = 32768}),
                (self->private_impl.f_history_index & 32767)),
            v_written);
        if (v_n_copied < ((uint64_t)(v_written.len))) {
          v_written = wuffs_base__slice_u8__subslice_i(v_written, v_n_copied);
          v_n_copied = wuffs_base__slice_u8__copy_from_slice(
              ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                      .len = 32768}),
              v_written);
          self->private_impl.f_history_index =
              (((uint32_t)((v_n_copied & 32767))) + 32768);
        } else {
          v_already_full = 0;
          if (self->private_impl.f_history_index >= 32768) {
            v_already_full = 32768;
          }
          self->private_impl.f_history_index =
              ((self->private_impl.f_history_index & 32767) +
               ((uint32_t)((v_n_copied & 32767))) + v_already_full);
        }
      }
      status = v_z;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(1);
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_z = v_z;
  self->private_impl.c_decode[0].v_n_copied = v_n_copied;
  self->private_impl.c_decode[0].v_already_full = v_already_full;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }

  self->private_impl.status = status;
  return status;
}

// -------- func deflate.decoder.decode_blocks

static wuffs_base__status  //
wuffs_deflate__decoder__decode_blocks(wuffs_deflate__decoder* self,
                                      wuffs_base__io_writer a_dst,
                                      wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_final;
  uint32_t v_type;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_blocks[0].coro_susp_point;
  if (coro_susp_point) {
    v_final = self->private_impl.c_decode_blocks[0].v_final;
    v_type = self->private_impl.c_decode_blocks[0].v_type;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_final = 0;
  label_0_continue:;
    while (v_final == 0) {
      while (self->private_impl.f_n_bits < 3) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *ioptr_src++;
          self->private_impl.f_bits |=
              (((uint32_t)(t_0)) << self->private_impl.f_n_bits);
        }
        self->private_impl.f_n_bits += 8;
      }
      v_final = (self->private_impl.f_bits & 1);
      v_type = ((self->private_impl.f_bits >> 1) & 3);
      self->private_impl.f_bits >>= 3;
      self->private_impl.f_n_bits -= 3;
      if (v_type == 0) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status =
            wuffs_deflate__decoder__decode_uncompressed(self, a_dst, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
        goto label_0_continue;
      } else if (v_type == 1) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        status = wuffs_deflate__decoder__init_fixed_huffman(self);
        if (status) {
          goto suspend;
        }
      } else if (v_type == 2) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status = wuffs_deflate__decoder__init_dynamic_huffman(self, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
      } else {
        status = WUFFS_DEFLATE__ERROR_BAD_BLOCK;
        goto exit;
      }
      self->private_impl.f_end_of_block = false;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_deflate__decoder__decode_huffman_fast(self, a_dst, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      if (self->private_impl.f_end_of_block) {
        goto label_0_continue;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_deflate__decoder__decode_huffman_slow(self, a_dst, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      if (self->private_impl.f_end_of_block) {
        goto label_0_continue;
      }
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_END_OF_BLOCK;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_blocks[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_blocks[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_blocks[0].v_final = v_final;
  self->private_impl.c_decode_blocks[0].v_type = v_type;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func deflate.decoder.decode_uncompressed

static wuffs_base__status  //
wuffs_deflate__decoder__decode_uncompressed(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_length;
  uint32_t v_n_copied;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_uncompressed[0].coro_susp_point;
  if (coro_susp_point) {
    v_length = self->private_impl.c_decode_uncompressed[0].v_length;
    v_n_copied = self->private_impl.c_decode_uncompressed[0].v_n_copied;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if ((self->private_impl.f_n_bits >= 8) ||
        ((self->private_impl.f_bits >> self->private_impl.f_n_bits) != 0)) {
      status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
      goto exit;
    }
    self->private_impl.f_n_bits = 0;
    self->private_impl.f_bits = 0;
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint32_t t_1;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 4)) {
        t_1 = wuffs_base__load_u32le(ioptr_src);
        ioptr_src += 4;
      } else {
        self->private_impl.c_decode_uncompressed[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch =
              &self->private_impl.c_decode_uncompressed[0].scratch;
          uint32_t t_0 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_0;
          if (t_0 == 24) {
            t_1 = *scratch;
            break;
          }
          t_0 += 8;
          *scratch |= ((uint64_t)(t_0)) << 56;
        }
      }
      v_length = t_1;
    }
    if ((((v_length) & ((1 << (16)) - 1)) + ((v_length) >> (32 - (16)))) !=
        65535) {
      status = WUFFS_DEFLATE__ERROR_INCONSISTENT_STORED_BLOCK_LENGTH;
      goto exit;
    }
    v_length = ((v_length) & ((1 << (16)) - 1));
    while (true) {
      v_n_copied = wuffs_base__io_writer__copy_n_from_reader(
          &ioptr_dst, iobounds1_dst, v_length, &ioptr_src, iobounds1_src);
      if (v_length <= v_n_copied) {
        status = WUFFS_BASE__STATUS_OK;
        goto ok;
      }
      v_length -= v_n_copied;
      if (((uint64_t)(iobounds1_dst - ioptr_dst)) == 0) {
        status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);
      } else {
        status = WUFFS_BASE__SUSPENSION_SHORT_READ;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_uncompressed[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_uncompressed[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_uncompressed[0].v_length = v_length;
  self->private_impl.c_decode_uncompressed[0].v_n_copied = v_n_copied;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func deflate.decoder.init_fixed_huffman

static wuffs_base__status  //
wuffs_deflate__decoder__init_fixed_huffman(wuffs_deflate__decoder* self) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_i;

  uint32_t coro_susp_point =
      self->private_impl.c_init_fixed_huffman[0].coro_susp_point;
  if (coro_susp_point) {
    v_i = self->private_impl.c_init_fixed_huffman[0].v_i;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_i = 0;
    while (v_i < 144) {
      self->private_impl.f_code_lengths[v_i] = 8;
      v_i += 1;
    }
    while (v_i < 256) {
      self->private_impl.f_code_lengths[v_i] = 9;
      v_i += 1;
    }
    while (v_i < 280) {
      self->private_impl.f_code_lengths[v_i] = 7;
      v_i += 1;
    }
    while (v_i < 288) {
      self->private_impl.f_code_lengths[v_i] = 8;
      v_i += 1;
    }
    while (v_i < 320) {
      self->private_impl.f_code_lengths[v_i] = 5;
      v_i += 1;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
    status = wuffs_deflate__decoder__init_huff(self, 0, 0, 288, 257);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    status = wuffs_deflate__decoder__init_huff(self, 1, 288, 320, 0);
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_init_fixed_huffman[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_init_fixed_huffman[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_init_fixed_huffman[0].v_i = v_i;

  goto exit;
exit:
  return status;
}

// -------- func deflate.decoder.init_dynamic_huffman

static wuffs_base__status  //
wuffs_deflate__decoder__init_dynamic_huffman(wuffs_deflate__decoder* self,
                                             wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_n_lit;
  uint32_t v_n_dist;
  uint32_t v_n_clen;
  uint32_t v_i;
  uint32_t v_mask;
  uint32_t v_table_entry;
  uint32_t v_table_entry_n_bits;
  uint32_t v_n_extra_bits;
  uint8_t v_rep_symbol;
  uint32_t v_rep_count;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_init_dynamic_huffman[0].coro_susp_point;
  if (coro_susp_point) {
    v_bits = self->private_impl.c_init_dynamic_huffman[0].v_bits;
    v_n_bits = self->private_impl.c_init_dynamic_huffman[0].v_n_bits;
    v_n_lit = self->private_impl.c_init_dynamic_huffman[0].v_n_lit;
    v_n_dist = self->private_impl.c_init_dynamic_huffman[0].v_n_dist;
    v_n_clen = self->private_impl.c_init_dynamic_huffman[0].v_n_clen;
    v_i = self->private_impl.c_init_dynamic_huffman[0].v_i;
    v_mask = self->private_impl.c_init_dynamic_huffman[0].v_mask;
    v_table_entry = self->private_impl.c_init_dynamic_huffman[0].v_table_entry;
    v_table_entry_n_bits =
        self->private_impl.c_init_dynamic_huffman[0].v_table_entry_n_bits;
    v_n_extra_bits =
        self->private_impl.c_init_dynamic_huffman[0].v_n_extra_bits;
    v_rep_symbol = self->private_impl.c_init_dynamic_huffman[0].v_rep_symbol;
    v_rep_count = self->private_impl.c_init_dynamic_huffman[0].v_rep_count;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_bits = self->private_impl.f_bits;
    v_n_bits = self->private_impl.f_n_bits;
    while (v_n_bits < 14) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_bits |= (((uint32_t)(t_0)) << v_n_bits);
      }
      v_n_bits += 8;
    }
    v_n_lit = (((v_bits) & ((1 << (5)) - 1)) + 257);
    if (v_n_lit > 286) {
      status = WUFFS_DEFLATE__ERROR_BAD_LITERAL_LENGTH_CODE_COUNT;
      goto exit;
    }
    v_bits >>= 5;
    v_n_dist = (((v_bits) & ((1 << (5)) - 1)) + 1);
    if (v_n_dist > 30) {
      status = WUFFS_DEFLATE__ERROR_BAD_DISTANCE_CODE_COUNT;
      goto exit;
    }
    v_bits >>= 5;
    v_n_clen = (((v_bits) & ((1 << (4)) - 1)) + 4);
    v_bits >>= 4;
    v_n_bits -= 14;
    v_i = 0;
    while (v_i < v_n_clen) {
      while (v_n_bits < 3) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_1)) << v_n_bits);
        }
        v_n_bits += 8;
      }
      self->private_impl.f_code_lengths[wuffs_deflate__code_order[v_i]] =
          ((uint8_t)((v_bits & 7)));
      v_bits >>= 3;
      v_n_bits -= 3;
      v_i += 1;
    }
    while (v_i < 19) {
      self->private_impl.f_code_lengths[wuffs_deflate__code_order[v_i]] = 0;
      v_i += 1;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
    status = wuffs_deflate__decoder__init_huff(self, 0, 0, 19, 4095);
    if (status) {
      goto suspend;
    }
    v_mask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[0]) - 1);
    v_i = 0;
  label_0_continue:;
    while (v_i < (v_n_lit + v_n_dist)) {
      v_table_entry = 0;
      while (true) {
        v_table_entry = self->private_impl.f_huffs[0][(v_bits & v_mask)];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_1_break;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_2 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_2)) << v_n_bits);
        }
        v_n_bits += 8;
      }
    label_1_break:;
      if ((v_table_entry >> 24) != 128) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry = ((v_table_entry >> 8) & 255);
      if (v_table_entry < 16) {
        self->private_impl.f_code_lengths[v_i] = ((uint8_t)(v_table_entry));
        v_i += 1;
        goto label_0_continue;
      }
      v_n_extra_bits = 0;
      v_rep_symbol = 0;
      v_rep_count = 0;
      if (v_table_entry == 16) {
        v_n_extra_bits = 2;
        if (v_i <= 0) {
          status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_LENGTH_REPETITION;
          goto exit;
        }
        v_rep_symbol = self->private_impl.f_code_lengths[(v_i - 1)];
        v_rep_count = 3;
      } else if (v_table_entry == 17) {
        v_n_extra_bits = 3;
        v_rep_symbol = 0;
        v_rep_count = 3;
      } else if (v_table_entry == 18) {
        v_n_extra_bits = 7;
        v_rep_symbol = 0;
        v_rep_count = 11;
      } else {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      while (v_n_bits < v_n_extra_bits) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_3 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_3)) << v_n_bits);
        }
        v_n_bits += 8;
      }
      v_rep_count += ((v_bits) & ((1 << (v_n_extra_bits)) - 1));
      v_bits >>= v_n_extra_bits;
      v_n_bits -= v_n_extra_bits;
      while (v_rep_count > 0) {
        if (v_i >= (v_n_lit + v_n_dist)) {
          status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT;
          goto exit;
        }
        self->private_impl.f_code_lengths[v_i] = v_rep_symbol;
        v_i += 1;
        v_rep_count -= 1;
      }
    }
    if (v_i != (v_n_lit + v_n_dist)) {
      status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT;
      goto exit;
    }
    if (self->private_impl.f_code_lengths[256] == 0) {
      status = WUFFS_DEFLATE__ERROR_MISSING_END_OF_BLOCK_CODE;
      goto exit;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
    status = wuffs_deflate__decoder__init_huff(self, 0, 0, v_n_lit, 257);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
    status = wuffs_deflate__decoder__init_huff(self, 1, v_n_lit,
                                               (v_n_lit + v_n_dist), 0);
    if (status) {
      goto suspend;
    }
    self->private_impl.f_bits = v_bits;
    self->private_impl.f_n_bits = v_n_bits;

    goto ok;
  ok:
    self->private_impl.c_init_dynamic_huffman[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_init_dynamic_huffman[0].coro_susp_point =
      coro_susp_point;
  self->private_impl.c_init_dynamic_huffman[0].v_bits = v_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_bits = v_n_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_lit = v_n_lit;
  self->private_impl.c_init_dynamic_huffman[0].v_n_dist = v_n_dist;
  self->private_impl.c_init_dynamic_huffman[0].v_n_clen = v_n_clen;
  self->private_impl.c_init_dynamic_huffman[0].v_i = v_i;
  self->private_impl.c_init_dynamic_huffman[0].v_mask = v_mask;
  self->private_impl.c_init_dynamic_huffman[0].v_table_entry = v_table_entry;
  self->private_impl.c_init_dynamic_huffman[0].v_table_entry_n_bits =
      v_table_entry_n_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_extra_bits = v_n_extra_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_rep_symbol = v_rep_symbol;
  self->private_impl.c_init_dynamic_huffman[0].v_rep_count = v_rep_count;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func deflate.decoder.init_huff

static wuffs_base__status  //
wuffs_deflate__decoder__init_huff(wuffs_deflate__decoder* self,
                                  uint32_t a_which,
                                  uint32_t a_n_codes0,
                                  uint32_t a_n_codes1,
                                  uint32_t a_base_symbol) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint16_t v_counts[16];
  uint32_t v_i;
  uint32_t v_remaining;
  uint16_t v_offsets[16];
  uint32_t v_n_symbols;
  uint32_t v_count;
  uint16_t v_symbols[320];
  uint32_t v_min_cl;
  uint32_t v_max_cl;
  uint32_t v_initial_high_bits;
  uint32_t v_prev_cl;
  uint32_t v_prev_redirect_key;
  uint32_t v_top;
  uint32_t v_next_top;
  uint32_t v_code;
  uint32_t v_key;
  uint32_t v_value;
  uint32_t v_cl;
  uint32_t v_tmp;
  uint32_t v_redirect_key;
  uint32_t v_j;
  uint32_t v_reversed_key;
  uint32_t v_symbol;
  uint32_t v_high_bits;
  uint32_t v_delta;

  memset(v_counts, 0, sizeof(v_counts));
  v_i = a_n_codes0;
  while (v_i < a_n_codes1) {
    if (v_counts[self->private_impl.f_code_lengths[v_i]] >= 320) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_counts[self->private_impl.f_code_lengths[v_i]] += 1;
    v_i += 1;
  }
  if ((((uint32_t)(v_counts[0])) + a_n_codes0) == a_n_codes1) {
    status = WUFFS_DEFLATE__ERROR_NO_HUFFMAN_CODES;
    goto exit;
  }
  v_remaining = 1;
  v_i = 1;
  while (v_i <= 15) {
    if (v_remaining > 1073741824) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_remaining <<= 1;
    if (v_remaining < ((uint32_t)(v_counts[v_i]))) {
      status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_OVER_SUBSCRIBED;
      goto exit;
    }
    v_remaining -= ((uint32_t)(v_counts[v_i]));
    v_i += 1;
  }
  if (v_remaining != 0) {
    status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE_UNDER_SUBSCRIBED;
    goto exit;
  }
  memset(v_offsets, 0, sizeof(v_offsets));
  v_n_symbols = 0;
  v_i = 1;
  while (v_i <= 15) {
    v_offsets[v_i] = ((uint16_t)(v_n_symbols));
    v_count = ((uint32_t)(v_counts[v_i]));
    if (v_n_symbols > (320 - v_count)) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_n_symbols = (v_n_symbols + v_count);
    v_i += 1;
  }
  if (v_n_symbols > 288) {
    status =
        WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  memset(v_symbols, 0, sizeof(v_symbols));
  v_i = a_n_codes0;
  while (v_i < a_n_codes1) {
    if (v_i < a_n_codes0) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    if (self->private_impl.f_code_lengths[v_i] != 0) {
      if (v_offsets[self->private_impl.f_code_lengths[v_i]] >= 320) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_symbols[v_offsets[self->private_impl.f_code_lengths[v_i]]] =
          ((uint16_t)((v_i - a_n_codes0)));
      v_offsets[self->private_impl.f_code_lengths[v_i]] += 1;
    }
    v_i += 1;
  }
  v_min_cl = 1;
  while (true) {
    if (v_counts[v_min_cl] != 0) {
      goto label_0_break;
    }
    if (v_min_cl >= 9) {
      status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_MINIMUM_CODE_LENGTH;
      goto exit;
    }
    v_min_cl += 1;
  }
label_0_break:;
  v_max_cl = 15;
  while (true) {
    if (v_counts[v_max_cl] != 0) {
      goto label_1_break;
    }
    if (v_max_cl <= 1) {
      status = WUFFS_DEFLATE__ERROR_NO_HUFFMAN_CODES;
      goto exit;
    }
    v_max_cl -= 1;
  }
label_1_break:;
  if (v_max_cl <= 9) {
    self->private_impl.f_n_huffs_bits[a_which] = v_max_cl;
  } else {
    self->private_impl.f_n_huffs_bits[a_which] = 9;
  }
  v_i = 0;
  if ((v_n_symbols != ((uint32_t)(v_offsets[v_max_cl]))) ||
      (v_n_symbols != ((uint32_t)(v_offsets[15])))) {
    status =
        WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  if ((a_n_codes0 + ((uint32_t)(v_symbols[0]))) >= 320) {
    status =
        WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  v_initial_high_bits = 512;
  if (v_max_cl < 9) {
    v_initial_high_bits = (((uint32_t)(1)) << v_max_cl);
  }
  v_prev_cl = ((uint32_t)(self->private_impl.f_code_lengths[(
      a_n_codes0 + ((uint32_t)(v_symbols[0])))]));
  v_prev_redirect_key = 4294967295;
  v_top = 0;
  v_next_top = 512;
  v_code = 0;
  v_key = 0;
  v_value = 0;
  while (true) {
    if ((a_n_codes0 + ((uint32_t)(v_symbols[v_i]))) >= 320) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_cl = ((uint32_t)(self->private_impl.f_code_lengths[(
        a_n_codes0 + ((uint32_t)(v_symbols[v_i])))]));
    if (v_cl > v_prev_cl) {
      v_code <<= (v_cl - v_prev_cl);
      if (v_code >= 32768) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
    }
    v_prev_cl = v_cl;
    v_key = v_code;
    if (v_cl > 9) {
      v_tmp = (v_cl - 9);
      v_cl = v_tmp;
      v_redirect_key = ((v_key >> v_tmp) & 511);
      v_key = ((v_key) & ((1 << (v_tmp)) - 1));
      if (v_prev_redirect_key != v_redirect_key) {
        v_prev_redirect_key = v_redirect_key;
        v_remaining = (((uint32_t)(1)) << v_cl);
        v_j = v_prev_cl;
        while (v_j <= 15) {
          if (v_remaining <= ((uint32_t)(v_counts[v_j]))) {
            goto label_2_break;
          }
          v_remaining -= ((uint32_t)(v_counts[v_j]));
          if (v_remaining > 1073741824) {
            status =
                WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_remaining <<= 1;
          v_j += 1;
        }
      label_2_break:;
        if ((v_j <= 9) || (15 < v_j)) {
          status =
              WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
        v_tmp = (v_j - 9);
        v_initial_high_bits = (((uint32_t)(1)) << v_tmp);
        v_top = v_next_top;
        if ((v_top + (((uint32_t)(1)) << v_tmp)) > 1234) {
          status =
              WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
        v_next_top = (v_top + (((uint32_t)(1)) << v_tmp));
        v_redirect_key =
            (((uint32_t)(wuffs_deflate__reverse8[(v_redirect_key >> 1)])) |
             ((v_redirect_key & 1) << 8));
        self->private_impl.f_huffs[a_which][v_redirect_key] =
            (268435465 | (v_top << 8) | (v_tmp << 4));
      }
    }
    if ((v_key >= 512) || (v_counts[v_prev_cl] <= 0)) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_counts[v_prev_cl] -= 1;
    v_reversed_key = (((uint32_t)(wuffs_deflate__reverse8[(v_key >> 1)])) |
                      ((v_key & 1) << 8));
    v_reversed_key >>= (9 - v_cl);
    v_symbol = ((uint32_t)(v_symbols[v_i]));
    if (v_symbol == 256) {
      v_value = (536870912 | v_cl);
    } else if ((v_symbol < 256) && (a_which == 0)) {
      v_value = (2147483648 | (v_symbol << 8) | v_cl);
    } else if (v_symbol >= a_base_symbol) {
      v_symbol -= a_base_symbol;
      if (a_which == 0) {
        v_value = (wuffs_deflate__lcode_magic_numbers[(v_symbol & 31)] | v_cl);
      } else {
        v_value = (wuffs_deflate__dcode_magic_numbers[(v_symbol & 31)] | v_cl);
      }
    } else {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_high_bits = v_initial_high_bits;
    v_delta = (((uint32_t)(1)) << v_cl);
    while (v_high_bits >= v_delta) {
      v_high_bits -= v_delta;
      if ((v_top + ((v_high_bits | v_reversed_key) & 511)) >= 1234) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      self->private_impl
          .f_huffs[a_which][(v_top + ((v_high_bits | v_reversed_key) & 511))] =
          v_value;
    }
    v_i += 1;
    if (v_i >= v_n_symbols) {
      goto label_3_break;
    }
    v_code += 1;
    if (v_code >= 32768) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
  }
label_3_break:;
  goto exit;
exit:
  return status;
}

// -------- func deflate.decoder.decode_huffman_fast

static wuffs_base__status  //
wuffs_deflate__decoder__decode_huffman_fast(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_table_entry;
  uint32_t v_table_entry_n_bits;
  uint32_t v_lmask;
  uint32_t v_dmask;
  uint32_t v_redir_top;
  uint32_t v_redir_mask;
  uint32_t v_length;
  uint32_t v_dist_minus_1;
  uint32_t v_n_copied;
  uint32_t v_hlen;
  uint32_t v_hdist;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  if ((self->private_impl.f_n_bits >= 8) ||
      ((self->private_impl.f_bits >> self->private_impl.f_n_bits) != 0)) {
    status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
    goto exit;
  }
  v_bits = self->private_impl.f_bits;
  v_n_bits = self->private_impl.f_n_bits;
  v_table_entry = 0;
  v_table_entry_n_bits = 0;
  v_lmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[0]) - 1);
  v_dmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[1]) - 1);
label_0_continue:;
  while ((((uint64_t)(iobounds1_dst - ioptr_dst)) >= 258) &&
         (((uint64_t)(iobounds1_src - ioptr_src)) >= 12)) {
    if (v_n_bits < 15) {
      v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
      (ioptr_src += 1, wuffs_base__return_empty_struct());
      v_n_bits += 8;
      v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
      (ioptr_src += 1, wuffs_base__return_empty_struct());
      v_n_bits += 8;
    } else {
    }
    v_table_entry = self->private_impl.f_huffs[0][(v_bits & v_lmask)];
    v_table_entry_n_bits = (v_table_entry & 15);
    v_bits >>= v_table_entry_n_bits;
    v_n_bits -= v_table_entry_n_bits;
    if ((v_table_entry >> 31) != 0) {
      (wuffs_base__store_u8be(ioptr_dst,
                              ((uint8_t)(((v_table_entry >> 8) & 255)))),
       ioptr_dst += 1, wuffs_base__return_empty_struct());
      goto label_0_continue;
    } else if ((v_table_entry >> 30) != 0) {
    } else if ((v_table_entry >> 29) != 0) {
      self->private_impl.f_end_of_block = true;
      goto label_0_break;
    } else if ((v_table_entry >> 28) != 0) {
      if (v_n_bits < 15) {
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
      } else {
      }
      v_redir_top = ((v_table_entry >> 8) & 65535);
      v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
      if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry = self->private_impl
                          .f_huffs[0][(v_redir_top + (v_bits & v_redir_mask))];
      v_table_entry_n_bits = (v_table_entry & 15);
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
      if ((v_table_entry >> 31) != 0) {
        (wuffs_base__store_u8be(ioptr_dst,
                                ((uint8_t)(((v_table_entry >> 8) & 255)))),
         ioptr_dst += 1, wuffs_base__return_empty_struct());
        goto label_0_continue;
      } else if ((v_table_entry >> 30) != 0) {
      } else if ((v_table_entry >> 29) != 0) {
        self->private_impl.f_end_of_block = true;
        goto label_0_break;
      } else if ((v_table_entry >> 28) != 0) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      } else if ((v_table_entry >> 27) != 0) {
        status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
        goto exit;
      } else {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
    } else if ((v_table_entry >> 27) != 0) {
      status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
      goto exit;
    } else {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_length = ((v_table_entry >> 8) & 32767);
    v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
    if (v_table_entry_n_bits > 0) {
      if (v_n_bits < 15) {
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
      } else {
      }
      v_length =
          ((v_length + ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1))) &
           32767);
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
    } else {
    }
    if (v_length > 258) {
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    if (v_n_bits < 15) {
      v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
      (ioptr_src += 1, wuffs_base__return_empty_struct());
      v_n_bits += 8;
      v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
      (ioptr_src += 1, wuffs_base__return_empty_struct());
      v_n_bits += 8;
    } else {
    }
    v_table_entry = self->private_impl.f_huffs[1][(v_bits & v_dmask)];
    v_table_entry_n_bits = (v_table_entry & 15);
    v_bits >>= v_table_entry_n_bits;
    v_n_bits -= v_table_entry_n_bits;
    if ((v_table_entry >> 28) == 1) {
      if (v_n_bits < 15) {
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
      } else {
      }
      v_redir_top = ((v_table_entry >> 8) & 65535);
      v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
      if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry = self->private_impl
                          .f_huffs[1][(v_redir_top + (v_bits & v_redir_mask))];
      v_table_entry_n_bits = (v_table_entry & 15);
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
    } else {
    }
    if ((v_table_entry >> 24) != 64) {
      if ((v_table_entry >> 24) == 8) {
        status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
        goto exit;
      }
      status =
          WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_dist_minus_1 = ((v_table_entry >> 8) & 32767);
    v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
    if (v_table_entry_n_bits > 0) {
      if (v_n_bits < 15) {
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
        v_bits |= (((uint32_t)(wuffs_base__load_u8be(ioptr_src))) << v_n_bits);
        (ioptr_src += 1, wuffs_base__return_empty_struct());
        v_n_bits += 8;
      }
      v_dist_minus_1 =
          ((v_dist_minus_1 + ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1))) &
           32767);
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
    }
    v_n_copied = 0;
    while (true) {
      if (((uint64_t)((v_dist_minus_1 + 1))) >
          ((uint64_t)(
              ((wuffs_base__slice_u8){
                   .ptr = a_dst.private_impl.bounds[0],
                   .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
               })
                  .len))) {
        v_hlen = 0;
        v_hdist = ((uint32_t)(
            (((uint64_t)((v_dist_minus_1 + 1))) -
             ((uint64_t)(
                 ((wuffs_base__slice_u8){
                      .ptr = a_dst.private_impl.bounds[0],
                      .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
                  })
                     .len)))));
        if (v_length > v_hdist) {
          v_length -= v_hdist;
          v_hlen = v_hdist;
          if (v_length > 258) {
            status =
                WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
        } else {
          v_hlen = v_length;
          v_length = 0;
        }
        if (self->private_impl.f_history_index < v_hdist) {
          status = WUFFS_DEFLATE__ERROR_BAD_DISTANCE;
          goto exit;
        }
        v_hdist = (self->private_impl.f_history_index - v_hdist);
        while (true) {
          v_n_copied = wuffs_base__io_writer__copy_n_from_slice(
              &ioptr_dst, iobounds1_dst, v_hlen,
              wuffs_base__slice_u8__subslice_i(
                  ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                          .len = 32768}),
                  (v_hdist & 32767)));
          if (v_hlen <= v_n_copied) {
            goto label_1_break;
          }
          v_hlen -= v_n_copied;
          wuffs_base__io_writer__copy_n_from_slice(
              &ioptr_dst, iobounds1_dst, v_hlen,
              ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                      .len = 32768}));
          goto label_1_break;
        }
      label_1_break:;
        if (v_length == 0) {
          goto label_0_continue;
        }
        if (((uint64_t)((v_dist_minus_1 + 1))) >
            ((uint64_t)(
                ((wuffs_base__slice_u8){
                     .ptr = a_dst.private_impl.bounds[0],
                     .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
                 })
                    .len))) {
          status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_DISTANCE;
          goto exit;
        }
      }
      wuffs_base__io_writer__copy_n_from_history_fast(
          &ioptr_dst, a_dst.private_impl.bounds[0], iobounds1_dst, v_length,
          (v_dist_minus_1 + 1));
      goto label_2_break;
    }
  label_2_break:;
  }
label_0_break:;
  while (v_n_bits >= 8) {
    v_n_bits -= 8;
    if (ioptr_src > iobounds0orig_src) {
      (ioptr_src--, wuffs_base__return_empty_struct());
    } else {
      status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_I_O;
      goto exit;
    }
  }
  self->private_impl.f_bits = (v_bits & ((((uint32_t)(1)) << v_n_bits) - 1));
  self->private_impl.f_n_bits = v_n_bits;
  if ((self->private_impl.f_n_bits >= 8) ||
      ((self->private_impl.f_bits >> self->private_impl.f_n_bits) != 0)) {
    status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
    goto exit;
  }
  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;
}

// -------- func deflate.decoder.decode_huffman_slow

static wuffs_base__status  //
wuffs_deflate__decoder__decode_huffman_slow(wuffs_deflate__decoder* self,
                                            wuffs_base__io_writer a_dst,
                                            wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_table_entry;
  uint32_t v_table_entry_n_bits;
  uint32_t v_lmask;
  uint32_t v_dmask;
  uint32_t v_redir_top;
  uint32_t v_redir_mask;
  uint32_t v_length;
  uint32_t v_dist_minus_1;
  uint32_t v_n_copied;
  uint32_t v_hlen;
  uint32_t v_hdist;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_huffman_slow[0].coro_susp_point;
  if (coro_susp_point) {
    v_bits = self->private_impl.c_decode_huffman_slow[0].v_bits;
    v_n_bits = self->private_impl.c_decode_huffman_slow[0].v_n_bits;
    v_table_entry = self->private_impl.c_decode_huffman_slow[0].v_table_entry;
    v_table_entry_n_bits =
        self->private_impl.c_decode_huffman_slow[0].v_table_entry_n_bits;
    v_lmask = self->private_impl.c_decode_huffman_slow[0].v_lmask;
    v_dmask = self->private_impl.c_decode_huffman_slow[0].v_dmask;
    v_redir_top = self->private_impl.c_decode_huffman_slow[0].v_redir_top;
    v_redir_mask = self->private_impl.c_decode_huffman_slow[0].v_redir_mask;
    v_length = self->private_impl.c_decode_huffman_slow[0].v_length;
    v_dist_minus_1 = self->private_impl.c_decode_huffman_slow[0].v_dist_minus_1;
    v_n_copied = self->private_impl.c_decode_huffman_slow[0].v_n_copied;
    v_hlen = self->private_impl.c_decode_huffman_slow[0].v_hlen;
    v_hdist = self->private_impl.c_decode_huffman_slow[0].v_hdist;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if ((self->private_impl.f_n_bits >= 8) ||
        ((self->private_impl.f_bits >> self->private_impl.f_n_bits) != 0)) {
      status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
      goto exit;
    }
    v_bits = self->private_impl.f_bits;
    v_n_bits = self->private_impl.f_n_bits;
    v_table_entry = 0;
    v_table_entry_n_bits = 0;
    v_lmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[0]) - 1);
    v_dmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[1]) - 1);
  label_0_continue:;
    while (true) {
      while (true) {
        v_table_entry = self->private_impl.f_huffs[0][(v_bits & v_lmask)];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_1_break;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_0)) << v_n_bits);
        }
        v_n_bits += 8;
      }
    label_1_break:;
      if ((v_table_entry >> 31) != 0) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (ioptr_dst == iobounds1_dst) {
          status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
        *ioptr_dst++ = ((uint8_t)(((v_table_entry >> 8) & 255)));
        goto label_0_continue;
      } else if ((v_table_entry >> 30) != 0) {
      } else if ((v_table_entry >> 29) != 0) {
        self->private_impl.f_end_of_block = true;
        goto label_0_break;
      } else if ((v_table_entry >> 28) != 0) {
        v_redir_top = ((v_table_entry >> 8) & 65535);
        v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
        while (true) {
          if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
            status =
                WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_table_entry =
              self->private_impl
                  .f_huffs[0][(v_redir_top + (v_bits & v_redir_mask))];
          v_table_entry_n_bits = (v_table_entry & 15);
          if (v_n_bits >= v_table_entry_n_bits) {
            v_bits >>= v_table_entry_n_bits;
            v_n_bits -= v_table_entry_n_bits;
            goto label_2_break;
          }
          {
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint8_t t_1 = *ioptr_src++;
            v_bits |= (((uint32_t)(t_1)) << v_n_bits);
          }
          v_n_bits += 8;
        }
      label_2_break:;
        if ((v_table_entry >> 31) != 0) {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (ioptr_dst == iobounds1_dst) {
            status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
            goto suspend;
          }
          *ioptr_dst++ = ((uint8_t)(((v_table_entry >> 8) & 255)));
          goto label_0_continue;
        } else if ((v_table_entry >> 30) != 0) {
        } else if ((v_table_entry >> 29) != 0) {
          self->private_impl.f_end_of_block = true;
          goto label_0_break;
        } else if ((v_table_entry >> 28) != 0) {
          status =
              WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        } else if ((v_table_entry >> 27) != 0) {
          status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
          goto exit;
        } else {
          status =
              WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
      } else if ((v_table_entry >> 27) != 0) {
        status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
        goto exit;
      } else {
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_length = ((v_table_entry >> 8) & 32767);
      v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
      if (v_table_entry_n_bits > 0) {
        while (v_n_bits < v_table_entry_n_bits) {
          {
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint8_t t_2 = *ioptr_src++;
            v_bits |= (((uint32_t)(t_2)) << v_n_bits);
          }
          v_n_bits += 8;
        }
        v_length =
            ((v_length + ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1))) &
             32767);
        v_bits >>= v_table_entry_n_bits;
        v_n_bits -= v_table_entry_n_bits;
      }
      while (true) {
        v_table_entry = self->private_impl.f_huffs[1][(v_bits & v_dmask)];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_3_break;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_3 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_3)) << v_n_bits);
        }
        v_n_bits += 8;
      }
    label_3_break:;
      if ((v_table_entry >> 28) == 1) {
        v_redir_top = ((v_table_entry >> 8) & 65535);
        v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
        while (true) {
          if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
            status =
                WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_table_entry =
              self->private_impl
                  .f_huffs[1][(v_redir_top + (v_bits & v_redir_mask))];
          v_table_entry_n_bits = (v_table_entry & 15);
          if (v_n_bits >= v_table_entry_n_bits) {
            v_bits >>= v_table_entry_n_bits;
            v_n_bits -= v_table_entry_n_bits;
            goto label_4_break;
          }
          {
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint8_t t_4 = *ioptr_src++;
            v_bits |= (((uint32_t)(t_4)) << v_n_bits);
          }
          v_n_bits += 8;
        }
      label_4_break:;
      }
      if ((v_table_entry >> 24) != 64) {
        if ((v_table_entry >> 24) == 8) {
          status = WUFFS_DEFLATE__ERROR_BAD_HUFFMAN_CODE;
          goto exit;
        }
        status =
            WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_dist_minus_1 = ((v_table_entry >> 8) & 32767);
      v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
      if (v_table_entry_n_bits > 0) {
        while (v_n_bits < v_table_entry_n_bits) {
          {
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint8_t t_5 = *ioptr_src++;
            v_bits |= (((uint32_t)(t_5)) << v_n_bits);
          }
          v_n_bits += 8;
        }
        v_dist_minus_1 = ((v_dist_minus_1 +
                           ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1))) &
                          32767);
        v_bits >>= v_table_entry_n_bits;
        v_n_bits -= v_table_entry_n_bits;
      }
      v_n_copied = 0;
      while (true) {
        if (((uint64_t)((v_dist_minus_1 + 1))) >
            ((uint64_t)(
                ((wuffs_base__slice_u8){
                     .ptr = a_dst.private_impl.bounds[0],
                     .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
                 })
                    .len))) {
          v_hlen = 0;
          v_hdist = ((uint32_t)(
              (((uint64_t)((v_dist_minus_1 + 1))) -
               ((uint64_t)(((wuffs_base__slice_u8){
                                .ptr = a_dst.private_impl.bounds[0],
                                .len = (size_t)(ioptr_dst -
                                                a_dst.private_impl.bounds[0]),
                            })
                               .len)))));
          if (v_length > v_hdist) {
            v_length -= v_hdist;
            v_hlen = v_hdist;
          } else {
            v_hlen = v_length;
            v_length = 0;
          }
          if (self->private_impl.f_history_index < v_hdist) {
            status = WUFFS_DEFLATE__ERROR_BAD_DISTANCE;
            goto exit;
          }
          v_hdist = (self->private_impl.f_history_index - v_hdist);
          while (true) {
            v_n_copied = wuffs_base__io_writer__copy_n_from_slice(
                &ioptr_dst, iobounds1_dst, v_hlen,
                wuffs_base__slice_u8__subslice_i(
                    ((wuffs_base__slice_u8){.ptr = self->private_impl.f_history,
                                            .len = 32768}),
                    (v_hdist & 32767)));
            if (v_hlen <= v_n_copied) {
              v_hlen = 0;
              goto label_5_break;
            }
            if (v_n_copied > 0) {
              v_hlen -= v_n_copied;
              v_hdist = ((v_hdist + v_n_copied) & 32767);
              if (v_hdist == 0) {
                goto label_5_break;
              }
            }
            status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(9);
          }
        label_5_break:;
          if (v_hlen > 0) {
            while (true) {
              v_n_copied = wuffs_base__io_writer__copy_n_from_slice(
                  &ioptr_dst, iobounds1_dst, v_hlen,
                  wuffs_base__slice_u8__subslice_i(
                      ((wuffs_base__slice_u8){
                          .ptr = self->private_impl.f_history, .len = 32768}),
                      (v_hdist & 32767)));
              if (v_hlen <= v_n_copied) {
                v_hlen = 0;
                goto label_6_break;
              }
              v_hlen -= v_n_copied;
              v_hdist += v_n_copied;
              status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
              WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(10);
            }
          label_6_break:;
          }
          if (v_length == 0) {
            goto label_0_continue;
          }
        }
        v_n_copied = wuffs_base__io_writer__copy_n_from_history(
            &ioptr_dst, a_dst.private_impl.bounds[0], iobounds1_dst, v_length,
            (v_dist_minus_1 + 1));
        if (v_length <= v_n_copied) {
          v_length = 0;
          goto label_7_break;
        }
        v_length -= v_n_copied;
        status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(11);
      }
    label_7_break:;
    }
  label_0_break:;
    self->private_impl.f_bits = v_bits;
    self->private_impl.f_n_bits = v_n_bits;
    if ((self->private_impl.f_n_bits >= 8) ||
        ((self->private_impl.f_bits >> self->private_impl.f_n_bits) != 0)) {
      status = WUFFS_DEFLATE__ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_huffman_slow[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_huffman_slow[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_huffman_slow[0].v_bits = v_bits;
  self->private_impl.c_decode_huffman_slow[0].v_n_bits = v_n_bits;
  self->private_impl.c_decode_huffman_slow[0].v_table_entry = v_table_entry;
  self->private_impl.c_decode_huffman_slow[0].v_table_entry_n_bits =
      v_table_entry_n_bits;
  self->private_impl.c_decode_huffman_slow[0].v_lmask = v_lmask;
  self->private_impl.c_decode_huffman_slow[0].v_dmask = v_dmask;
  self->private_impl.c_decode_huffman_slow[0].v_redir_top = v_redir_top;
  self->private_impl.c_decode_huffman_slow[0].v_redir_mask = v_redir_mask;
  self->private_impl.c_decode_huffman_slow[0].v_length = v_length;
  self->private_impl.c_decode_huffman_slow[0].v_dist_minus_1 = v_dist_minus_1;
  self->private_impl.c_decode_huffman_slow[0].v_n_copied = v_n_copied;
  self->private_impl.c_decode_huffman_slow[0].v_hlen = v_hlen;
  self->private_impl.c_decode_huffman_slow[0].v_hdist = v_hdist;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__DEFLATE)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__GIF)

// ---------------- Status Codes Implementations

static const char wuffs_gif__status__string_data[] = {
    0x00, 0x67, 0x69, 0x66, 0x3A, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E,
    0x61, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0x69, 0x6E,
    0x63, 0x6F, 0x6E, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x72,
    0x69, 0x2F, 0x77, 0x69, 0x00, 0x67, 0x69, 0x66, 0x3A, 0x20, 0x74, 0x6F,
    0x6F, 0x20, 0x6D, 0x75, 0x63, 0x68, 0x20, 0x70, 0x69, 0x78, 0x65, 0x6C,
    0x20, 0x64, 0x61, 0x74, 0x61, 0x00, 0x67, 0x69, 0x66, 0x3A, 0x20, 0x6E,
    0x6F, 0x74, 0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x70, 0x69,
    0x78, 0x65, 0x6C, 0x20, 0x64, 0x61, 0x74, 0x61, 0x00, 0x67, 0x69, 0x66,
    0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x6C, 0x69, 0x74, 0x65, 0x72, 0x61,
    0x6C, 0x20, 0x77, 0x69, 0x64, 0x74, 0x68, 0x00, 0x67, 0x69, 0x66, 0x3A,
    0x20, 0x62, 0x61, 0x64, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x00,
    0x67, 0x69, 0x66, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x67, 0x72, 0x61,
    0x70, 0x68, 0x69, 0x63, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 0x6F, 0x6C,
    0x00, 0x67, 0x69, 0x66, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x65, 0x78,
    0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6C, 0x61, 0x62, 0x65,
    0x6C, 0x00, 0x67, 0x69, 0x66, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x62,
    0x6C, 0x6F, 0x63, 0x6B, 0x00,
};

static const uint16_t wuffs_gif__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0029, 0x0042, 0x005D,
    0x0074, 0x0084, 0x009D, 0x00B6,
};

const char* wuffs_gif__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_gif__packageid:
      o = wuffs_gif__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_gif__status__string_data + o;
      }
      break;
    case wuffs_lzw__packageid:
      return wuffs_lzw__status__string(s);
  }
  return "unknown status";
}

// ---------------- Private Consts

static const uint32_t wuffs_gif__interlace_start[5] = {
    4294967295, 1, 2, 4, 0,
};

static const uint8_t wuffs_gif__interlace_delta[5] = {
    1, 2, 4, 8, 8,
};

static const uint8_t wuffs_gif__animexts1dot0[11] = {
    65, 78, 73, 77, 69, 88, 84, 83, 49, 46, 48,
};

static const uint8_t wuffs_gif__netscape2dot0[11] = {
    78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48,
};

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

static wuffs_base__status  //
wuffs_gif__decoder__skip_frame(wuffs_gif__decoder* self,
                               wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_up_to_id_part1(wuffs_gif__decoder* self,
                                          wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_header(wuffs_gif__decoder* self,
                                  wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_lsd(wuffs_gif__decoder* self,
                               wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_extension(wuffs_gif__decoder* self,
                                     wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__skip_blocks(wuffs_gif__decoder* self,
                                wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_ae(wuffs_gif__decoder* self,
                              wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_gc(wuffs_gif__decoder* self,
                              wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_id_part0(wuffs_gif__decoder* self,
                                    wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__decode_id_part1(wuffs_gif__decoder* self,
                                    wuffs_base__pixel_buffer* a_dst,
                                    wuffs_base__io_reader a_src);

static wuffs_base__status  //
wuffs_gif__decoder__copy_to_image_buffer(wuffs_gif__decoder* self,
                                         wuffs_base__pixel_buffer* a_pb);

// ---------------- Initializer Implementations

void wuffs_gif__decoder__check_wuffs_version(wuffs_gif__decoder* self,
                                             size_t sizeof_star_self,
                                             uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  wuffs_lzw__decoder__check_wuffs_version(&self->private_impl.f_lzw,
                                          sizeof(self->private_impl.f_lzw),
                                          WUFFS_VERSION);
}

// ---------------- Function Implementations

// -------- func gif.decoder.decode_image_config

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_image_config(wuffs_gif__decoder* self,
                                        wuffs_base__image_config* a_dst,
                                        wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_num_loops;
  bool v_ffio;

  uint32_t coro_susp_point =
      self->private_impl.c_decode_image_config[0].coro_susp_point;
  if (coro_susp_point) {
    v_num_loops = self->private_impl.c_decode_image_config[0].v_num_loops;
    v_ffio = self->private_impl.c_decode_image_config[0].v_ffio;
  } else {
    v_ffio = false;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence >= 1) {
      status = WUFFS_BASE__ERROR_INVALID_CALL_SEQUENCE;
      goto exit;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
    status = wuffs_gif__decoder__decode_header(self, a_src);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    status = wuffs_gif__decoder__decode_lsd(self, a_src);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
    status = wuffs_gif__decoder__decode_up_to_id_part1(self, a_src);
    if (status) {
      goto suspend;
    }
    v_num_loops = 1;
    if (self->private_impl.f_seen_num_loops) {
      v_num_loops = self->private_impl.f_num_loops;
    }
    v_ffio =
        (!self->private_impl.f_gc_has_transparent_index &&
         (self->private_impl.f_frame_rect_x0 == 0) &&
         (self->private_impl.f_frame_rect_y0 == 0) &&
         (self->private_impl.f_frame_rect_x1 == self->private_impl.f_width) &&
         (self->private_impl.f_frame_rect_y1 == self->private_impl.f_height) &&
         self->private_impl.f_has_full_palette);
    if (a_dst != NULL) {
      wuffs_base__image_config__initialize(
          a_dst, 570984584, 0, self->private_impl.f_width,
          self->private_impl.f_height, v_num_loops, v_ffio);
    }
    self->private_impl.f_call_sequence = 1;

    goto ok;
  ok:
    self->private_impl.c_decode_image_config[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_image_config[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_image_config[0].v_num_loops = v_num_loops;
  self->private_impl.c_decode_image_config[0].v_ffio = v_ffio;

  goto exit;
exit:
  self->private_impl.status = status;
  return status;
}

// -------- func gif.decoder.frame_count

WUFFS_BASE__MAYBE_STATIC uint64_t  //
wuffs_gif__decoder__frame_count(wuffs_gif__decoder* self) {
  if (!self) {
    return 0;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return 0;
  }

  return self->private_impl.f_frame_count_value;
}

// -------- func gif.decoder.work_buffer_size

WUFFS_BASE__MAYBE_STATIC wuffs_base__range_ii_u64  //
wuffs_gif__decoder__work_buffer_size(wuffs_gif__decoder* self) {
  if (!self) {
    return ((wuffs_base__range_ii_u64){});
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return ((wuffs_base__range_ii_u64){});
  }

  return wuffs_base__utility__make_range_ii_u64(&self->private_impl.f_util, 0,
                                                0);
}

// -------- func gif.decoder.decode_frame_config

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_frame_config(wuffs_gif__decoder* self,
                                        wuffs_base__frame_config* a_dst,
                                        wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t coro_susp_point =
      self->private_impl.c_decode_frame_config[0].coro_susp_point;
  if (coro_susp_point) {
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (!self->private_impl.f_end_of_data) {
      if (self->private_impl.f_call_sequence == 0) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        status = wuffs_gif__decoder__decode_image_config(self, NULL, a_src);
        if (status) {
          goto suspend;
        }
      } else if (self->private_impl.f_call_sequence == 1) {
      } else if (self->private_impl.f_call_sequence == 2) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        status = wuffs_gif__decoder__skip_frame(self, a_src);
        if (status) {
          goto suspend;
        }
      } else {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        status = wuffs_gif__decoder__decode_up_to_id_part1(self, a_src);
        if (status) {
          goto suspend;
        }
      }
    }
    if (self->private_impl.f_end_of_data) {
      while (true) {
        status = WUFFS_BASE__SUSPENSION_END_OF_DATA;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);
      }
    }
    if (self->private_impl.f_use_local_palette ||
        self->private_impl.f_gc_has_transparent_index) {
      self->private_impl.f_which_palette = 1;
    } else if (!self->private_impl.f_previous_use_global_palette) {
      self->private_impl.f_which_palette = 0;
    } else {
      self->private_impl.f_which_palette = 2;
    }
    self->private_impl.f_previous_use_global_palette =
        !(self->private_impl.f_use_local_palette ||
          self->private_impl.f_gc_has_transparent_index);
    if (a_dst != NULL) {
      wuffs_base__frame_config__update(
          a_dst,
          wuffs_base__utility__make_rect_ie_u32(
              &self->private_impl.f_util, self->private_impl.f_frame_rect_x0,
              self->private_impl.f_frame_rect_y0,
              self->private_impl.f_frame_rect_x1,
              self->private_impl.f_frame_rect_y1),
          self->private_impl.f_gc_duration, true,
          self->private_impl.f_gc_disposal,
          (self->private_impl.f_which_palette != 2));
    }
    self->private_impl.f_call_sequence = 2;

    goto ok;
  ok:
    self->private_impl.c_decode_frame_config[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_frame_config[0].coro_susp_point = coro_susp_point;

  goto exit;
exit:
  self->private_impl.status = status;
  return status;
}

// -------- func gif.decoder.skip_frame

static wuffs_base__status  //
wuffs_gif__decoder__skip_frame(wuffs_gif__decoder* self,
                               wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_lw;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_skip_frame[0].coro_susp_point;
  if (coro_susp_point) {
    v_lw = self->private_impl.c_skip_frame[0].v_lw;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_lw = t_0;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    if (a_src.private_impl.buf) {
      a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.private_impl.buf) {
      ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    }
    if (status) {
      goto suspend;
    }
    self->private_impl.f_seen_graphic_control = false;
    self->private_impl.f_gc_has_transparent_index = false;
    self->private_impl.f_gc_transparent_index = 0;
    self->private_impl.f_gc_disposal = 0;
    self->private_impl.f_gc_duration = 0;
    wuffs_base__u64__sat_add_indirect(&self->private_impl.f_frame_count_value,
                                      1);
    self->private_impl.f_call_sequence = 3;

    goto ok;
  ok:
    self->private_impl.c_skip_frame[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_skip_frame[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_skip_frame[0].v_lw = v_lw;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_frame

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gif__decoder__decode_frame(wuffs_gif__decoder* self,
                                 wuffs_base__pixel_buffer* a_dst,
                                 wuffs_base__io_reader a_src,
                                 wuffs_base__slice_u8 a_work_buffer,
                                 uint32_t a_pixbuf_origin_x,
                                 uint32_t a_pixbuf_origin_y) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  if (!a_dst) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_ARGUMENT;
    return WUFFS_BASE__ERROR_BAD_ARGUMENT;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t coro_susp_point =
      self->private_impl.c_decode_frame[0].coro_susp_point;
  if (coro_susp_point) {
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence != 2) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      status = wuffs_gif__decoder__decode_frame_config(self, NULL, a_src);
      if (status) {
        goto suspend;
      }
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    status = wuffs_gif__decoder__decode_id_part1(self, a_dst, a_src);
    if (status) {
      goto suspend;
    }
    self->private_impl.f_seen_graphic_control = false;
    self->private_impl.f_gc_has_transparent_index = false;
    self->private_impl.f_gc_transparent_index = 0;
    self->private_impl.f_gc_disposal = 0;
    self->private_impl.f_gc_duration = 0;
    wuffs_base__u64__sat_add_indirect(&self->private_impl.f_frame_count_value,
                                      1);
    self->private_impl.f_call_sequence = 3;

    goto ok;
  ok:
    self->private_impl.c_decode_frame[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_frame[0].coro_susp_point = coro_susp_point;

  goto exit;
exit:
  self->private_impl.status = status;
  return status;
}

// -------- func gif.decoder.decode_up_to_id_part1

static wuffs_base__status  //
wuffs_gif__decoder__decode_up_to_id_part1(wuffs_gif__decoder* self,
                                          wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_block_type;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point;
  if (coro_susp_point) {
    v_block_type = self->private_impl.c_decode_up_to_id_part1[0].v_block_type;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_type = t_0;
      }
      if (v_block_type == 33) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status = wuffs_gif__decoder__decode_extension(self, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
      } else if (v_block_type == 44) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status = wuffs_gif__decoder__decode_id_part0(self, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
        goto label_0_break;
      } else if (v_block_type == 59) {
        self->private_impl.f_end_of_data = true;
        goto label_0_break;
      } else {
        status = WUFFS_GIF__ERROR_BAD_BLOCK;
        goto exit;
      }
    }
  label_0_break:;

    goto ok;
  ok:
    self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point =
      coro_susp_point;
  self->private_impl.c_decode_up_to_id_part1[0].v_block_type = v_block_type;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_header

static wuffs_base__status  //
wuffs_gif__decoder__decode_header(wuffs_gif__decoder* self,
                                  wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_c[6];
  uint32_t v_i;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_header[0].coro_susp_point;
  if (coro_susp_point) {
    memcpy(v_c, self->private_impl.c_decode_header[0].v_c, sizeof(v_c));
    v_i = self->private_impl.c_decode_header[0].v_i;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    memset(v_c, 0, sizeof(v_c));
    v_i = 0;
    while (v_i < 6) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_c[v_i] = t_0;
      }
      v_i += 1;
    }
    if ((v_c[0] != 71) || (v_c[1] != 73) || (v_c[2] != 70) || (v_c[3] != 56) ||
        ((v_c[4] != 55) && (v_c[4] != 57)) || (v_c[5] != 97)) {
      status = WUFFS_GIF__ERROR_BAD_HEADER;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_header[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_header[0].coro_susp_point = coro_susp_point;
  memcpy(self->private_impl.c_decode_header[0].v_c, v_c, sizeof(v_c));
  self->private_impl.c_decode_header[0].v_i = v_i;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_lsd

static wuffs_base__status  //
wuffs_gif__decoder__decode_lsd(wuffs_gif__decoder* self,
                               wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_flags;
  uint32_t v_num_palette_entries;
  uint32_t v_i;
  uint32_t v_argb;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_lsd[0].coro_susp_point;
  if (coro_susp_point) {
    v_flags = self->private_impl.c_decode_lsd[0].v_flags;
    v_num_palette_entries =
        self->private_impl.c_decode_lsd[0].v_num_palette_entries;
    v_i = self->private_impl.c_decode_lsd[0].v_i;
    v_argb = self->private_impl.c_decode_lsd[0].v_argb;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint16_t t_1;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_1 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_lsd[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_lsd[0].scratch;
          uint32_t t_0 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_0;
          if (t_0 == 8) {
            t_1 = *scratch;
            break;
          }
          t_0 += 8;
          *scratch |= ((uint64_t)(t_0)) << 56;
        }
      }
      self->private_impl.f_width = ((uint32_t)(t_1));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_lsd[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_lsd[0].scratch;
          uint32_t t_2 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = *scratch;
            break;
          }
          t_2 += 8;
          *scratch |= ((uint64_t)(t_2)) << 56;
        }
      }
      self->private_impl.f_height = ((uint32_t)(t_3));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_4 = *ioptr_src++;
      v_flags = t_4;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
    self->private_impl.c_decode_lsd[0].scratch = 2;
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
    if (self->private_impl.c_decode_lsd[0].scratch >
        ((uint64_t)(iobounds1_src - ioptr_src))) {
      self->private_impl.c_decode_lsd[0].scratch -= iobounds1_src - ioptr_src;
      ioptr_src = iobounds1_src;
      goto short_read_src;
    }
    ioptr_src += self->private_impl.c_decode_lsd[0].scratch;
    if ((v_flags & 128) != 0) {
      v_num_palette_entries = (((uint32_t)(1)) << (1 + (v_flags & 7)));
      v_i = 0;
      while (v_i < v_num_palette_entries) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
          uint32_t t_6;
          if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 3)) {
            t_6 = wuffs_base__load_u24be(ioptr_src);
            ioptr_src += 3;
          } else {
            self->private_impl.c_decode_lsd[0].scratch = 0;
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
            while (true) {
              if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
                goto short_read_src;
              }
              uint64_t* scratch = &self->private_impl.c_decode_lsd[0].scratch;
              uint32_t t_5 = *scratch & 0xFF;
              *scratch >>= 8;
              *scratch <<= 8;
              *scratch |= ((uint64_t)(*ioptr_src++)) << (56 - t_5);
              if (t_5 == 16) {
                t_6 = *scratch >> (64 - 24);
                break;
              }
              t_5 += 8;
              *scratch |= ((uint64_t)(t_5));
            }
          }
          v_argb = (t_6 | 4278190080);
        }
        self->private_impl.f_palettes[0][((4 * v_i) + 0)] =
            ((uint8_t)(((v_argb >> 0) & 255)));
        self->private_impl.f_palettes[0][((4 * v_i) + 1)] =
            ((uint8_t)(((v_argb >> 8) & 255)));
        self->private_impl.f_palettes[0][((4 * v_i) + 2)] =
            ((uint8_t)(((v_argb >> 16) & 255)));
        self->private_impl.f_palettes[0][((4 * v_i) + 3)] =
            ((uint8_t)(((v_argb >> 24) & 255)));
        v_i += 1;
      }
      self->private_impl.f_has_full_global_palette = (v_i == 256);
      while (v_i < 256) {
        self->private_impl.f_palettes[0][((4 * v_i) + 0)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 1)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 2)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 3)] = 0;
        v_i += 1;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_lsd[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_lsd[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_lsd[0].v_flags = v_flags;
  self->private_impl.c_decode_lsd[0].v_num_palette_entries =
      v_num_palette_entries;
  self->private_impl.c_decode_lsd[0].v_i = v_i;
  self->private_impl.c_decode_lsd[0].v_argb = v_argb;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_extension

static wuffs_base__status  //
wuffs_gif__decoder__decode_extension(wuffs_gif__decoder* self,
                                     wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_label;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_extension[0].coro_susp_point;
  if (coro_susp_point) {
    v_label = self->private_impl.c_decode_extension[0].v_label;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_label = t_0;
    }
    if (v_label == 249) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_gif__decoder__decode_gc(self, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      status = WUFFS_BASE__STATUS_OK;
      goto ok;
    } else if (v_label == 255) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_gif__decoder__decode_ae(self, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      status = WUFFS_BASE__STATUS_OK;
      goto ok;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
    if (a_src.private_impl.buf) {
      a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.private_impl.buf) {
      ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_extension[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_extension[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_extension[0].v_label = v_label;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.skip_blocks

static wuffs_base__status  //
wuffs_gif__decoder__skip_blocks(wuffs_gif__decoder* self,
                                wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_block_size;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_skip_blocks[0].coro_susp_point;
  if (coro_susp_point) {
    v_block_size = self->private_impl.c_skip_blocks[0].v_block_size;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_BASE__STATUS_OK;
        goto ok;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      self->private_impl.c_skip_blocks[0].scratch = ((uint32_t)(v_block_size));
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (self->private_impl.c_skip_blocks[0].scratch >
          ((uint64_t)(iobounds1_src - ioptr_src))) {
        self->private_impl.c_skip_blocks[0].scratch -=
            iobounds1_src - ioptr_src;
        ioptr_src = iobounds1_src;
        goto short_read_src;
      }
      ioptr_src += self->private_impl.c_skip_blocks[0].scratch;
    }

    goto ok;
  ok:
    self->private_impl.c_skip_blocks[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_skip_blocks[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_skip_blocks[0].v_block_size = v_block_size;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_ae

static wuffs_base__status  //
wuffs_gif__decoder__decode_ae(wuffs_gif__decoder* self,
                              wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_c;
  uint8_t v_block_size;
  bool v_not_animexts;
  bool v_not_netscape;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_ae[0].coro_susp_point;
  if (coro_susp_point) {
    v_c = self->private_impl.c_decode_ae[0].v_c;
    v_block_size = self->private_impl.c_decode_ae[0].v_block_size;
    v_not_animexts = self->private_impl.c_decode_ae[0].v_not_animexts;
    v_not_netscape = self->private_impl.c_decode_ae[0].v_not_netscape;
  } else {
    v_not_animexts = false;
    v_not_netscape = false;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      v_c = 0;
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_BASE__STATUS_OK;
        goto ok;
      }
      if (v_block_size != 11) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (self->private_impl.c_decode_ae[0].scratch >
            ((uint64_t)(iobounds1_src - ioptr_src))) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      v_not_animexts = 0;
      v_not_netscape = 0;
      v_block_size = 0;
      while (v_block_size < 11) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *ioptr_src++;
          v_c = t_1;
        }
        v_not_animexts =
            (v_not_animexts || (v_c != wuffs_gif__animexts1dot0[v_block_size]));
        v_not_netscape =
            (v_not_netscape || (v_c != wuffs_gif__netscape2dot0[v_block_size]));
        v_block_size += 1;
      }
      if (v_not_animexts && v_not_netscape) {
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_2 = *ioptr_src++;
        v_block_size = t_2;
      }
      if (v_block_size != 3) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
        if (self->private_impl.c_decode_ae[0].scratch >
            ((uint64_t)(iobounds1_src - ioptr_src))) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_3 = *ioptr_src++;
        v_c = t_3;
      }
      if (v_c != 1) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
        self->private_impl.c_decode_ae[0].scratch = 2;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
        if (self->private_impl.c_decode_ae[0].scratch >
            ((uint64_t)(iobounds1_src - ioptr_src))) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
        uint16_t t_5;
        if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
          t_5 = wuffs_base__load_u16le(ioptr_src);
          ioptr_src += 2;
        } else {
          self->private_impl.c_decode_ae[0].scratch = 0;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(12);
          while (true) {
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint64_t* scratch = &self->private_impl.c_decode_ae[0].scratch;
            uint32_t t_4 = *scratch >> 56;
            *scratch <<= 8;
            *scratch >>= 8;
            *scratch |= ((uint64_t)(*ioptr_src++)) << t_4;
            if (t_4 == 8) {
              t_5 = *scratch;
              break;
            }
            t_4 += 8;
            *scratch |= ((uint64_t)(t_4)) << 56;
          }
        }
        self->private_impl.f_num_loops = ((uint32_t)(t_5));
      }
      self->private_impl.f_seen_num_loops = true;
      if ((0 < self->private_impl.f_num_loops) &&
          (self->private_impl.f_num_loops <= 65535)) {
        self->private_impl.f_num_loops += 1;
      }
      goto label_0_break;
    }
  label_0_break:;
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(13);
    if (a_src.private_impl.buf) {
      a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.private_impl.buf) {
      ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_ae[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_ae[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_ae[0].v_c = v_c;
  self->private_impl.c_decode_ae[0].v_block_size = v_block_size;
  self->private_impl.c_decode_ae[0].v_not_animexts = v_not_animexts;
  self->private_impl.c_decode_ae[0].v_not_netscape = v_not_netscape;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_gc

static wuffs_base__status  //
wuffs_gif__decoder__decode_gc(wuffs_gif__decoder* self,
                              wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_c;
  uint8_t v_flags;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_gc[0].coro_susp_point;
  if (coro_susp_point) {
    v_c = self->private_impl.c_decode_gc[0].v_c;
    v_flags = self->private_impl.c_decode_gc[0].v_flags;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_seen_graphic_control) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_c = t_0;
    }
    if (v_c != 4) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_1 = *ioptr_src++;
      v_flags = t_1;
    }
    self->private_impl.f_gc_has_transparent_index = ((v_flags & 1) != 0);
    v_flags = ((v_flags >> 2) & 7);
    if (v_flags == 2) {
      self->private_impl.f_gc_disposal = 1;
    } else if ((v_flags == 3) || (v_flags == 4)) {
      self->private_impl.f_gc_disposal = 2;
    } else {
      self->private_impl.f_gc_disposal = 0;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_gc[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_gc[0].scratch;
          uint32_t t_2 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = *scratch;
            break;
          }
          t_2 += 8;
          *scratch |= ((uint64_t)(t_2)) << 56;
        }
      }
      self->private_impl.f_gc_duration = (((uint64_t)(t_3)) * 7056000);
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_4 = *ioptr_src++;
      self->private_impl.f_gc_transparent_index = t_4;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_5 = *ioptr_src++;
      v_c = t_5;
    }
    if (v_c != 0) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    self->private_impl.f_seen_graphic_control = true;

    goto ok;
  ok:
    self->private_impl.c_decode_gc[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_gc[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_gc[0].v_c = v_c;
  self->private_impl.c_decode_gc[0].v_flags = v_flags;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_id_part0

static wuffs_base__status  //
wuffs_gif__decoder__decode_id_part0(wuffs_gif__decoder* self,
                                    wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_flags;
  uint32_t v_num_palette_entries;
  uint32_t v_i;
  uint32_t v_argb;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_id_part0[0].coro_susp_point;
  if (coro_susp_point) {
    v_flags = self->private_impl.c_decode_id_part0[0].v_flags;
    v_num_palette_entries =
        self->private_impl.c_decode_id_part0[0].v_num_palette_entries;
    v_i = self->private_impl.c_decode_id_part0[0].v_i;
    v_argb = self->private_impl.c_decode_id_part0[0].v_argb;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint16_t t_1;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_1 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_id_part0[0].scratch;
          uint32_t t_0 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_0;
          if (t_0 == 8) {
            t_1 = *scratch;
            break;
          }
          t_0 += 8;
          *scratch |= ((uint64_t)(t_0)) << 56;
        }
      }
      self->private_impl.f_frame_rect_x0 = ((uint32_t)(t_1));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_id_part0[0].scratch;
          uint32_t t_2 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = *scratch;
            break;
          }
          t_2 += 8;
          *scratch |= ((uint64_t)(t_2)) << 56;
        }
      }
      self->private_impl.f_frame_rect_y0 = ((uint32_t)(t_3));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      uint16_t t_5;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_5 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_id_part0[0].scratch;
          uint32_t t_4 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_4;
          if (t_4 == 8) {
            t_5 = *scratch;
            break;
          }
          t_4 += 8;
          *scratch |= ((uint64_t)(t_4)) << 56;
        }
      }
      self->private_impl.f_frame_rect_x1 =
          (self->private_impl.f_frame_rect_x0 + ((uint32_t)(t_5)));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
      uint16_t t_7;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_7 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode_id_part0[0].scratch;
          uint32_t t_6 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_6;
          if (t_6 == 8) {
            t_7 = *scratch;
            break;
          }
          t_6 += 8;
          *scratch |= ((uint64_t)(t_6)) << 56;
        }
      }
      self->private_impl.f_frame_rect_y1 =
          (self->private_impl.f_frame_rect_y0 + ((uint32_t)(t_7)));
    }
    self->private_impl.f_dst_x = self->private_impl.f_frame_rect_x0;
    self->private_impl.f_dst_y = self->private_impl.f_frame_rect_y0;
    if (self->private_impl.f_call_sequence == 0) {
      self->private_impl.f_width = wuffs_base__u32__max(
          self->private_impl.f_width, self->private_impl.f_frame_rect_x1);
      self->private_impl.f_height = wuffs_base__u32__max(
          self->private_impl.f_height, self->private_impl.f_frame_rect_y1);
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_8 = *ioptr_src++;
      v_flags = t_8;
    }
    if ((v_flags & 64) != 0) {
      self->private_impl.f_interlace = 4;
    } else {
      self->private_impl.f_interlace = 0;
    }
    self->private_impl.f_has_full_palette =
        self->private_impl.f_has_full_global_palette;
    self->private_impl.f_use_local_palette = ((v_flags & 128) != 0);
    if (self->private_impl.f_use_local_palette) {
      v_num_palette_entries = (((uint32_t)(1)) << (1 + (v_flags & 7)));
      v_i = 0;
      while (v_i < v_num_palette_entries) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
          uint32_t t_10;
          if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 3)) {
            t_10 = wuffs_base__load_u24be(ioptr_src);
            ioptr_src += 3;
          } else {
            self->private_impl.c_decode_id_part0[0].scratch = 0;
            WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
            while (true) {
              if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
                goto short_read_src;
              }
              uint64_t* scratch =
                  &self->private_impl.c_decode_id_part0[0].scratch;
              uint32_t t_9 = *scratch & 0xFF;
              *scratch >>= 8;
              *scratch <<= 8;
              *scratch |= ((uint64_t)(*ioptr_src++)) << (56 - t_9);
              if (t_9 == 16) {
                t_10 = *scratch >> (64 - 24);
                break;
              }
              t_9 += 8;
              *scratch |= ((uint64_t)(t_9));
            }
          }
          v_argb = (t_10 | 4278190080);
        }
        self->private_impl.f_palettes[1][((4 * v_i) + 0)] =
            ((uint8_t)(((v_argb >> 0) & 255)));
        self->private_impl.f_palettes[1][((4 * v_i) + 1)] =
            ((uint8_t)(((v_argb >> 8) & 255)));
        self->private_impl.f_palettes[1][((4 * v_i) + 2)] =
            ((uint8_t)(((v_argb >> 16) & 255)));
        self->private_impl.f_palettes[1][((4 * v_i) + 3)] =
            ((uint8_t)(((v_argb >> 24) & 255)));
        v_i += 1;
      }
      self->private_impl.f_has_full_palette = (v_i == 256);
      while (v_i < 256) {
        self->private_impl.f_palettes[1][((4 * v_i) + 0)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 1)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 2)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 3)] = 0;
        v_i += 1;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_id_part0[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_id_part0[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_id_part0[0].v_flags = v_flags;
  self->private_impl.c_decode_id_part0[0].v_num_palette_entries =
      v_num_palette_entries;
  self->private_impl.c_decode_id_part0[0].v_i = v_i;
  self->private_impl.c_decode_id_part0[0].v_argb = v_argb;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.decode_id_part1

static wuffs_base__status  //
wuffs_gif__decoder__decode_id_part1(wuffs_gif__decoder* self,
                                    wuffs_base__pixel_buffer* a_dst,
                                    wuffs_base__io_reader a_src) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_lw;
  uint64_t v_block_size;
  wuffs_base__io_writer v_w;
  wuffs_base__io_buffer u_w;
  uint8_t* ioptr_w = NULL;
  uint8_t* iobounds1_w = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(u_w);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(ioptr_w);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_w);
  wuffs_base__status v_z;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_id_part1[0].coro_susp_point;
  if (coro_susp_point) {
    v_lw = self->private_impl.c_decode_id_part1[0].v_lw;
    v_block_size = self->private_impl.c_decode_id_part1[0].v_block_size;
    v_w = ((wuffs_base__io_writer){});
    v_z = self->private_impl.c_decode_id_part1[0].v_z;
  } else {
    v_w = ((wuffs_base__io_writer){});
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_gc_has_transparent_index) {
      if (!self->private_impl.f_use_local_palette) {
        wuffs_base__slice_u8__copy_from_slice(
            ((wuffs_base__slice_u8){.ptr = self->private_impl.f_palettes[1],
                                    .len = 1024}),
            ((wuffs_base__slice_u8){.ptr = self->private_impl.f_palettes[0],
                                    .len = 1024}));
      }
      self->private_impl.f_palettes[1][(
          (4 * ((uint32_t)(self->private_impl.f_gc_transparent_index))) + 0)] =
          0;
      self->private_impl.f_palettes[1][(
          (4 * ((uint32_t)(self->private_impl.f_gc_transparent_index))) + 1)] =
          0;
      self->private_impl.f_palettes[1][(
          (4 * ((uint32_t)(self->private_impl.f_gc_transparent_index))) + 2)] =
          0;
      self->private_impl.f_palettes[1][(
          (4 * ((uint32_t)(self->private_impl.f_gc_transparent_index))) + 3)] =
          0;
    }
    wuffs_base__pixel_buffer__set_palette(
        a_dst,
        ((wuffs_base__slice_u8){.ptr = self->private_impl.f_palettes[(
                                    self->private_impl.f_which_palette & 1)],
                                .len = 1024}));
    if (self->private_impl.f_previous_lzw_decode_ended_abruptly) {
      (memset(&self->private_impl.f_lzw, 0, sizeof((wuffs_lzw__decoder){})),
       wuffs_lzw__decoder__check_wuffs_version(&self->private_impl.f_lzw,
                                               sizeof((wuffs_lzw__decoder){}),
                                               WUFFS_VERSION),
       wuffs_base__return_empty_struct());
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_lw = t_0;
    }
    if ((v_lw < 2) || (8 < v_lw)) {
      status = WUFFS_GIF__ERROR_BAD_LITERAL_WIDTH;
      goto exit;
    }
    wuffs_lzw__decoder__set_literal_width(&self->private_impl.f_lzw,
                                          ((uint32_t)(v_lw)));
    self->private_impl.f_previous_lzw_decode_ended_abruptly = true;
    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_1 = *ioptr_src++;
        v_block_size = ((uint64_t)(t_1));
      }
      if (v_block_size == 0) {
        goto label_0_break;
      }
      self->private_impl.f_previous_lzw_decode_ended_abruptly = true;
    label_1_continue:;
      while (true) {
        v_w = ((wuffs_base__io_writer){});
        {
          wuffs_base__io_reader o_0_a_src = a_src;
          wuffs_base__io_writer o_0_v_w = v_w;
          uint8_t* o_0_ioptr_v_w = ioptr_w;
          uint8_t* o_0_iobounds1_v_w = iobounds1_w;
          wuffs_base__io_writer__set(
              &v_w, &u_w, &ioptr_w, &iobounds1_w,
              wuffs_base__slice_u8__subslice_i(
                  ((wuffs_base__slice_u8){
                      .ptr = self->private_impl.f_uncompressed, .len = 4096}),
                  self->private_impl.f_uncompressed_wi));
          wuffs_base__io_reader__set_limit(&a_src, ioptr_src, v_block_size);
          wuffs_base__io_reader__set_mark(&a_src, ioptr_src);
          {
            u_w.wi = ioptr_w - u_w.ptr;
            if (a_src.private_impl.buf) {
              a_src.private_impl.buf->ri =
                  ioptr_src - a_src.private_impl.buf->ptr;
            }
            wuffs_base__status t_2 = wuffs_lzw__decoder__decode(
                &self->private_impl.f_lzw, v_w, a_src);
            ioptr_w = u_w.ptr + u_w.wi;
            if (a_src.private_impl.buf) {
              ioptr_src =
                  a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
            }
            v_z = t_2;
          }
          self->private_impl.f_uncompressed_wi =
              (4096 - ((uint32_t)(wuffs_base__u64__min(
                          ((uint64_t)(iobounds1_w - ioptr_w)), 4096))));
          wuffs_base__u64__sat_sub_indirect(
              &v_block_size,
              ((uint64_t)(((wuffs_base__slice_u8){
                               .ptr = a_src.private_impl.bounds[0],
                               .len = (size_t)(ioptr_src -
                                               a_src.private_impl.bounds[0]),
                           })
                              .len)));
          v_w = o_0_v_w;
          ioptr_w = o_0_ioptr_v_w;
          iobounds1_w = o_0_iobounds1_v_w;
          a_src = o_0_a_src;
        }
        if ((v_z == 0) || (v_z == WUFFS_BASE__SUSPENSION_SHORT_WRITE)) {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
          status = wuffs_gif__decoder__copy_to_image_buffer(self, a_dst);
          if (status) {
            goto suspend;
          }
          if (v_z == WUFFS_BASE__SUSPENSION_SHORT_WRITE) {
            goto label_1_continue;
          }
          self->private_impl.f_previous_lzw_decode_ended_abruptly = false;
          goto label_1_break;
        }
        if ((v_block_size == 0) && (v_z == WUFFS_BASE__SUSPENSION_SHORT_READ)) {
          goto label_1_break;
        }
        status = v_z;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);
      }
    label_1_break:;
    }
  label_0_break:;
    if (self->private_impl.f_uncompressed_ri !=
        self->private_impl.f_uncompressed_wi) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      status = wuffs_gif__decoder__copy_to_image_buffer(self, a_dst);
      if (status) {
        goto suspend;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_id_part1[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_id_part1[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_id_part1[0].v_lw = v_lw;
  self->private_impl.c_decode_id_part1[0].v_block_size = v_block_size;
  self->private_impl.c_decode_id_part1[0].v_z = v_z;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func gif.decoder.copy_to_image_buffer

static wuffs_base__status  //
wuffs_gif__decoder__copy_to_image_buffer(wuffs_gif__decoder* self,
                                         wuffs_base__pixel_buffer* a_pb) {
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  wuffs_base__slice_u8 v_dst;
  wuffs_base__slice_u8 v_src;
  uint32_t v_n;
  uint32_t v_new_ri;
  wuffs_base__table_u8 v_tab;

  v_dst = ((wuffs_base__slice_u8){});
  v_src = ((wuffs_base__slice_u8){});
  v_n = 0;
  v_new_ri = 0;
  v_tab = wuffs_base__pixel_buffer__plane(a_pb, 0);
label_0_continue:;
  while (self->private_impl.f_uncompressed_wi >
         self->private_impl.f_uncompressed_ri) {
    v_src = wuffs_base__slice_u8__subslice_ij(
        ((wuffs_base__slice_u8){.ptr = self->private_impl.f_uncompressed,
                                .len = 4096}),
        self->private_impl.f_uncompressed_ri,
        self->private_impl.f_uncompressed_wi);
    if (self->private_impl.f_dst_y >= self->private_impl.f_frame_rect_y1) {
      status = WUFFS_GIF__ERROR_TOO_MUCH_PIXEL_DATA;
      goto exit;
    }
    v_dst = wuffs_base__table_u8__row(v_tab, self->private_impl.f_dst_y);
    if (((uint64_t)(self->private_impl.f_dst_x)) < ((uint64_t)(v_dst.len))) {
      if ((((uint64_t)(self->private_impl.f_dst_x)) <=
           ((uint64_t)(self->private_impl.f_frame_rect_x1))) &&
          (((uint64_t)(self->private_impl.f_frame_rect_x1)) <=
           ((uint64_t)(v_dst.len)))) {
        v_dst = wuffs_base__slice_u8__subslice_ij(
            v_dst, ((uint64_t)(self->private_impl.f_dst_x)),
            ((uint64_t)(self->private_impl.f_frame_rect_x1)));
      } else {
        v_dst = wuffs_base__slice_u8__subslice_i(
            v_dst, ((uint64_t)(self->private_impl.f_dst_x)));
      }
      v_n = ((uint32_t)(
          (wuffs_base__slice_u8__copy_from_slice(v_dst, v_src) & 4294967295)));
      v_new_ri =
          wuffs_base__u32__sat_add(self->private_impl.f_uncompressed_ri, v_n);
      self->private_impl.f_uncompressed_ri =
          wuffs_base__u32__min(v_new_ri, 4096);
      wuffs_base__u32__sat_add_indirect(&self->private_impl.f_dst_x, v_n);
    }
    if (self->private_impl.f_frame_rect_x1 <= self->private_impl.f_dst_x) {
      self->private_impl.f_dst_x = self->private_impl.f_frame_rect_x0;
      wuffs_base__u32__sat_add_indirect(
          &self->private_impl.f_dst_y,
          ((uint32_t)(
              wuffs_gif__interlace_delta[self->private_impl.f_interlace])));
      while (
          (self->private_impl.f_interlace > 0) &&
          (self->private_impl.f_dst_y >= self->private_impl.f_frame_rect_y1)) {
        self->private_impl.f_interlace -= 1;
        self->private_impl.f_dst_y = wuffs_base__u32__sat_add(
            self->private_impl.f_frame_rect_y0,
            wuffs_gif__interlace_start[self->private_impl.f_interlace]);
      }
      goto label_0_continue;
    }
    if (self->private_impl.f_uncompressed_wi ==
        self->private_impl.f_uncompressed_ri) {
      goto label_0_break;
    } else if (self->private_impl.f_uncompressed_wi <
               self->private_impl.f_uncompressed_ri) {
      status = WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI;
      goto exit;
    }
    v_n = (self->private_impl.f_frame_rect_x1 - self->private_impl.f_dst_x);
    v_n = wuffs_base__u32__min(v_n, (self->private_impl.f_uncompressed_wi -
                                     self->private_impl.f_uncompressed_ri));
    v_new_ri =
        wuffs_base__u32__sat_add(self->private_impl.f_uncompressed_ri, v_n);
    self->private_impl.f_uncompressed_ri = wuffs_base__u32__min(v_new_ri, 4096);
    wuffs_base__u32__sat_add_indirect(&self->private_impl.f_dst_x, v_n);
    if (self->private_impl.f_frame_rect_x1 <= self->private_impl.f_dst_x) {
      self->private_impl.f_dst_x = self->private_impl.f_frame_rect_x0;
      wuffs_base__u32__sat_add_indirect(
          &self->private_impl.f_dst_y,
          ((uint32_t)(
              wuffs_gif__interlace_delta[self->private_impl.f_interlace])));
      while (
          (self->private_impl.f_interlace > 0) &&
          (self->private_impl.f_dst_y >= self->private_impl.f_frame_rect_y1)) {
        self->private_impl.f_interlace -= 1;
        self->private_impl.f_dst_y = wuffs_base__u32__sat_add(
            self->private_impl.f_frame_rect_y0,
            wuffs_gif__interlace_start[self->private_impl.f_interlace]);
      }
      goto label_0_continue;
    }
    if (self->private_impl.f_uncompressed_ri !=
        self->private_impl.f_uncompressed_wi) {
      status = WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI;
      goto exit;
    }
    goto label_0_break;
  }
label_0_break:;
  self->private_impl.f_uncompressed_ri = 0;
  self->private_impl.f_uncompressed_wi = 0;
  goto exit;
exit:
  return status;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__GIF)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__GZIP)

// ---------------- Status Codes Implementations

static const char wuffs_gzip__status__string_data[] = {
    0x00, 0x67, 0x7A, 0x69, 0x70, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x68,
    0x65, 0x61, 0x64, 0x65, 0x72, 0x00, 0x67, 0x7A, 0x69, 0x70, 0x3A, 0x20,
    0x62, 0x61, 0x64, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67,
    0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x00, 0x67, 0x7A, 0x69, 0x70, 0x3A,
    0x20, 0x62, 0x61, 0x64, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x72, 0x65, 0x73,
    0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x00,
    0x67, 0x7A, 0x69, 0x70, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x63, 0x68,
    0x65, 0x63, 0x6B, 0x73, 0x75, 0x6D, 0x00,
};

static const uint16_t wuffs_gzip__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0012, 0x002B, 0x0048,
};

const char* wuffs_gzip__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_gzip__packageid:
      o = wuffs_gzip__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_gzip__status__string_data + o;
      }
      break;
    case wuffs_crc32__packageid:
      return wuffs_crc32__status__string(s);
    case wuffs_deflate__packageid:
      return wuffs_deflate__status__string(s);
  }
  return "unknown status";
}

// ---------------- Private Consts

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

// ---------------- Initializer Implementations

void wuffs_gzip__decoder__check_wuffs_version(wuffs_gzip__decoder* self,
                                              size_t sizeof_star_self,
                                              uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  wuffs_deflate__decoder__check_wuffs_version(
      &self->private_impl.f_flate, sizeof(self->private_impl.f_flate),
      WUFFS_VERSION);
  wuffs_crc32__ieee_hasher__check_wuffs_version(
      &self->private_impl.f_checksum, sizeof(self->private_impl.f_checksum),
      WUFFS_VERSION);
}

// ---------------- Function Implementations

// -------- func gzip.decoder.set_ignore_checksum

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_gzip__decoder__set_ignore_checksum(wuffs_gzip__decoder* self, bool a_ic) {
  if (!self) {
    return;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return;
  }

  self->private_impl.f_ignore_checksum = a_ic;
}

// -------- func gzip.decoder.decode

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_gzip__decoder__decode(wuffs_gzip__decoder* self,
                            wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint8_t v_c;
  uint8_t v_flags;
  uint16_t v_xlen;
  uint32_t v_checksum_got;
  uint32_t v_decoded_length_got;
  wuffs_base__status v_z;
  uint32_t v_checksum_want;
  uint32_t v_decoded_length_want;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_c = self->private_impl.c_decode[0].v_c;
    v_flags = self->private_impl.c_decode[0].v_flags;
    v_xlen = self->private_impl.c_decode[0].v_xlen;
    v_checksum_got = self->private_impl.c_decode[0].v_checksum_got;
    v_decoded_length_got = self->private_impl.c_decode[0].v_decoded_length_got;
    v_z = self->private_impl.c_decode[0].v_z;
    v_checksum_want = self->private_impl.c_decode[0].v_checksum_want;
    v_decoded_length_want =
        self->private_impl.c_decode[0].v_decoded_length_want;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_c = t_0;
    }
    if (v_c != 31) {
      status = WUFFS_GZIP__ERROR_BAD_HEADER;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_1 = *ioptr_src++;
      v_c = t_1;
    }
    if (v_c != 139) {
      status = WUFFS_GZIP__ERROR_BAD_HEADER;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_2 = *ioptr_src++;
      v_c = t_2;
    }
    if (v_c != 8) {
      status = WUFFS_GZIP__ERROR_BAD_COMPRESSION_METHOD;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_3 = *ioptr_src++;
      v_flags = t_3;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
    self->private_impl.c_decode[0].scratch = 6;
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
    if (self->private_impl.c_decode[0].scratch >
        ((uint64_t)(iobounds1_src - ioptr_src))) {
      self->private_impl.c_decode[0].scratch -= iobounds1_src - ioptr_src;
      ioptr_src = iobounds1_src;
      goto short_read_src;
    }
    ioptr_src += self->private_impl.c_decode[0].scratch;
    if ((v_flags & 4) != 0) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
        uint16_t t_5;
        if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
          t_5 = wuffs_base__load_u16le(ioptr_src);
          ioptr_src += 2;
        } else {
          self->private_impl.c_decode[0].scratch = 0;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
          while (true) {
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint64_t* scratch = &self->private_impl.c_decode[0].scratch;
            uint32_t t_4 = *scratch >> 56;
            *scratch <<= 8;
            *scratch >>= 8;
            *scratch |= ((uint64_t)(*ioptr_src++)) << t_4;
            if (t_4 == 8) {
              t_5 = *scratch;
              break;
            }
            t_4 += 8;
            *scratch |= ((uint64_t)(t_4)) << 56;
          }
        }
        v_xlen = t_5;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
      self->private_impl.c_decode[0].scratch = ((uint32_t)(v_xlen));
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
      if (self->private_impl.c_decode[0].scratch >
          ((uint64_t)(iobounds1_src - ioptr_src))) {
        self->private_impl.c_decode[0].scratch -= iobounds1_src - ioptr_src;
        ioptr_src = iobounds1_src;
        goto short_read_src;
      }
      ioptr_src += self->private_impl.c_decode[0].scratch;
    }
    if ((v_flags & 8) != 0) {
      while (true) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_6 = *ioptr_src++;
          v_c = t_6;
        }
        if (v_c == 0) {
          goto label_0_break;
        }
      }
    label_0_break:;
    }
    if ((v_flags & 16) != 0) {
      while (true) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(12);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_7 = *ioptr_src++;
          v_c = t_7;
        }
        if (v_c == 0) {
          goto label_1_break;
        }
      }
    label_1_break:;
    }
    if ((v_flags & 2) != 0) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(13);
      self->private_impl.c_decode[0].scratch = 2;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(14);
      if (self->private_impl.c_decode[0].scratch >
          ((uint64_t)(iobounds1_src - ioptr_src))) {
        self->private_impl.c_decode[0].scratch -= iobounds1_src - ioptr_src;
        ioptr_src = iobounds1_src;
        goto short_read_src;
      }
      ioptr_src += self->private_impl.c_decode[0].scratch;
    }
    if ((v_flags & 224) != 0) {
      status = WUFFS_GZIP__ERROR_BAD_ENCODING_FLAGS;
      goto exit;
    }
    v_checksum_got = 0;
    v_decoded_length_got = 0;
    while (true) {
      wuffs_base__io_writer__set_mark(&a_dst, ioptr_dst);
      {
        if (a_dst.private_impl.buf) {
          a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
        }
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        wuffs_base__status t_8 = wuffs_deflate__decoder__decode(
            &self->private_impl.f_flate, a_dst, a_src);
        if (a_dst.private_impl.buf) {
          ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
        }
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        v_z = t_8;
      }
      if (!self->private_impl.f_ignore_checksum) {
        v_checksum_got = wuffs_crc32__ieee_hasher__update(
            &self->private_impl.f_checksum,
            ((wuffs_base__slice_u8){
                .ptr = a_dst.private_impl.bounds[0],
                .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
            }));
        v_decoded_length_got += ((uint32_t)(
            (((uint64_t)(
                 ((wuffs_base__slice_u8){
                      .ptr = a_dst.private_impl.bounds[0],
                      .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
                  })
                     .len)) &
             4294967295)));
      }
      if (v_z == 0) {
        goto label_2_break;
      }
      status = v_z;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(15);
    }
  label_2_break:;
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(16);
      uint32_t t_10;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 4)) {
        t_10 = wuffs_base__load_u32le(ioptr_src);
        ioptr_src += 4;
      } else {
        self->private_impl.c_decode[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(17);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode[0].scratch;
          uint32_t t_9 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_9;
          if (t_9 == 24) {
            t_10 = *scratch;
            break;
          }
          t_9 += 8;
          *scratch |= ((uint64_t)(t_9)) << 56;
        }
      }
      v_checksum_want = t_10;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(18);
      uint32_t t_12;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 4)) {
        t_12 = wuffs_base__load_u32le(ioptr_src);
        ioptr_src += 4;
      } else {
        self->private_impl.c_decode[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(19);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode[0].scratch;
          uint32_t t_11 = *scratch >> 56;
          *scratch <<= 8;
          *scratch >>= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << t_11;
          if (t_11 == 24) {
            t_12 = *scratch;
            break;
          }
          t_11 += 8;
          *scratch |= ((uint64_t)(t_11)) << 56;
        }
      }
      v_decoded_length_want = t_12;
    }
    if (!self->private_impl.f_ignore_checksum &&
        ((v_checksum_got != v_checksum_want) ||
         (v_decoded_length_got != v_decoded_length_want))) {
      status = WUFFS_GZIP__ERROR_BAD_CHECKSUM;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_c = v_c;
  self->private_impl.c_decode[0].v_flags = v_flags;
  self->private_impl.c_decode[0].v_xlen = v_xlen;
  self->private_impl.c_decode[0].v_checksum_got = v_checksum_got;
  self->private_impl.c_decode[0].v_decoded_length_got = v_decoded_length_got;
  self->private_impl.c_decode[0].v_z = v_z;
  self->private_impl.c_decode[0].v_checksum_want = v_checksum_want;
  self->private_impl.c_decode[0].v_decoded_length_want = v_decoded_length_want;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__GZIP)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__LZW)

// ---------------- Status Codes Implementations

static const char wuffs_lzw__status__string_data[] = {
    0x00, 0x6C, 0x7A, 0x77, 0x3A, 0x20, 0x63, 0x79, 0x63, 0x6C, 0x69,
    0x63, 0x61, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20,
    0x63, 0x68, 0x61, 0x69, 0x6E, 0x00, 0x6C, 0x7A, 0x77, 0x3A, 0x20,
    0x62, 0x61, 0x64, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x00,
};

static const uint16_t wuffs_lzw__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0001, 0x001C,
};

const char* wuffs_lzw__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_lzw__packageid:
      o = wuffs_lzw__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_lzw__status__string_data + o;
      }
      break;
  }
  return "unknown status";
}

// ---------------- Private Consts

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

// ---------------- Initializer Implementations

void wuffs_lzw__decoder__check_wuffs_version(wuffs_lzw__decoder* self,
                                             size_t sizeof_star_self,
                                             uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
}

// ---------------- Function Implementations

// -------- func lzw.decoder.set_literal_width

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_lzw__decoder__set_literal_width(wuffs_lzw__decoder* self, uint32_t a_lw) {
  if (!self) {
    return;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return;
  }
  if (a_lw < 2 || a_lw > 8) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_ARGUMENT;
    return;
  }

  self->private_impl.f_literal_width = a_lw;
}

// -------- func lzw.decoder.decode

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_lzw__decoder__decode(wuffs_lzw__decoder* self,
                           wuffs_base__io_writer a_dst,
                           wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint32_t v_literal_width;
  uint32_t v_clear_code;
  uint32_t v_end_code;
  uint32_t v_save_code;
  uint32_t v_prev_code;
  uint32_t v_width;
  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_code;
  uint32_t v_s;
  uint32_t v_c;
  wuffs_base__slice_u8 v_expansion;
  uint64_t v_n_copied;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_literal_width = self->private_impl.c_decode[0].v_literal_width;
    v_clear_code = self->private_impl.c_decode[0].v_clear_code;
    v_end_code = self->private_impl.c_decode[0].v_end_code;
    v_save_code = self->private_impl.c_decode[0].v_save_code;
    v_prev_code = self->private_impl.c_decode[0].v_prev_code;
    v_width = self->private_impl.c_decode[0].v_width;
    v_bits = self->private_impl.c_decode[0].v_bits;
    v_n_bits = self->private_impl.c_decode[0].v_n_bits;
    v_code = self->private_impl.c_decode[0].v_code;
    v_s = self->private_impl.c_decode[0].v_s;
    v_c = self->private_impl.c_decode[0].v_c;
    v_expansion = ((wuffs_base__slice_u8){});
    v_n_copied = self->private_impl.c_decode[0].v_n_copied;
  } else {
    v_expansion = ((wuffs_base__slice_u8){});
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_literal_width = 8;
    if (self->private_impl.f_literal_width >= 2) {
      v_literal_width = self->private_impl.f_literal_width;
    }
    v_clear_code = (((uint32_t)(1)) << v_literal_width);
    v_end_code = (v_clear_code + 1);
    v_save_code = v_end_code;
    v_prev_code = 0;
    v_width = (v_literal_width + 1);
    v_bits = 0;
    v_n_bits = 0;
    while (true) {
      while (v_n_bits < v_width) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_0)) << v_n_bits);
        }
        v_n_bits += 8;
      }
      v_code = ((v_bits) & ((1 << (v_width)) - 1));
      v_bits >>= v_width;
      v_n_bits -= v_width;
      if (v_code < v_clear_code) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (ioptr_dst == iobounds1_dst) {
          status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
        *ioptr_dst++ = ((uint8_t)(v_code));
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_code));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
          v_save_code += 1;
          if ((v_save_code == (((uint32_t)(1)) << v_width)) && (v_width < 12)) {
            v_width += 1;
          }
          v_prev_code = v_code;
        }
      } else if (v_code <= v_end_code) {
        if (v_code == v_end_code) {
          status = WUFFS_BASE__STATUS_OK;
          goto ok;
        }
        v_save_code = v_end_code;
        v_prev_code = 0;
        v_width = (v_literal_width + 1);
      } else if (v_code <= v_save_code) {
        v_s = 4095;
        v_c = v_code;
        if (v_code == v_save_code) {
          v_s -= 1;
          v_c = v_prev_code;
        }
        while (v_c >= v_clear_code) {
          self->private_impl.f_stack[v_s] = self->private_impl.f_suffixes[v_c];
          if (v_s == 0) {
            status = WUFFS_LZW__ERROR_CYCLICAL_PREFIX_CHAIN;
            goto exit;
          }
          v_s -= 1;
          v_c = ((uint32_t)(self->private_impl.f_prefixes[v_c]));
        }
        self->private_impl.f_stack[v_s] = ((uint8_t)(v_c));
        if (v_code == v_save_code) {
          self->private_impl.f_stack[4095] = ((uint8_t)(v_c));
        }
        while (true) {
          v_expansion = wuffs_base__slice_u8__subslice_i(
              ((wuffs_base__slice_u8){.ptr = self->private_impl.f_stack,
                                      .len = 4096}),
              v_s);
          v_n_copied = wuffs_base__io_writer__copy_from_slice(
              &ioptr_dst, iobounds1_dst, v_expansion);
          if (v_n_copied == ((uint64_t)(v_expansion.len))) {
            goto label_0_break;
          }
          v_s = ((v_s + ((uint32_t)((v_n_copied & 4095)))) & 4095);
          status = WUFFS_BASE__SUSPENSION_SHORT_WRITE;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);
        }
      label_0_break:;
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_c));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
          v_save_code += 1;
          if ((v_save_code == (((uint32_t)(1)) << v_width)) && (v_width < 12)) {
            v_width += 1;
          }
          v_prev_code = v_code;
        }
      } else {
        status = WUFFS_LZW__ERROR_BAD_CODE;
        goto exit;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_literal_width = v_literal_width;
  self->private_impl.c_decode[0].v_clear_code = v_clear_code;
  self->private_impl.c_decode[0].v_end_code = v_end_code;
  self->private_impl.c_decode[0].v_save_code = v_save_code;
  self->private_impl.c_decode[0].v_prev_code = v_prev_code;
  self->private_impl.c_decode[0].v_width = v_width;
  self->private_impl.c_decode[0].v_bits = v_bits;
  self->private_impl.c_decode[0].v_n_bits = v_n_bits;
  self->private_impl.c_decode[0].v_code = v_code;
  self->private_impl.c_decode[0].v_s = v_s;
  self->private_impl.c_decode[0].v_c = v_c;
  self->private_impl.c_decode[0].v_n_copied = v_n_copied;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__LZW)

#if !defined(WUFFS_CONFIG__MODULES) || defined(WUFFS_CONFIG__MODULE__ZLIB)

// ---------------- Status Codes Implementations

static const char wuffs_zlib__status__string_data[] = {
    0x00, 0x7A, 0x6C, 0x69, 0x62, 0x3A, 0x20, 0x54, 0x4F, 0x44, 0x4F, 0x3A,
    0x20, 0x75, 0x6E, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64,
    0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20, 0x64, 0x69, 0x63, 0x74,
    0x69, 0x6F, 0x6E, 0x61, 0x72, 0x79, 0x00, 0x7A, 0x6C, 0x69, 0x62, 0x3A,
    0x20, 0x62, 0x61, 0x64, 0x20, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79, 0x20,
    0x63, 0x68, 0x65, 0x63, 0x6B, 0x00, 0x7A, 0x6C, 0x69, 0x62, 0x3A, 0x20,
    0x62, 0x61, 0x64, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x72, 0x65, 0x73, 0x73,
    0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x20, 0x73,
    0x69, 0x7A, 0x65, 0x00, 0x7A, 0x6C, 0x69, 0x62, 0x3A, 0x20, 0x62, 0x61,
    0x64, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F,
    0x6E, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x00, 0x7A, 0x6C, 0x69,
    0x62, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B,
    0x73, 0x75, 0x6D, 0x00,
};

static const uint16_t wuffs_zlib__status__string_offsets[] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x002B, 0x0042, 0x0064, 0x0081,
};

const char* wuffs_zlib__status__string(wuffs_base__status s) {
  uint16_t o;
  switch (s & 0x1FFFFF) {
    case 0:
      return wuffs_base__status__string(s);
    case wuffs_zlib__packageid:
      o = wuffs_zlib__status__string_offsets[(uint8_t)(s >> 24)];
      if (o) {
        return wuffs_zlib__status__string_data + o;
      }
      break;
    case wuffs_adler32__packageid:
      return wuffs_adler32__status__string(s);
    case wuffs_deflate__packageid:
      return wuffs_deflate__status__string(s);
  }
  return "unknown status";
}

// ---------------- Private Consts

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

// ---------------- Initializer Implementations

void wuffs_zlib__decoder__check_wuffs_version(wuffs_zlib__decoder* self,
                                              size_t sizeof_star_self,
                                              uint64_t wuffs_version) {
  if (!self) {
    return;
  }
  if (sizeof(*self) != sizeof_star_self) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_SIZEOF_RECEIVER;
    return;
  }
  if (((wuffs_version >> 32) != WUFFS_VERSION_MAJOR) ||
      (((wuffs_version >> 16) & 0xFFFF) > WUFFS_VERSION_MINOR)) {
    self->private_impl.status = WUFFS_BASE__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (self->private_impl.magic != 0) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_CALLED_TWICE;
    return;
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  wuffs_deflate__decoder__check_wuffs_version(
      &self->private_impl.f_flate, sizeof(self->private_impl.f_flate),
      WUFFS_VERSION);
  wuffs_adler32__hasher__check_wuffs_version(
      &self->private_impl.f_checksum, sizeof(self->private_impl.f_checksum),
      WUFFS_VERSION);
}

// ---------------- Function Implementations

// -------- func zlib.decoder.set_ignore_checksum

WUFFS_BASE__MAYBE_STATIC void  //
wuffs_zlib__decoder__set_ignore_checksum(wuffs_zlib__decoder* self, bool a_ic) {
  if (!self) {
    return;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return;
  }

  self->private_impl.f_ignore_checksum = a_ic;
}

// -------- func zlib.decoder.decode

WUFFS_BASE__MAYBE_STATIC wuffs_base__status  //
wuffs_zlib__decoder__decode(wuffs_zlib__decoder* self,
                            wuffs_base__io_writer a_dst,
                            wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_BASE__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status =
        WUFFS_BASE__ERROR_CHECK_WUFFS_VERSION_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_base__status status = WUFFS_BASE__STATUS_OK;

  uint16_t v_x;
  uint32_t v_checksum_got;
  wuffs_base__status v_z;
  uint32_t v_checksum_want;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_x = self->private_impl.c_decode[0].v_x;
    v_checksum_got = self->private_impl.c_decode[0].v_checksum_got;
    v_z = self->private_impl.c_decode[0].v_z;
    v_checksum_want = self->private_impl.c_decode[0].v_checksum_want;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint16_t t_1;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_1 = wuffs_base__load_u16be(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode[0].scratch;
          uint32_t t_0 = *scratch & 0xFF;
          *scratch >>= 8;
          *scratch <<= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << (56 - t_0);
          if (t_0 == 8) {
            t_1 = *scratch >> (64 - 16);
            break;
          }
          t_0 += 8;
          *scratch |= ((uint64_t)(t_0));
        }
      }
      v_x = t_1;
    }
    if (((v_x >> 8) & 15) != 8) {
      status = WUFFS_ZLIB__ERROR_BAD_COMPRESSION_METHOD;
      goto exit;
    }
    if ((v_x >> 12) > 7) {
      status = WUFFS_ZLIB__ERROR_BAD_COMPRESSION_WINDOW_SIZE;
      goto exit;
    }
    if ((v_x & 32) != 0) {
      status = WUFFS_ZLIB__ERROR_TODO_UNSUPPORTED_PRESET_DICTIONARY;
      goto exit;
    }
    if ((v_x % 31) != 0) {
      status = WUFFS_ZLIB__ERROR_BAD_PARITY_CHECK;
      goto exit;
    }
    v_checksum_got = 0;
    while (true) {
      wuffs_base__io_writer__set_mark(&a_dst, ioptr_dst);
      {
        if (a_dst.private_impl.buf) {
          a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
        }
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        wuffs_base__status t_2 = wuffs_deflate__decoder__decode(
            &self->private_impl.f_flate, a_dst, a_src);
        if (a_dst.private_impl.buf) {
          ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
        }
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        v_z = t_2;
      }
      if (!self->private_impl.f_ignore_checksum) {
        v_checksum_got = wuffs_adler32__hasher__update(
            &self->private_impl.f_checksum,
            ((wuffs_base__slice_u8){
                .ptr = a_dst.private_impl.bounds[0],
                .len = (size_t)(ioptr_dst - a_dst.private_impl.bounds[0]),
            }));
      }
      if (v_z == 0) {
        goto label_0_break;
      }
      status = v_z;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);
    }
  label_0_break:;
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
      uint32_t t_4;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 4)) {
        t_4 = wuffs_base__load_u32be(ioptr_src);
        ioptr_src += 4;
      } else {
        self->private_impl.c_decode[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint64_t* scratch = &self->private_impl.c_decode[0].scratch;
          uint32_t t_3 = *scratch & 0xFF;
          *scratch >>= 8;
          *scratch <<= 8;
          *scratch |= ((uint64_t)(*ioptr_src++)) << (56 - t_3);
          if (t_3 == 24) {
            t_4 = *scratch >> (64 - 32);
            break;
          }
          t_3 += 8;
          *scratch |= ((uint64_t)(t_3));
        }
      }
      v_checksum_want = t_4;
    }
    if (!self->private_impl.f_ignore_checksum &&
        (v_checksum_got != v_checksum_want)) {
      status = WUFFS_ZLIB__ERROR_BAD_CHECKSUM;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_x = v_x;
  self->private_impl.c_decode[0].v_checksum_got = v_checksum_got;
  self->private_impl.c_decode[0].v_z = v_z;
  self->private_impl.c_decode[0].v_checksum_want = v_checksum_want;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_BASE__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_BASE__SUSPENSION_SHORT_READ;
  goto suspend;
}

#endif  // !defined(WUFFS_CONFIG__MODULES) ||
        // defined(WUFFS_CONFIG__MODULE__ZLIB)

#endif  // WUFFS_IMPLEMENTATION

#endif  // WUFFS_INCLUDE_GUARD
